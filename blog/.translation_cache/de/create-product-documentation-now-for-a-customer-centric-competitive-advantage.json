{
    "__metadata__": {
        "original_categories": [
            "Product Documentation",
            "Product Management",
            "Documentation Portals",
            "Product Updates",
            "Best Practices",
            "Product Documentation Tutorials"
        ],
        "author_name": "Ciaran Sweet",
        "author_email": "content@soseo.co",
        "author_info": "A freelance technology writer that covers everything B2B and B2C!",
        "author_image": "https://cdn.docsie.io/user_profiles/8627/logo_logo_3KANTfZMqHKSow4aOi8st9Rei1fu6Cg66XKlyoiAIKtLa.png",
        "header_image": "https://cdn.docsie.io/workspace_8D5W1pxgb7Jq3oZO7/doc_QpDdxIGnXpT0d02oQ/file_EXThNygmYp0Mmpk4M/boo_XGfvRm3TVTFbV6HET/06cd6fa0-e3a4-3bb5-0a91-15dab27628cfUntitled_1_min_1_2_3_4_5_6_7_8.jpg",
        "timestamp": "2021-07-02T11:46:42+00:00",
        "status": 1
    },
    "create-product-documentation-now-for-a-c|title": "Bewährte Methoden für Kundendokumentation 2025 | Leitfaden für Produktdokumentation | Technische Redakteure Produktmanager | Dokumentationsportale Vorlagen Tutorials | Wettbewerbsvorteil Strategie",
    "create-product-documentation-now-for-a-c|display_title": "Wie Produktdokumentation einen unschlagbaren Wettbewerbsvorteil schafft",
    "create-product-documentation-now-for-a-c|summary": "Bauen Sie Ihren kundenorientierten Wettbewerbsvorteil mit hervorragender Produktdokumentation auf",
    "create-product-documentation-now-for-a-c|markdown": "Als erste Anlaufstelle sollte jedes Unternehmen, das Produkte verkauft, überlegen, wie es Produktdokumentation erstellen kann. Dokumentation ist ein unbezahlbares Werkzeug, das Unternehmen dabei hilft, gezieltes Wissen mit ihrer Kundenbasis zu teilen. Wenn ein Unternehmen bei der Wissensvermittlung durch digitale Dokumentation überzeugt, schafft es einen bedeutenden kundenorientierten Wettbewerbsvorteil.\n\nBetrachten Sie die vorhandenen Marketing- oder Verkaufsmaterialien Ihres Unternehmens. Diese Materialien sind nicht maßgeblich und dienen ausschließlich der Bewerbung Ihrer Produkte – was Ihre Kunden auch wissen. Im Gegensatz dazu präsentiert die Produktdokumentation Ihr Produkt und dessen Funktionen. Sie erwärmt kalte Leads im Verkaufstrichter und erleichtert Cross- oder Upselling Ihres erweiterten Produktportfolios. Kurz gesagt: Produktdokumentation verleiht Ihrer Marke Autorität und schafft Vertrauen bei potenziellen wie auch bestehenden Kunden.\n\nDies wird durch eine IEEE-Studie belegt, die zeigt, wie die Zufriedenheit mit der Produktdokumentation direkt mit der wahrgenommenen Produktqualität korreliert. Je besser die Dokumentation, desto überzeugter sind Ihre Kunden von der Produktqualität!\n\nHaben Sie bereits Produktdokumentation? Lassen Sie uns in jedem Fall erkunden, wie Sie die Großartigkeit Ihres Produkts durch Produktdokumentation präsentieren können!\n\n## Formate der Produktdokumentation\n\nJe nach Komplexität Ihres Produkts kann es sinnvoll sein, ein bestimmtes Format für die Produktdokumentation zu verwenden:\n\n### 1. **All-in-One-Produktdokumentation**\n\nDie All-in-One-Produktdokumentation eignet sich für Unternehmen, die Produkte mit geringer Komplexität verkaufen. Ähnlich wie die Gelben Seiten (früher) alle lokalen Telefonnummern enthielten, befindet sich hier die gesamte Information zu Ihrem Produkt in einem einzigen Dokument.\n\nWenn Sie noch keine Produktdokumentation haben, kann ein All-in-One-Benutzerhandbuch kurzfristig ausreichen. Mit zunehmender Größe und Komplexität Ihres Produkts wird dieses Format jedoch wahrscheinlich nicht mehr tragfähig sein. Dies ist ein Paradebeispiel dafür, alle Ihre Produkt-Eier in einen Dokumentationskorb zu legen – was passiert, wenn der Korb voll oder kaputt ist?\n\n### 2. **Self-Service-Wissensportale**\n\nJeder, der im Kundenservice arbeitet, weiß, dass Self-Service-Wissensportale dem Unternehmen einen immensen Mehrwert bieten. Kunden stimmen zu – 89% der befragten Kunden in den USA erwarten, dass ein Wissensportal verfügbar ist. Auf gut Deutsch: Kunden wollen Zugang zu strukturierter digitaler Produktdokumentation mit Suchfunktion. Ohne diese wird Ihr Kundenservice-Team mit einfachen Produktfragen überhäuft.\n\nBei diesem Format sollten Produktdokumentationsautoren Inhalte für gute Lesbarkeit strukturieren. Kurze, prägnante Antworten schlagen langatmige Erklärungen, und häufig gestellte Fragen (FAQs) sollten auf der Startseite des Wissensportals im Vordergrund stehen.\n\n### 3. **Kontextuelle Produktdokumentation**\n\nUm die Kundenzufriedenheit zu maximieren, gehen Branchenführer noch einen Schritt weiter als ein Wissensportal. Kontextuelle Produktdokumentation integriert Wissen direkt in Ihr Produkt. Wenn ein Benutzer das Einstellungsmenü zum ersten Mal lädt, könnte kontextuelle Dokumentation eine schrittweise Anleitung zu jeder Funktion bieten. Alternativ könnte ein Wissensportal in der Seitenleiste eingebettet werden, sodass Wissen ohne zusätzliche Klicks gesucht werden kann.\n\nKontextuelle Produktdokumentation braucht Zeit zur Entwicklung, aber die Vorteile überwiegen die Kosten bei weitem. Diese Forrester-Studie zeigt, dass 73% der Befragten die Wertschätzung der Kundenzeit als entscheidend für guten Kundenservice ansehen. Kontextuelle Hilfe wertschätzt die Zeit der Kunden. Sie eliminiert Klicks und bietet sofortiges Wissen – dadurch können Kunden schneller produktiv werden.\n\n## Bauen Sie Ihren kundenorientierten Wettbewerbsvorteil mit Docsie auf\n\nOb Sie bereits Dokumentation haben oder noch gar keine – Docsie ist ein hervorragender Ausgangspunkt! Docsie bietet kundenorientierte Zusammenarbeit, umfassende Einbettungsmöglichkeiten, maßgeschneiderte Übersetzungen und leistungsstarkes Publishing – alles griffbereit.\n\n### Kunden verstehen durch Feedback-Möglichkeiten\n\nVerständnis fördert Empathie, und das Verstehen Ihrer Kundenbasis schafft Bewusstsein für deren Bedürfnisse. Für Verständnis brauchen Sie Daten.\n\nDocsie ermöglicht Kunden, Feedback zur Dokumentation zu geben, und sammelt diese Daten über Docsie Vocally. Hier finden Sie Kommentare zu Ihren Dokumenten, eine Bewertung des Lesers und eine Videoaufzeichnung, die genau zeigt, was der Leser angesehen hat.\n\nDaten führen zu Erkenntnissen, und Erkenntnisse leiten Handlungen. Nutzen Sie Docsie Vocally, um Kundenfeedback zu verstehen und den Wert Ihrer Dokumentation zu maximieren.\n\n[Vocally by Docsie](https://help.docsie.io/jsfiddle.net?doc=/using-docsie/quick-start/#header-three-dcdes)\n\n![Docsie Vocally Feedback-Formular](https://docsie-app-media.s3.amazonaws.com/image/7093/doc_GzKTESk1IUWjA77hg/hfqdsijgxnujiyvnbfdo \"Docsie Vocally Feedback-Formular\")\n\n### Strukturierung Ihres Wissensportals\n\nEin Wissensportal ist nur dann nützlich, wenn es für einfache Navigation strukturiert ist. Docsie bietet Struktur durch Bücher, Regale, Arbeitsbereiche und Inhaltsblöcke.\n\nAls Beispiel könnte ein \"Erste Schritte\"-Buch im Regal \"Ersteinrichtung\" stehen. Dieses befindet sich im Arbeitsbereich \"Mein Produktname\". Sie könnten ein weiteres \"Administration\"-Regal im selben Arbeitsbereich haben, mit einem Buch namens \"Benutzerverwaltung\". Durch die Strukturierung Ihrer Dokumentation mit diesen Docsie-Funktionen können Leser leicht nach relevanten Informationen suchen. Fügen Sie so viele Bücher und Regale hinzu, wie Sie benötigen – der Himmel ist die Grenze!\n\nWarum sollten Sie außerdem nur Text-Dokumentation veröffentlichen, wenn Sie sie mit Docsie-Inhaltsblöcken anreichern können? Begeistern Sie Ihre Kunden mit beweglichen, interaktiven Elementen auf der Seite! Neben Standard-Textformatierungen wie Überschriften, Listen und Aufzählungszeichen ermöglicht der Docsie Editor erweiterte Tooltips, Bild- oder Videointegration und iFrame-Skripteinbettung.\n\n![Docsie Editor Toolbar](https://docsie-app-media.s3.amazonaws.com/image/7093/doc_GzKTESk1IUWjA77hg/xiwdhdxekaikfcgveihi \"Docsie Editor Toolbar\")\n\n![Docsie Regale und Bücher in einem Arbeitsbereich](https://docsie-app-media.s3.amazonaws.com/image/7093/doc_GzKTESk1IUWjA77hg/fsatbpedsecqafstgwch \"Docsie Regale und Bücher in einem Arbeitsbereich\")\n\n[Was ist der Docsie Editor](https://help.docsie.io/?doc=/using-docsie/docsie-editor/adding-media/#section-header-two-ee89i)\n\n### Zentralisieren Sie Ihre Dokumente und perfektionieren Sie die Kunst des Publizierens\n\nBei großen Dokumentationsmengen kann Dezentralisierung zum Desaster führen. Durch die Zentralisierung Ihrer Dokumentation können Mitarbeiter Inhalte einfach erstellen und bearbeiten. Noch wichtiger ist, dass dies auch beim Veröffentlichen hilft.\n\nDocsie zentralisiert Dokumentation für einfachen Zugriff über Arbeitsbereiche. Ein gesamter Arbeitsbereich oder einzelne Regale und Bücher in diesem Arbeitsbereich können mit zwei Klicks veröffentlicht werden. Diese Dokumente werden auf Docsie-Servern gespeichert und gehostet, was hohe Verfügbarkeit und Zuverlässigkeit für Ihre Beruhigung bietet. Wenn Ihre Autoren Änderungen vornehmen, werden diese automatisch in Ihrem Live-Docsie-Wissensportal übernommen. Fortgeschrittene Benutzer können optional selbst hosten, was größere Anpassungsmöglichkeiten der Marke und technischere Seitenelemente-Integration ermöglicht.\n\n![Eine Live-Ansicht eines Docsie-Portals](https://docsie-app-media.s3.amazonaws.com/image/7093/doc_GzKTESk1IUWjA77hg/ztrwbdcjznqcqkgofnhz \"Eine Live-Ansicht eines Docsie-Portals\")\n\nAls Teil des Veröffentlichungsprozesses ermöglicht die Versionierung \"immergrüne\" Dokumentation, die sich mit Ihrem Produkt ändert. Wenn Sie Ihr Produkt von Version 1 auf Version 2 aktualisieren, folgt Ihre Dokumentation und veranschaulicht alle Änderungen. Kunden können dadurch neue Funktionen kennenlernen und sogar auf ältere Dokumentation zurückgreifen, wenn sie eine ältere Version Ihres Produkts verwenden oder benötigen.\n\n![Kontextmenü zum Veröffentlichen von Büchern und Regalen in Docsie](https://docsie-app-media.s3.amazonaws.com/image/7093/doc_GzKTESk1IUWjA77hg/fgzcadbebafclhvtrhvf \"Kontextmenü zum Veröffentlichen von Büchern und Regalen in Docsie\")\n\n![Versionsauswahl in einem Live-Docsie-Portal](https://docsie-app-media.s3.amazonaws.com/image/7093/doc_GzKTESk1IUWjA77hg/vuddxclgluvcgtupojou \"Versionsauswahl in einem Live-Docsie-Portal\")\n\n### Kontextuelle Dokumentation bereichert das Kundenerlebnis\n\nHaben Sie jemals ein Produkt benutzt und dann einen neuen Tab geöffnet, um zu suchen, wie man dieses Produkt verwendet? Diesem Produkt fehlt kontextuelle Dokumentation, und Sie mussten zusätzliche Arbeit leisten, um alles herauszufinden – nicht gut!\n\nDocsie-Benutzer können [TourGuide.js](https://github.com/LikaloLLC/tourguide.js/) nutzen, um Kunden geführte Touren anzubieten, ohne das Haupt-Produktdashboard zu verlassen. Das Ergebnis ähnelt einem integrierten Wissensportal, das in Ihr Produkt eingeblendet wird und kontextbezogene Ratschläge gibt, damit Benutzer schneller produktiv werden können.\n\n![TourGuide.js Beispiel-Walkthrough](https://docsie-app-media.s3.amazonaws.com/image/7093/doc_GzKTESk1IUWjA77hg/ebcdkxsfhzumealctwgl \"TourGuide.js Beispiel-Walkthrough\")",
    "create-product-documentation-now-for-a-c|category|0": "Produktdokumentation\n\u0000#ifndef GRAPHICS_INCLUDED\n#define GRAPHICS_INCLUDED\n\n#include <string>\n\n#include \"color.h\"\n#include \"dataStructures.h\"\n\nusing namespace std;\n\n/// \n/// \\brief The Graphics class\n/// This is an abstract class that is used to represent all the graphics objects\n/// in the system. It is the base class for Text, Circle, Rectangle, Triangle, Line, and Image.\n/// It also is used to represent groups of graphics objects.\n/// \nclass Graphics\n{\npublic:\n\n    /// \n    /// \\brief Graphics constructor with no parameters.\n    /// \n    Graphics();\n\n    /// \n    /// \\brief Graphics constructor with name parameter.\n    /// \\param name Name of graphics object. Does not need to be unique.\n    /// \n    Graphics(string name);\n\n    /// \n    /// \\brief Graphics destructor.\n    /// \n    virtual ~Graphics();\n\n    /// \n    /// \\brief draw Draw this object.\n    /// \\param x The x coordinate of where to draw this object.\n    /// \\param y The y coordinate of where to draw this object.\n    /// \n    virtual void draw(int x, int y) = 0;\n\n    /// \n    /// \\brief erase Erase this object.\n    /// \\param x The x coordinate of where to erase this object.\n    /// \\param y The y coordinate of where to erase this object.\n    /// \n    virtual void erase(int x, int y);\n\n    /// \n    /// \\brief getName Get the name of this object.\n    /// \\return Object's name.\n    /// \n    string getName();\n\n    /// \n    /// \\brief setName Set the name of this object.\n    /// \\param name The name to give this object.\n    /// \n    void setName(string name);\n\n    /// \n    /// \\brief getColor Get the color of this object.\n    /// \\return The color.\n    /// \n    Color getColor();\n\n    /// \n    /// \\brief setColor Set the color of this object.\n    /// \\param color The color.\n    /// \n    void setColor(Color color);\n\n    /// \n    /// \\brief setColor Set the color of this object.\n    /// \\param r The amount of red (0-255).\n    /// \\param g The amount of green (0-255).\n    /// \\param b The amount of blue (0-255).\n    /// \n    void setColor(short r, short g, short b);\n\n    /// \n    /// \\brief getNumChildren Get the number of child objects this object has.\n    /// \\return Number of child objects.\n    /// \n    virtual int getNumChildren();\n\n    /// \n    /// \\brief child Get a pointer to the specified child.\n    /// \\param i Index of the child.\n    /// \\return Pointer to the child, or nullptr if i is invalid.\n    /// \n    virtual Graphics* child(int i);\n\n    /// \n    /// \\brief addChild Add a child to this object.\n    /// \\param child The child to add. This object will assume ownership of the child. nullptr value is ignored.\n    /// \n    virtual void addChild(Graphics* child);\n\n    /// \n    /// \\brief removeAllChildren Remove and delete all children.\n    /// \n    virtual void removeAllChildren();\n\n    /// \n    /// \\brief removeChild Remove and delete the child at the specified index.\n    /// \\param i The index of the child to remove.\n    /// \n    virtual void removeChild(int i);\n\n    /// \n    /// \\brief removeChild Remove and delete the specified child object, if it exists.\n    /// \\param child The child to remove.\n    /// \n    virtual void removeChild(Graphics* child);\n\n    /// \n    /// \\brief translate Calculate the new coordinates after translation.\n    /// \\param x The original x coordinate.\n    /// \\param y The original y coordinate.\n    /// \\param translateX The x coordinate will be translated by this amount.\n    /// \\param translateY The y coordinate will be translated by this amount.\n    /// \\param newX This will be filled with the new x coordinate.\n    /// \\param newY This will be filled with the new y coordinate.\n    /// \n    static void translate(int x, int y, int translateX, int translateY, int* newX, int* newY);\n\n    /// \n    /// \\brief rotate Calculate the new coordinates after rotation.\n    /// \\param x The original x coordinate.\n    /// \\param y The original y coordinate.\n    /// \\param rotateX The x coordinate of the center of rotation.\n    /// \\param rotateY The y coordinate of the center of rotation.\n    /// \\param angle The angle of rotation, in radians.\n    /// \\param newX This will be filled with the new x coordinate.\n    /// \\param newY This will be filled with the new y coordinate.\n    /// \n    static void rotate(int x, int y, int rotateX, int rotateY, double angle, int* newX, int* newY);\n\n    /// \n    /// \\brief rotateAroundOrigin Calculate the new coordinates after rotating around the origin.\n    /// \\param x The original x coordinate.\n    /// \\param y The original y coordinate.\n    /// \\param angle The angle of rotation, in radians.\n    /// \\param newX This will be filled with the new x coordinate.\n    /// \\param newY This will be filled with the new y coordinate.\n    /// \n    static void rotateAroundOrigin(int x, int y, double angle, int* newX, int* newY);\n\n    /// \n    /// \\brief scale Calculate the new coordinates after scaling.\n    /// \\param x The original x coordinate.\n    /// \\param y The original y coordinate.\n    /// \\param scaleX The point will be scaled from this x coordinate.\n    /// \\param scaleY The point will be scaled from this y coordinate.\n    /// \\param scale The amount of scaling.\n    /// \\param newX This will be filled with the new x coordinate.\n    /// \\param newY This will be filled with the new y coordinate.\n    /// \n    static void scale(int x, int y, int scaleX, int scaleY, double scale, int* newX, int* newY);\n\nprotected:\n    string mName;\n    Color mColor;\n    Vector<Graphics*> mChildren;\n};\n\n#endif // GRAPHICS_INCLUDED\n\u0005End File\u0006# jyothisuhanip/Interactive-Graphics-System\n#ifndef VECTORHEADERDEF\n#define VECTORHEADERDEF\n\n#include <cassert>\n\n/*!\n * \\class Vector\n * \\brief A simple vector class for managing a dynamically sized array.\n * Vector stores its elements in a dynamically allocated array. When the\n * end of the array is reached, a new array of twice the size is allocated,\n * and the data from the old array is copied over. The old array is then deleted.\n */\ntemplate <class T>\nclass Vector\n{\nprivate:\n    T* mData;\n    int mSize;\n    int mCapacity;\n\npublic:\n    Vector();\n    ~Vector();\n    \n    /*! \\brief Returns the number of elements in the vector. */\n    int size() const;\n    \n    /*! \\brief Returns the capacity of the vector. */\n    int capacity() const;\n    \n    /*! \\brief Adds an element to the end of the vector. */\n    void push_back(const T& item);\n    \n    /*! \\brief Adds an element to the beginning of the vector. */\n    void push_front(const T& item);\n    \n    /*! \\brief Removes and returns the element at the end of the vector. */\n    T pop_back();\n    \n    /*! \\brief Removes and returns the element at the beginning of the vector. */\n    T pop_front();\n    \n    /*! \\brief Returns a reference to the element at the given index. */\n    T& operator[](int i);\n    \n    /*! \\brief Returns a const reference to the element at the given index. */\n    const T& operator[](int i) const;\n    \n    /*! \\brief Reserves capacity for at least n elements in the vector. */\n    void reserve(int n);\n    \n    /*! \\brief Changes the size of the vector. */\n    void resize(int n);\n    \n    /*! \\brief Removes all elements from the vector. */\n    void clear();\n    \n    /*! \\brief Removes the element at the given index. */\n    void erase(int index);\n};\n\ntemplate<class T>\nVector<T>::Vector()\n{\n    mSize = 0;\n    mCapacity = 10;\n    mData = new T[mCapacity];\n}\n\ntemplate<class T>\nVector<T>::~Vector()\n{\n    delete[] mData;\n}\n\ntemplate<class T>\nint Vector<T>::size() const\n{\n    return mSize;\n}\n\ntemplate<class T>\nint Vector<T>::capacity() const\n{\n    return mCapacity;\n}\n\ntemplate<class T>\nvoid Vector<T>::push_back(const T& item)\n{\n    if (mSize >= mCapacity)\n    {\n        reserve(mCapacity * 2);\n    }\n    \n    mData[mSize] = item;\n    mSize++;\n}\n\ntemplate<class T>\nvoid Vector<T>::push_front(const T& item)\n{\n    if (mSize >= mCapacity)\n    {\n        reserve(mCapacity * 2);\n    }\n    \n    for (int i = mSize; i > 0; i--)\n    {\n        mData[i] = mData[i - 1];\n    }\n    \n    mData[0] = item;\n    mSize++;\n}\n\ntemplate<class T>\nT Vector<T>::pop_back()\n{\n    assert(mSize > 0);\n    \n    mSize--;\n    return mData[mSize];\n}\n\ntemplate<class T>\nT Vector<T>::pop_front()\n{\n    assert(mSize > 0);\n    \n    T front = mData[0];\n    \n    for (int i = 1; i < mSize; i++)\n    {\n        mData[i - 1] = mData[i];\n    }\n    \n    mSize--;\n    return front;\n}\n\ntemplate<class T>\nT& Vector<T>::operator[](int i)\n{\n    assert(i >= 0);\n    assert(i < mSize);\n    \n    return mData[i];\n}\n\ntemplate<class T>\nconst T& Vector<T>::operator[](int i) const\n{\n    assert(i >= 0);\n    assert(i < mSize);\n    \n    return mData[i];\n}\n\ntemplate<class T>\nvoid Vector<T>::reserve(int n)\n{\n    if (n <= mCapacity)\n    {\n        return;\n    }\n    \n    T* newData = new T[n];\n    \n    for (int i = 0; i < mSize; i++)\n    {\n        newData[i] = mData[i];\n    }\n    \n    delete[] mData;\n    mData = newData;\n    mCapacity = n;\n}\n\ntemplate<class T>\nvoid Vector<T>::resize(int n)\n{\n    if (n <= 0)\n    {\n        clear();\n        return;\n    }\n    \n    if (n < mSize)\n    {\n        mSize = n;\n    }\n    else if (n > mSize)\n    {\n        if (n > mCapacity)\n        {\n            reserve(n);\n        }\n        \n        mSize = n;\n    }\n}\n\ntemplate<class T>\nvoid Vector<T>::clear()\n{\n    mSize = 0;\n}\n\ntemplate<class T>\nvoid Vector<T>::erase(int index)\n{\n    assert(index >= 0);\n    assert(index < mSize);\n    \n    for (int i = index + 1; i < mSize; i++)\n    {\n        mData[i - 1] = mData[i];\n    }\n    \n    mSize--;\n}\n\n#endif\n\u0005End File\u0006# jyothisuhanip/Interactive-Graphics-System\n#ifndef WINDOW_INCLUDED\n#define WINDOW_INCLUDED\n\n#include <string>\n#include <SDL.h>\n#include <SDL_ttf.h>\n#include <SDL_image.h>\n\n#include \"color.h\"\n#include \"graphics.h\"\n\nusing namespace std;\n\n/// \n/// \\brief The Window class\n/// The window class is used to display graphics objects on the screen.\n/// \nclass Window\n{\npublic:\n\n    /// \n    /// \\brief Window constructor.\n    /// The window is created with the specified dimensions and title.\n    /// \\param width The width of the window.\n    /// \\param height The height of the window.\n    /// \\param title The title of the window.\n    /// \n    Window(int width, int height, string title);\n\n    /// \n    /// \\brief Window destructor.\n    /// The window is destroyed and all resources are freed.\n    /// \n    ~Window();\n\n    /// \n    /// \\brief isOpen Check if the window is open.\n    /// \\return True if the window is open, false otherwise.\n    /// \n    bool isOpen() const;\n\n    /// \n    /// \\brief setGraphics Set the graphics object to be displayed in the window.\n    /// The window will take ownership of the graphics object. If there was\n    /// a previous graphics object, it will be deleted.\n    /// \\param graphics The graphics object to display.\n    /// \n    void setGraphics(Graphics* graphics);\n\n    /// \n    /// \\brief getGraphics Get the graphics object displayed in the window.\n    /// \\return The graphics object displayed in the window.\n    /// \n    Graphics* getGraphics() const;\n\n    /// \n    /// \\brief clear Clear the window.\n    /// \n    void clear();\n\n    /// \n    /// \\brief clear Clear the window with the specified color.\n    /// \\param r The red component of the color.\n    /// \\param g The green component of the color.\n    /// \\param b The blue component of the color.\n    /// \n    void clear(short r, short g, short b);\n\n    /// \n    /// \\brief clear Clear the window with the specified color.\n    /// \\param color The color to clear the window with.\n    /// \n    void clear(Color color);\n\n    /// \n    /// \\brief getBackgroundColor Get the background color of the window.\n    /// \\return The background color of the window.\n    /// \n    Color getBackgroundColor() const;\n\n    /// \n    /// \\brief setBackgroundColor Set the background color of the window.\n    /// \\param r The red component of the color.\n    /// \\param g The green component of the color.\n    /// \\param b The blue component of the color.\n    /// \n    void setBackgroundColor(short r, short g, short b);\n\n    /// \n    /// \\brief setBackgroundColor Set the background color of the window.\n    /// \\param color The color to set the background to.\n    /// \n    void setBackgroundColor(Color color);\n\n    /// \n    /// \\brief update Update the window.\n    /// Processes events and draws the graphics object.\n    /// \n    void update();\n\n    /// \n    /// \\brief update Update the window.\n    /// Processes events and draws the graphics object in the specified position.\n    /// \\param x The x coordinate of the graphics object.\n    /// \\param y The y coordinate of the graphics object.\n    /// \n    void update(int x, int y);\n\n    /// \n    /// \\brief handleEvents Handle any events.\n    /// \\return False if the user closes the window, true otherwise.\n    /// \n    bool handleEvents();\n\n    /// \n    /// \\brief delay Delay for the specified number of milliseconds.\n    /// \\param ms The number of milliseconds to delay.\n    /// \n    void delay(int ms);\n\n    /// \n    /// \\brief getWidth Get the width of the window.\n    /// \\return The width of the window.\n    /// \n    int getWidth() const;\n\n    /// \n    /// \\brief getHeight Get the height of the window.\n    /// \\return The height of the window.\n    /// \n    int getHeight() const;\n\n    /// \n    /// \\brief display Display the window.\n    /// \n    void display();\n\n    /// \n    /// \\brief getMouseX Get the x coordinate of the mouse.\n    /// \\return The x coordinate of the mouse.\n    /// \n    int getMouseX() const;\n\n    /// \n    /// \\brief getMouseY Get the y coordinate of the mouse.\n    /// \\return The y coordinate of the mouse.\n    /// \n    int getMouseY() const;\n\n    /// \n    /// \\brief getMouseButton Get the state of the mouse button.\n    /// \\return True if the mouse button is pressed, false otherwise.\n    /// \n    bool getMouseButton() const;\n\n    /// \n    /// \\brief draw Draw the graphics object.\n    /// \n    void draw();\n\n    /// \n    /// \\brief draw Draw the graphics object in the specified position.\n    /// \\param x The x coordinate of the graphics object.\n    /// \\param y The y coordinate of the graphics object.\n    /// \n    void draw(int x, int y);\n\n    /// \n    /// \\brief getTicks Get the number of milliseconds since the window was created.\n    /// \\return The number of milliseconds since the window was created.\n    /// \n    unsigned int getTicks() const;\n\nprivate:\n    SDL_Window* mWindow;\n    SDL_Renderer* mRenderer;\n    Graphics* mGraphics;\n    Color mBackgroundColor;\n    int mWidth;\n    int mHeight;\n    bool mIsOpen;\n    int mMouseX;\n    int mMouseY;\n    bool mMouseButton;\n};\n\n#endif // WINDOW_INCLUDED\n\u0005End File\u0006# jyothisuhanip/Interactive-Graphics-System\n# headers/map.h\n#ifndef MAPHEADERDEF\n#define MAPHEADERDEF\n\n#include <cassert>\n\n/*!\n * \\struct KeyValuePair\n * \\brief A simple key-value pair structure.\n */\ntemplate <class K, class V>\nstruct KeyValuePair\n{\n    K key;\n    V value;\n};\n\n/*!\n * \\class Map\n * \\brief A simple map class that maps keys to values.\n * The map is implemented as a dynamically sized array of key-value pairs.\n * There is no restriction on the key type except that it must be comparable.\n */\ntemplate <class K, class V>\nclass Map\n{\nprivate:\n    KeyValuePair<K, V>* mData;\n    int mSize;\n    int mCapacity;\n\npublic:\n    Map();\n    ~Map();\n    \n    /*! \\brief Returns the number of key-value pairs in the map. */\n    int size() const;\n    \n    /*! \\brief Returns the capacity of the map. */\n    int capacity() const;\n    \n    /*! \\brief Inserts a key-value pair into the map. */\n    void insert(const K& key, const V& value);\n    \n    /*! \\brief Returns a reference to the value associated with the given key. */\n    V& operator[](const K& key);\n    \n    /*! \\brief Returns a const reference to the value associated with the given key. */\n    const V& operator[](const K& key) const;\n    \n    /*! \\brief Returns true if the map contains the given key, false otherwise. */\n    bool containsKey(const K& key) const;\n    \n    /*! \\brief Removes the key-value pair with the given key from the map. */\n    void erase(const K& key);\n    \n    /*! \\brief Removes all key-value pairs from the map. */\n    void clear();\n    \n    /*! \\brief Returns the key at the given index. */\n    K keyAt(int index) const;\n    \n    /*! \\brief Returns the value at the given index. */\n    V valueAt(int index) const;\n    \n    /*! \\brief Returns a reference to the value at the given index. */\n    V& valueAt(int index);\n};\n\ntemplate<class K, class V>\nMap<K, V>::Map()\n{\n    mSize = 0;\n    mCapacity = 10;\n    mData = new KeyValuePair<K, V>[mCapacity];\n}\n\ntemplate<class K, class V>\nMap<K, V>::~Map()\n{\n    delete[] mData;\n}\n\ntemplate<class K, class V>\nint Map<K, V>::size() const\n{\n    return mSize;\n}\n\ntemplate<class K, class V>\nint Map<K, V>::capacity() const\n{\n    return mCapacity;\n}\n\ntemplate<class K, class V>\nvoid Map<K, V>::insert(const K& key, const V& value)\n{\n    for (int i = 0; i < mSize; i++)\n    {\n        if (mData[i].key == key)\n        {\n            mData[i].value = value;\n            return;\n        }\n    }\n    \n    if (mSize >= mCapacity)\n    {\n        int newCapacity = mCapacity * 2;\n        KeyValuePair<K, V>* newData = new KeyValuePair<K, V>[newCapacity];\n        \n        for (int i = 0; i < mSize; i++)\n        {\n            newData[i] = mData[i];\n        }\n        \n        delete[] mData;\n        mData = newData;\n        mCapacity = newCapacity;\n    }\n    \n    mData[mSize].key = key;\n    mData[mSize].value = value;\n    mSize++;\n}\n\ntemplate<class K, class V>\nV& Map<K, V>::operator[](const K& key)\n{\n    for (int i = 0; i < mSize; i++)\n    {\n        if (mData[i].key == key)\n        {\n            return mData[i].value;\n        }\n    }\n    \n    if (mSize >= mCapacity)\n    {\n        int newCapacity = mCapacity * 2;\n        KeyValuePair<K, V>* newData = new KeyValuePair<K, V>[newCapacity];\n        \n        for (int i = 0; i < mSize; i++)\n        {\n            newData[i] = mData[i];\n        }\n        \n        delete[] mData;\n        mData = newData;\n        mCapacity = newCapacity;\n    }\n    \n    mData[mSize].key = key;\n    mSize++;\n    \n    return mData[mSize - 1].value;\n}\n\ntemplate<class K, class V>\nconst V& Map<K, V>::operator[](const K& key) const\n{\n    for (int i = 0; i < mSize; i++)\n    {\n        if (mData[i].key == key)\n        {\n            return mData[i].value;\n        }\n    }\n    \n    assert(false);\n}\n\ntemplate<class K, class V>\nbool Map<K, V>::containsKey(const K& key) const\n{\n    for (int i = 0; i < mSize; i++)\n    {\n        if (mData[i].key == key)\n        {\n            return true;\n        }\n    }\n    \n    return false;\n}\n\ntemplate<class K, class V>\nvoid Map<K, V>::erase(const K& key)\n{\n    for (int i = 0; i < mSize; i++)\n    {\n        if (mData[i].key == key)\n        {\n            for (int j = i + 1; j < mSize; j++)\n            {\n                mData[j - 1] = mData[j];\n            }\n            \n            mSize--;\n            return;\n        }\n    }\n}\n\ntemplate<class K, class V>\nvoid Map<K, V>::clear()\n{\n    mSize = 0;\n}\n\ntemplate<class K, class V>\nK Map<K, V>::keyAt(int index) const\n{\n    assert(index >= 0);\n    assert(index < mSize);\n    \n    return mData[index].key;\n}\n\ntemplate<class K, class V>\nV Map<K, V>::valueAt(int index) const\n{\n    assert(index >= 0);\n    assert(index < mSize);\n    \n    return mData[index].value;\n}\n\ntemplate<class K, class V>\nV& Map<K, V>::valueAt(int index)\n{\n    assert(index >= 0);\n    assert(index < mSize);\n    \n    return mData[index].value;\n}\n\n#endif\n\u0000/*\n * Copyright (c) 2005 Topspin Communications.  All rights reserved.\n * Copyright (c) 2006 Cisco Systems.  All rights reserved.\n *\n * This software is available to you under a choice of one of two\n * licenses.  You may choose to be licensed under the terms of the GNU\n * General Public License (GPL) Version 2, available from the file\n * COPYING in the main directory of this source tree, or the\n * OpenIB.org BSD license below:\n *\n *     Redistribution and use in source and binary forms, with or\n *     without modification, are permitted provided that the following\n *     conditions are met:\n *\n *      - Redistributions of source code must retain the above\n *        copyright notice, this list of conditions and the following\n *        disclaimer.\n *\n *      - Redistributions in binary form must reproduce the above\n *        copyright notice, this list of conditions and the following\n *        disclaimer in the documentation and/or other materials\n *        provided with the distribution.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS\n * BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN\n * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\n * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n */\n\n#if HAVE_CONFIG_H\n#  include <config.h>\n#endif /* HAVE_CONFIG_H */\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <unistd.h>\n#include <string.h>\n#include <limits.h>\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <sys/time.h>\n#include <netdb.h>\n#include <malloc.h>\n#include <getopt.h>\n#include <arpa/inet.h>\n#include <inttypes.h>\n#include <signal.h>\n#include <infiniband/verbs.h>\n#include <endian.h>\n#include <byteswap.h>\n#include <pthread.h>\n#include <sys/mman.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <infiniband/driver.h>\n#include <math.h>\n\n#define MAX_INLINE_SIZE\t256\n#define MAX_NAME_LEN    20\n#define DEFAULT_NUMA_NODE 1\n#define CPUSET_SIZE     128\n\nenum ibv_mtu set_mtu = IBV_MTU_4096;\nenum ibv_mtu effective_mtu;\nstatic int\tpage_size;\n\n#define MICROSEC\t   1000000\n#define MAX_QUEUEPAIR_NUM 16\n#define\tMILIISECOND   1000\n#define KILO          1024\n#define MEGA          (KILO*KILO)\n#define GIGA          (MEGA*KILO)\n\n// MPI\n#define MPI_RANK_KEY 0x1234\n#define MSG_INIT_SIZE 100\n\nuint64_t BARRIER_MASK = 0xaaaaaaaaaaaaaaaa;\nuint64_t NORMAL_MASK  = 0xaaaaaaaa5a5a5a5a;\n\nint is_server;\n\nstruct qp_context{\n\tint qp_id;\n\tpthread_t qp_thread;\n\tstruct ibv_mr *(*mr_create)(struct ibv_pd *pd, void *addr, size_t length,\n\t\t\t\t    int access, size_t buf_size, int lkey, int rkey);\n\tstruct ibv_mr *(*mr_create_notify)(struct ibv_pd *pd, void *addr, size_t length,\n\t\t\t\t\t   int access, size_t buf_size, int lkey, int rkey);\n\tstruct ibv_mr *(*mr_create_all)(struct ibv_pd *pd, void *addr, size_t length,\n\t\t\t\t\tint access, size_t buf_size, int lkey, int rkey);\n\tstruct ibv_mr *(*mr_notify)(struct ibv_pd *pd, void *addr, size_t length,\n\t\t\t\t    int access, size_t buf_size, int lkey, int rkey);\n\tstruct ibv_mr *(*mr_resize)(struct ibv_pd *pd, void *addr, size_t length,\n\t\t\t\t    int access, size_t buf_size, int lkey, int rkey);\n};\n\nstruct qp_context qp_ctx[MAX_QUEUEPAIR_NUM]; // MAX 64\n\n// Message for QP to handle\nstruct ibv_mr *mpi_init_msg;\n\n#if __BYTE_ORDER == __LITTLE_ENDIAN\ninline uint64_t htonll(uint64_t x) { return bswap_64(x); }\ninline uint64_t ntohll(uint64_t x) { return bswap_64(x); }\n#elif __BYTE_ORDER == __BIG_ENDIAN\ninline uint64_t htonll(uint64_t x) { return x; }\ninline uint64_t ntohll(uint64_t x) { return x; }\n#else\n#error __BYTE_ORDER is neither __LITTLE_ENDIAN nor __BIG_ENDIAN\n#endif\n\n\n//#define DEBUG\n#ifdef DEBUG\n#define LOG(f, ...) printf(\"[%s] \"f, __func__, ##__VA_ARGS__)\n#define ENTER() printf(\"[%s] Begin\\n\", __func__)\n#define EXIT() printf(\"[%s] End\\n\", __func__)\n#else\n#define LOG(f, ...)\n#define ENTER()\n#define EXIT()\n#endif\n\n//For CPU binding\nstatic void setCPU(int cpu_idx) {\n\tint status;\n\tcpu_set_t my_set;\n\tCPU_ZERO(&my_set);\n\tCPU_SET(cpu_idx, &my_set);\n\tstatus = sched_setaffinity(0, sizeof(cpu_set_t), &my_set);\n\tif (status != 0) {\n\t\tperror(\"sched_setaffinity error\");\n\t}\n}\n\nstatic void set_cpu_socket(int socket_idx) {\n\tint status;\n\tint cpus_per_socket = sysconf(_SC_NPROCESSORS_ONLN) / 2;\n\tcpu_set_t my_set;\n\tCPU_ZERO(&my_set);\n\tif (socket_idx == 0) {\n\t\tfor (int i = 0; i < cpus_per_socket; i++) {\n\t\t\tCPU_SET(i, &my_set);\n\t\t}\n\t} else {\n\t\tfor (int i = cpus_per_socket; i < cpus_per_socket * 2; i++) {\n\t\t\tCPU_SET(i, &my_set);\n\t\t}\n\t}\n\n\tstatus = sched_setaffinity(0, sizeof(cpu_set_t), &my_set);\n\tif (status != 0) {\n\t\tperror(\"sched_setaffinity error\");\n\t}\n\n}\n\n//\n// Common function\n//\n\n// Utilities\n\n// For threads\ntypedef struct {\n\tpthread_mutex_t mutex;\n\tpthread_cond_t  cond;\n\tint \t\t\tval;\n} shared_int;\n\nint shared_int_create(shared_int *obj);\nint shared_int_destroy(shared_int *obj);\nint shared_int_reset(shared_int *obj);\nint shared_int_set(shared_int *obj, int val);\nint shared_int_get(shared_int *obj);\nint shared_int_add(shared_int *obj, int delta);\nint shared_int_get_and_add(shared_int *obj, int delta);\nint shared_int_barrier(shared_int *obj, int val);\nint shared_int_wait_neq(shared_int *obj, int val);\nint shared_int_wait_eq(shared_int *obj, int val);\nint shared_int_wait_geq(shared_int *obj, int val);\n\n// Parse user CLI args\nstruct config_t {\n\tconst char\t\t*dev_name;\n\tchar\t\t\tserver_name[MAX_NAME_LEN];\n\tu_int32_t\t\ttcp_port;\n\tu_int32_t\t\tib_port;\n\tint\t\t\tnuma_node;\n\tu_int32_t\t\tqp_timeout;\n\tu_int32_t\t\tqp_retry_cnt;\n\tu_int32_t\t\tqp_rnr_retry;\n\tenum ibv_mtu\t\tmtu;\n\tint\t\t\tsl;\n\tint\t\t\tgidx;\n\tint\t\t\tsgid_idx;\n\n\t// client\n\tint \t\tqp_num; // used to identify the qp\n\t\n};\n\n// IB/ROCE Resources\nstruct resource_t {\n\tstruct ibv_device_attr\tdevice_attr;\n\tstruct ibv_port_attr\tport_attr;\n\tstruct ibv_context\t*ib_ctx;\n\tstruct ibv_pd\t\t*pd;\n\tstruct ibv_cq\t\t*cq;\n\tstruct ibv_qp\t\t*qp;\n\tstruct ibv_mr\t\t*mr;\n\tstruct ibv_mr\t\t*notify_mr;\n\tstruct ibv_mr\t\t*all_mr;\n\tstruct ibv_mr\t\t*resize_mr;\n\tstruct ibv_port_attr\t*port_info;\n\tvoid\t\t\t*ib_buf;\n\tint\t\t\tsock;\n\tint \t\tid;\n\tint\t\t\tsize;\n\tint\t\t\tsend_flags;\n\tint\t\t\trx_depth;\n\tint\t\t\tpending;\n\tstruct ibv_send_wr\twr;\n\tstruct ibv_sge\t\tlist;\n\tunion ibv_gid\t\tmy_gid;\n\tchar\t\t\t*mmap_buf;\n\tint \t\tmr_all_size;\n\tint \t\tmr_notify_size;\n};\n\nstruct pingpong_dest {\n\tint\t\tlid;\n\tint\t\tqpn;\n\tint\t\tpsn;\n\tunsigned\trkey;\n\tunsigned\tvaddr;\n\tunion ibv_gid\tgid;\n};\n\n\n// Function Implementations\nstatic int sock_connect(const char *servername, int port) {\n\tstruct addrinfo *res, *t;\n\tstruct addrinfo hints = {\n\t\t.ai_family   = AF_INET,\n\t\t.ai_socktype = SOCK_STREAM\n\t};\n\tchar *service;\n\tint n;\n\tint sockfd = -1;\n\tint err;\n\n\tif (asprintf(&service, \"%d\", port) < 0)\n\t\treturn -1;\n\n\terr = getaddrinfo(servername, service, &hints, &res);\n\n\tif (err < 0) {\n\t\tfprintf(stderr, \"%s for %s:%d\\n\", gai_strerror(err), servername, port);\n\t\tfree(service);\n\t\treturn -1;\n\t}\n\n\tfor (t = res; t; t = t->ai_next) {\n\t\tsockfd = socket(t->ai_family, t->ai_socktype, t->ai_protocol);\n\t\tif (sockfd >= 0) {\n\t\t\tn = 1;\n\n\t\t\tsetsockopt(sockfd, SOL_SOCKET, SO_REUSEADDR, &n, sizeof n);\n\n\t\t\tif (!connect(sockfd, t->ai_addr, t->ai_addrlen))\n\t\t\t\tbreak;\n\t\t\tclose(sockfd);\n\t\t\tsockfd = -1;\n\t\t}\n\t}\n\n\tfreeaddrinfo(res);\n\tfree(service);\n\n\tif (sockfd < 0) {\n\t\tfprintf(stderr, \"Couldn't connect to %s:%d\\n\", servername, port);\n\t\treturn -1;\n\t}\n\n\treturn sockfd;\n}\n\nstatic int sock_bind(int port) {\n\tstruct sockaddr_in addr;\n\tint sfd;\n\tint flags;\n\tint yes = 1;\n\n\tsfd = socket(AF_INET, SOCK_STREAM, 0);\n\tif (sfd == -1) {\n\t\tperror(\"socket\");\n\t\treturn -1;\n\t}\n\n\tif (setsockopt(sfd, SOL_SOCKET, SO_REUSEADDR, &yes, sizeof(yes)) == -1) {\n\t\tperror(\"setsockopt\");\n\t\treturn -1;\n\t}\n\n\tmemset(&addr, 0, sizeof addr);\n\taddr.sin_family = AF_INET;\n\taddr.sin_port = htons(port);\n\taddr.sin_addr.s_addr = htonl(INADDR_ANY);\n\tif (bind(sfd, (struct sockaddr *)&addr, sizeof addr) == -1) {\n\t\tperror(\"bind\");\n\t\treturn -1;\n\t}\n\n\tflags = fcntl(sfd, F_GETFL);\n\tif (flags == -1) {\n\t\tperror(\"fcntl F_GETFL\");\n\t\treturn -1;\n\t}\n\n\tif (fcntl(sfd, F_SETFL, flags | O_NONBLOCK) == -1) {\n\t\tperror(\"fcntl F_SETFL O_NONBLOCK\");\n\t\treturn -1;\n\t}\n\n\tlisten(sfd, 5);\n\n\treturn sfd;\n}\n\nstatic int sock_accept(int sockfd) {\n\tstruct sockaddr_in addr;\n\tsocklen_t len = sizeof addr;\n\tint sfd;\n\n\tsfd = accept(sockfd, (struct sockaddr *)&addr, &len);\n\tif (sfd == -1) {\n\t\tperror(\"accept\");\n\t\treturn -1;\n\t}\n\n\treturn sfd;\n}\n\nstatic int sock_sync_data(int sock, int xfer_size, char *local_data, char *remote_data) {\n\tint rc;\n\tint read_bytes = 0;\n\tint total_read_bytes = 0;\n\n\trc = write(sock, local_data, xfer_size);\n\tif (rc < xfer_size)\n\t\tfprintf(stderr, \"Failed writing data during sock_sync_data, total bytes %d\\n\", rc);\n\telse\n\t\trc = 0;\n\n\twhile (!rc && total_read_bytes < xfer_size) {\n\t\tread_bytes = read(sock, remote_data + total_read_bytes, xfer_size - total_read_bytes);\n\t\tif (read_bytes > 0) {\n\t\t\ttotal_read_bytes += read_bytes;\n\t\t} else {\n\t\t\trc = read_bytes;\n\t\t}\n\t}\n\n\treturn rc;\n}\n\nstatic void wire_gid_to_gid(const char *wgid, union ibv_gid *gid) {\n\tchar tmp[9];\n\tuint32_t v32;\n\tint i;\n\n\tfor (tmp[8] = 0, i = 0; i < 4; ++i) {\n\t\tmemcpy(tmp, wgid + i * 8, 8);\n\t\tsscanf(tmp, \"%x\", &v32);\n\t\t*(uint32_t *)(&gid->raw[i * 4]) = ntohl(v32);\n\t}\n}\n\nstatic void gid_to_wire_gid(const union ibv_gid *gid, char wgid[]) {\n\tint i;\n\n\tfor (i = 0; i < 4; ++i)\n\t\tsprintf(&wgid[i * 8], \"%08x\", htonl(*(uint32_t *)(gid->raw + i * 4)));\n}\n\n// IB Init\nstatic int init_env(struct resource_t *res) {\n\tstruct ibv_device **dev_list;\n\tint i;\n\tint num_devices;\n\t\n\tif (!res) {\n\t\tfprintf(stderr, \"Init Environment with empty resource.\\n\");\n\t\treturn 1;\n\t}\n\n\t// Get IB device list\n\tdev_list = ibv_get_device_list(&num_devices);\n\tif (!dev_list) {\n\t\tfprintf(stderr, \"Failed to get IB devices list.\\n\");\n\t\treturn 1;\n\t}\n\n\t// Check if the requested device exists\n\tfor (i = 0; i < num_devices; i ++) {\n\t\tif (!dev_list[i]) {\n\t\t\tfprintf(stderr, \"Device list is empty.\\n\");\n\t\t\treturn 1;\n\t\t}\n\t\tprintf(\"Get Device[%d]: %s\\n\", i, ibv_get_device_name(dev_list[i]));\n\t}\n\n\tres->ib_ctx = ibv_open_device(dev_list[0]);\n\tif (!res->ib_ctx) {\n\t\tfprintf(stderr, \"Failed to open device %s\\n\", ibv_get_device_name(dev_list[0]));\n\t\treturn 1;\n\t}\n\n\tibv_free_device_list(dev_list);\n\tdev_list = NULL;\n\n\tif (ibv_query_device(res->ib_ctx, &res->device_attr)) {\n\t\tfprintf(stderr, \"Failed to query device props\");\n\t\treturn 1;\n\t}\n\tprintf(\"max_qp=%d, max_cq=%d, max_mr=%d\\n\",\n\t       res->device_attr.max_qp, res->device_attr.max_cq, res->device_attr.max_mr);\n\n\n\treturn 0;\n}\n\nstatic int init_resource(struct resource_t *res, struct config_t *cfg) {\n\t// Verify port number\n\tif (cfg->ib_port > 0) {\n\t\tif (cfg->ib_port > res->device_attr.phys_port_cnt) {\n\t\t\tfprintf(stderr, \"Invalid port number %d. It can be 1~%d\\n\",\n\t\t\t\tcfg->ib_port, res->device_attr.phys_port_cnt);\n\t\t\treturn 1;\n\t\t}\n\t} else {\n\t\tfprintf(stderr, \"Missing IB port configuration\\n\");\n\t\treturn 1;\n\t}\n\tres->id = cfg->qp_num;\n\tprintf(\"Create QP with ID %d\\n\", res->id);\n\t\n\t// Verify port attribute\n\tif (ibv_query_port(res->ib_ctx, cfg->ib_port, &res->port_attr)) {\n\t\tfprintf(stderr, \"Failed to query port attribute\\n\");\n\t\treturn 1;\n\t}\n\n\t// Create PD\n\tres->pd = ibv_alloc_pd(res->ib_ctx);\n\tif (!res->pd) {\n\t\tfprintf(stderr, \"Failed to allocate PD\\n\");\n\t\treturn 1;\n\t}\n\n\tres->rx_depth = 500;\n\t\n\tstruct ibv_cq_init_attr_ex cq_attr = {\n\t\t.cqe = 2048,\n\t\t.cq_context = NULL,\n\t\t.channel = NULL,\n\t\t.comp_vector = 0\n\t};\n\t\n\tres->cq = ibv_create_cq(res->ib_ctx, cq_attr.cqe, NULL, NULL, 0);\n\tif (!res->cq) {\n\t\tfprintf(stderr, \"Failed to create CQ\\n\");\n\t\treturn 1;\n\t}\n\n\treturn 0;\n}\n\n\nstatic struct ibv_mr *create_one_mr(struct ibv_pd *pd, void *addr, size_t length,\n\t\t\t\t    int access, size_t buf_size, int lkey, int rkey) {\n\tstruct ibv_mr *mr;\n\tmr = ibv_reg_mr(pd, addr, length, access);\n\tif (!mr) {\n\t\tfprintf(stderr, \"Failed to register MR\\n\");\n\t\treturn NULL;\n\t}\n\tprintf(\"MR was registered with addr=%p, lkey=0x%x, rkey=0x%x, flags=0x%x\\n\",\n\t       addr, mr->lkey, mr->rkey, mr->handle);\n\treturn mr;\n}\n\nstatic struct ibv_mr *create_mr(struct ibv_pd *pd, void *addr, size_t length,\n\t\t\t\tint access, size_t buf_size, int lkey, int rkey) {\n\tvoid* cpu_addr = malloc(buf_size);\n\tif (!cpu_addr) {\n\t\tfprintf(stderr, \"Failed to allocate memory\\n\");\n\t\treturn NULL;\n\t}\n\tmemset(cpu_addr, 0, buf_size);\n\tstruct ibv_mr *mr;\n\tmr = ibv_reg_mr(pd, cpu_addr, buf_size, access);\n\tif (!mr) {\n\t\tfprintf(stderr, \"Failed to register MR\\n\");\n\t\treturn NULL;\n\t}\n\tprintf(\"MR was registered with addr=%p, lkey=0x%x, rkey=0x%x, flags=0x%x\\n\",\n\t       cpu_addr, mr->lkey, mr->rkey, mr->handle);\n\treturn mr;\n}\n\nstatic struct ibv_mr *create_mr_notify(struct ibv_pd *pd, void *addr, size_t length,\n\t\t\t\t       int access, size_t buf_size, int lkey, int rkey) {\n\tvoid* cpu_addr = malloc(buf_size);\n\tif (!cpu_addr) {\n\t\tfprintf(stderr, \"Failed to allocate memory\\n\");\n\t\treturn NULL;\n\t}\n\tmemset(cpu_addr, 0, buf_size);\n\tint notify_access = IBV_ACCESS_LOCAL_WRITE | IBV_ACCESS_REMOTE_WRITE | IBV_ACCESS_REMOTE_READ;\n\tstruct ibv_mr *mr;\n\tmr = ibv_reg_mr(pd, cpu_addr, buf_size, notify_access);\n\tif (!mr) {\n\t\tfprintf(stderr, \"Failed to register MR\\n\");\n\t\treturn NULL;\n\t}\n\tprintf(\"MR was registered with addr=%p, lkey=0x%x, rkey=0x%x, flags=0x%x\\n\",\n\t       cpu_addr, mr->lkey, mr->rkey, mr->handle);\n\treturn mr;\n}\n\nstatic struct ibv_mr *create_mr_all(struct ibv_pd *pd, void *addr, size_t length,\n\t\t\t\t    int access, size_t buf_size, int lkey, int rkey) {\n\tvoid* cpu_addr = malloc(buf_size);\n\tif (!cpu_addr) {\n\t\tfprintf(stderr, \"Failed to allocate memory\\n\");\n\t\treturn NULL;\n\t}\n\tmemset(cpu_addr, 0, buf_size);\n\tstruct ibv_mr *mr;\n\tmr = ibv_reg_mr(pd, cpu_addr, buf_size, access);\n\tif (!mr) {\n\t\tfprintf(stderr, \"Failed to register MR\\n\");\n\t\treturn NULL;\n\t}\n\tprintf(\"MR was registered with addr=%p, lkey=0x%x, rkey=0x%x, flags=0x%x\\n\",\n\t       cpu_addr, mr->lkey, mr->rkey, mr->handle);\n\treturn mr;\n}\n\nstatic struct ibv_mr *notify_mr(struct ibv_pd *pd, void *addr, size_t length,\n\t\t\t\tint access, size_t buf_size, int lkey, int rkey) {\n\tint notify_access = IBV_ACCESS_LOCAL_WRITE | IBV_ACCESS_REMOTE_WRITE | IBV_ACCESS_REMOTE_READ;\n\tstruct ibv_mr *mr;\n\tmr = ibv_reg_mr(pd, addr, length, notify_access);\n\tif (!mr) {\n\t\tfprintf(stderr, \"Failed to register MR\\n\");\n\t\treturn NULL;\n\t}\n\tprintf(\"MR was registered with addr=%p, lkey=0x%x, rkey=0x%x, flags=0x%x\\n\",\n\t       addr, mr->lkey, mr->rkey, mr->handle);\n\treturn mr;\n}\n\nstatic struct ibv_mr *resize_mr(struct ibv_pd *pd, void *addr, size_t length,\n\t\t\t\tint access, size_t buf_size, int lkey, int rkey) {\n\tstruct ibv_mr *mr;\n\tmr = ibv_reg_mr(pd, addr, length, access);\n\tif (!mr) {\n\t\tfprintf(stderr, \"Failed to register MR\\n\");\n\t\treturn NULL;\n\t}\n\tprintf(\"MR was registered with addr=%p, lkey=0x%x, rkey=0x%x, flags=0x%x\\n\",\n\t       addr, mr->lkey, mr->rkey, mr->handle);\n\treturn mr;\n}\n\nstatic int create_mr_all_for_alloc(struct resource_t* res, struct config_t* cfg, int size) {\n\tres->mr_all_size = size;\n\tint access = IBV_ACCESS_LOCAL_WRITE | IBV_ACCESS_REMOTE_WRITE | IBV_ACCESS_REMOTE_READ;\n\tres->all_mr = qp_ctx[res->id].mr_create_all(res->pd, NULL, 0, access, size, 0, 0);\n\tif (!res->all_mr) {\n\t\tfprintf(stderr, \"Failed to create mr for alloc\\n\");\n\t\treturn 1;\n\t}\n\treturn 0;\n}\n\nstatic int create_mr_notify_for_alloc(struct resource_t* res, struct config_t* cfg, int size) {\n\tres->mr_notify_size = size;\n\tint access = IBV_ACCESS_LOCAL_WRITE | IBV_ACCESS_REMOTE_WRITE | IBV_ACCESS_REMOTE_READ;\n\tres->notify_mr = qp_ctx[res->id].mr_create_notify(res->pd, NULL, 0, access, size, 0, 0);\n\tif (!res->notify_mr) {\n\t\tfprintf(stderr, \"Failed to create mr for alloc\\n\");\n\t\treturn 1;\n\t}\n\treturn 0;\n}\n\nstatic void alloc_hugepage(struct resource_t* res, struct config_t* cfg, int size) {\n\tif (res->mmap_buf != NULL) {\n\t\tmunmap(res->mmap_buf, res->size);\n\t}\n\t\n\tpage_size = sysconf(_SC_PAGESIZE);\n\tint huge_page_size = 1 << 30; // 1GB\n\t\n\tsize = (size + huge_page_size - 1) & ~(huge_page_size - 1);\n\t\n\tres->size = size;\n\n\t//int type = 21; //MAP_HUGETLB | MAP_HUGE_1GB;\n\tint fd = memfd_create(\"buffer\", 0);\n\tif (fd < 0) {\n\t\tfprintf(stderr, \"memfd_create failed\\n\");\n\t\treturn;\n\t}\n\t\n\tif (ftruncate(fd, size) < 0) {\n\t\tfprintf(stderr, \"ftruncate failed\\n\");\n\t\treturn;\n\t}\n\t\n\tvoid* addr = mmap(NULL, size, PROT_READ | PROT_WRITE, MAP_SHARED, fd, 0);\n\tif (addr == MAP_FAILED) {\n\t\tfprintf(stderr, \"mmap failed\\n\");\n\t\treturn;\n\t}\n\t\n\tclose(fd);\n\n\tmemset(addr, 0, size);\n\t\n\tres->mmap_buf = addr;\n\tLOG(\"Allocated %d bytes at %p\\n\", size, addr);\n}\n\nstatic int create_qp(struct resource_t *res, struct config_t *cfg) {\n\tprintf(\"Creating QP %d\\n\", res->id);\n\t\n\tstruct ibv_qp_init_attr qp_init_attr = {\n\t\t.send_cq = res->cq,\n\t\t.recv_cq = res->cq,\n\t\t.cap = {\n\t\t\t.max_send_wr = 2048,\n\t\t\t.max_recv_wr = 2048,\n\t\t\t.max_send_sge = 1,\n\t\t\t.max_recv_sge = 1\n\t\t},\n\t\t.qp_type = IBV_QPT_RC,\n\t\t.sq_sig_all = 0\n\t};\n\n\tres->qp = ibv_create_qp(res->pd, &qp_init_attr);\n\tif (!res->qp) {\n\t\tfprintf(stderr, \"Failed to create QP\\n\");\n\t\treturn 1;\n\t}\n\tprintf(\"QP was created, QP number=0x%x\\n\", res->qp->qp_num);\n\n\treturn 0;\n}\n\nstatic int modify_qp_to_init(struct resource_t *res, struct config_t* cfg) {\n\tstruct ibv_qp_attr attr = {\n\t\t.qp_state = IBV_QPS_INIT,\n\t\t.pkey_index = 0,\n\t\t.port_num = cfg->ib_port,\n\t\t.qp_access_flags = IBV_ACCESS_LOCAL_WRITE | IBV_ACCESS_REMOTE_READ | IBV_ACCESS_REMOTE_WRITE\n\t};\n\n\tint flags = IBV_QP_STATE | IBV_QP_PKEY_INDEX | IBV_QP_PORT | IBV_QP_ACCESS_FLAGS;\n\tint rc = ibv_modify_qp(res->qp, &attr, flags);\n\tif (rc) {\n\t\tfprintf(stderr, \"Failed to modify QP to INIT\\n\");\n\t\treturn 1;\n\t}\n\treturn 0;\n}\n\nstatic int modify_qp_to_rtr(struct resource_t *res, struct config_t* cfg, uint32_t remote_qpn, uint16_t dlid, uint8_t *dgid) {\n\tstruct ibv_qp_attr attr = {\n\t\t.qp_state = IBV_QPS_RTR,\n\t\t.path_mtu = cfg->mtu,\n\t\t.dest_qp_num = remote_qpn,\n\t\t.rq_psn = 0,\n\t\t.max_dest_rd_atomic = 1,\n\t\t.min_rnr_timer = 0x12,\n\t\t.ah_attr = {\n\t\t\t.is_global = 0,\n\t\t\t.dlid = dlid,\n\t\t\t.sl = cfg->sl,\n\t\t\t.src_path_bits = 0,\n\t\t\t.port_num = cfg->ib_port\n\t\t}\n\t};\n\n\tif (cfg->gidx >= 0) {\n\t\tattr.ah_attr.is_global = 1;\n\t\tattr.ah_attr.port_num = 1;\n\t\tmemcpy(&attr.ah_attr.grh.dgid, dgid, 16);\n\t\tattr.ah_attr.grh.flow_label = 0;\n\t\tattr.ah_attr.grh.hop_limit = 1;\n\t\tattr.ah_attr.grh.sgid_index = cfg->sgid_idx;\n\t\tattr.ah_attr.grh.traffic_class = 0;\n\t}\n\n\tint flags = IBV_QP_STATE | IBV_QP_AV | IBV_QP_PATH_MTU | IBV_QP_DEST_QPN | IBV_QP_RQ_PSN | IBV_QP_MAX_DEST_RD_ATOMIC | IBV_QP_MIN_RNR_TIMER;\n\tint rc = ibv_modify_qp(res->qp, &attr, flags);\n\tif (rc) {\n\t\tfprintf(stderr, \"failed to modify QP to RTR\\n\");\n\t\treturn 1;\n\t}\n\n\treturn 0;\n}\n\nstatic int modify_qp_to_rts(struct resource_t *res, struct config_t* cfg) {\n\tstruct ibv_qp_attr attr = {\n\t\t.qp_state = IBV_QPS_RTS,\n\t\t.timeout = cfg->qp_timeout,\n\t\t.retry_cnt = cfg->qp_retry_cnt,\n\t\t.rnr_retry = cfg->qp_rnr_retry,\n\t\t.sq_psn = 0,\n\t\t.max_rd_atomic = 1\n\t};\n\n\tint flags = IBV_QP_STATE | IBV_QP_TIMEOUT | IBV_QP_RETRY_CNT | IBV_QP_RNR_RETRY | IBV_QP_SQ_PSN | IBV_QP_MAX_QP_RD_ATOMIC;\n\tint rc = ibv_modify_qp(res->qp, &attr, flags);\n\tif (rc) {\n\t\tfprintf(stderr, \"failed to modify QP to RTS\\n\");\n\t\treturn 1;\n\t}\n\n\treturn 0;\n}\n\nstatic int connect_qp(struct resource_t *res, struct config_t *cfg, struct pingpong_dest *dest) {\n\tstruct pingpong_dest my_dest;\n\tmy_dest.lid = res->port_attr.lid;\n\tmy_dest.qpn = res->qp->qp_num;\n\tmy_dest.psn = lrand48() & 0xffffff;\n\tif (cfg->gidx >= 0) {\n\t\tif (ibv_query_gid(res->ib_ctx, cfg->ib_port, cfg->gidx, &my_dest.gid)) {\n\t\t\tfprintf(stderr, \"can't read sgid of index %d\\n\", cfg->gidx);\n\t\t\treturn 1;\n\t\t}\n\t} else {\n\t\tmemset(&my_dest.gid, 0, sizeof my_dest.gid);\n\t}\n\tmy_dest.rkey = res->mr->rkey;\n\tmy_dest.vaddr = (uintptr_t)res->mr->addr;\n\t\n\tif (sock_sync_data(res->sock, sizeof(struct pingpong_dest), (char *)&my_dest, (char *)dest)) {\n\t\tfprintf(stderr, \"failed to exchange connection data between sides\\n\");\n\t\treturn 1;\n\t}\n\n\tif (modify_qp_to_init(res, cfg)) {\n\t\tfprintf(stderr, \"change QP state to INIT failed\\n\");\n\t\treturn 1;\n\t}\n\n\t// Let the client post SR to recv server's msg\n\tif (!is_server) {\n\t\tif (post_recv(res, 0)) {\n\t\t\tfprintf(stderr, \"failed to post RR\\n\");\n\t\t\treturn 1;\n\t\t}\n\t}\n\n\t\n\tif (cfg->gidx >= 0) {\n\t\tuint8_t *p = dest->gid.raw;\n\t\tfprintf(stdout, \"Remote GID = %02x:%02x:%02x:%02x:%02x:%02x:%02x:%02x:%02x:%02x:%02x:%02x:%02x:%02x:%02x:%02x\\n\",\n\t\t\tp[0], p[1], p[2], p[3], p[4], p[5], p[6], p[7], p[8], p[9], p[10], p[11], p[12], p[13], p[14], p[15]);\n\t}\n\n\t/* modify the QP to RTR */\n\tif (modify_qp_to_rtr(res, cfg, dest->qpn, dest->lid, dest->gid.raw)) {\n\t\tfprintf(stderr, \"Failed to modify QP state to RTR\\n\");\n\t\treturn 1;\n\t}\n\tfprintf(stderr, \"Modified QP state to RTR\\n\");\n\t\n\t/* modify the QP to RTS */\n\tif (modify_qp_to_rts(res, cfg)) {\n\t\tfprintf(stderr, \"Failed to modify QP state to RTS\\n\");\n\t\treturn 1;\n\t}\n\tfprintf(stderr, \"QP state was change to RTS\\n\");\n\n\t// Let the server do post SR\n\tif (is_server) {\n\t\tif (post_recv(res, 0)) {\n\t\t\tfprintf(stderr, \"failed to post RR\\n\");\n\t\t\treturn 1;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int connect_qp_notify(struct resource_t *res, struct resource_t *res_notify, struct config_t *cfg, struct pingpong_dest *dest) {\n\tstruct pingpong_dest my_dest;\n\tmy_dest.lid = res->port_attr.lid;\n\tmy_dest.qpn = res->qp->qp_num;\n\tmy_dest.psn = lrand48() & 0xffffff;\n\tif (cfg->gidx >= 0) {\n\t\tif (ibv_query_gid(res->ib_ctx, cfg->ib_port, cfg->gidx, &my_dest.gid)) {\n\t\t\tfprintf(stderr, \"can't read sgid of index %d\\n\", cfg->gidx);\n\t\t\treturn 1;\n\t\t}\n\t} else {\n\t\tmemset(&my_dest.gid, 0, sizeof my_dest.gid);\n\t}\n\tmy_dest.rkey = res_notify->notify_mr->rkey;\n\tmy_dest.vaddr = (uintptr_t)res_notify->notify_mr->addr;\n\t\n\tif (sock_sync_data(res->sock, sizeof(struct pingpong_dest), (char *)&my_dest, (char *)dest)) {\n\t\tfprintf(stderr, \"failed to exchange connection data between sides\\n\");\n\t\treturn 1;\n\t}\n\n\tif (modify_qp_to_init(res, cfg)) {\n\t\tfprintf(stderr, \"change QP state to INIT failed\\n\");\n\t\treturn 1;\n\t}\n\n\t// Let the client post SR to recv server's msg\n\tif (!is_server) {\n\t\tif (post_recv(res, 0)) {\n\t\t\tfprintf(stderr, \"failed to post RR\\n\");\n\t\t\treturn 1;\n\t\t}\n\t}\n\n\t\n\tif (cfg->gidx >= 0) {\n\t\tuint8_t *p = dest->gid.raw;\n\t\tfprintf(stdout, \"Remote GID = %02x:%02x:%02x:%02x:%02x:%02x:%02x:%02x:%02x:%02x:%02x:%02x:%02x:%02x:%02x:%02x\\n\",\n\t\t\tp[0], p[1], p[2], p[3], p[4], p[5], p[6], p[7], p[8], p[9], p[10], p[11], p[12], p[13], p[14], p[15]);\n\t}\n\n\t/* modify the QP to RTR */\n\tif (modify_qp_to_rtr(res, cfg, dest->qpn, dest->lid, dest->gid.raw)) {\n\t\tfprintf(stderr, \"Failed to modify QP state to RTR\\n\");\n\t\treturn 1;\n\t}\n\tfprintf(stderr, \"Modified QP state to RTR\\n\");\n\t\n\t/* modify the QP to RTS */\n\tif (modify_qp_to_rts(res, cfg)) {\n\t\tfprintf(stderr, \"Failed to modify QP state to RTS\\n\");\n\t\treturn 1;\n\t}\n\tfprintf(stderr, \"QP state was change to RTS\\n\");\n\n\t// Let the server do post SR\n\tif (is_server) {\n\t\tif (post_recv(res, 0)) {\n\t\t\tfprintf(stderr, \"failed to post RR\\n\");\n\t\t\treturn 1;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int connect_qp_all(struct resource_t *res, struct resource_t *res_all, struct config_t *cfg, struct pingpong_dest *dest) {\n\tstruct pingpong_dest my_dest;\n\tmy_dest.lid = res->port_attr.lid;\n\tmy_dest.qpn = res->qp->qp_num;\n\tmy_dest.psn = lrand48() & 0xffffff;\n\tif (cfg->gidx >= 0) {\n\t\tif (ibv_query_gid(res->ib_ctx, cfg->ib_port, cfg->gidx, &my_dest.gid)) {\n\t\t\tfprintf(stderr, \"can't read sgid of index %d\\n\", cfg->gidx);\n\t\t\treturn 1;\n\t\t}\n\t} else {\n\t\tmemset(&my_dest.gid, 0, sizeof my_dest.gid);\n\t}\n\tmy_dest.rkey = res_all->all_mr->rkey;\n\tmy_dest.vaddr = (uintptr_t)res_all->all_mr->addr;\n\t\n\tif (sock_sync_data(res->sock, sizeof(struct pingpong_dest), (char *)&my_dest, (char *)dest)) {\n\t\tfprintf(stderr, \"failed to exchange connection data between sides\\n\");\n\t\treturn 1;\n\t}\n\n\tif (modify_qp_to_init(res, cfg)) {\n\t\tfprintf(stderr, \"change QP state to INIT failed\\n\");\n\t\treturn 1;\n\t}\n\n\t// Let the client post SR to recv server's msg\n\tif (!is_server) {\n\t\tif (post_recv(res, 0)) {\n\t\t\tfprintf(stderr, \"failed to post RR\\n\");\n\t\t\treturn 1;\n\t\t}\n\t}\n\n\t\n\tif (cfg->gidx >= 0) {\n\t\tuint8_t *p = dest->gid.raw;\n\t\tfprintf(stdout, \"Remote GID = %02x:%02x:%02x:%02x:%02x:%02x:%02x:%02x:%02x:%02x:%02x:%02x:%02x:%02x:%02x:%02x\\n\",\n\t\t\tp[0], p[1], p[2], p[3], p[4], p[5], p[6], p[7], p[8], p[9], p[10], p[11], p[12], p[13], p[14], p[15]);\n\t}\n\n\t/* modify the QP to RTR */\n\tif (modify_qp_to_rtr(res, cfg, dest->qpn, dest->lid, dest->gid.raw)) {\n\t\tfprintf(stderr, \"Failed to modify QP state to RTR\\n\");\n\t\treturn 1;\n\t}\n\tfprintf(stderr, \"Modified QP state to RTR\\n\");\n\t\n\t/* modify the QP to RTS */\n\tif (modify_qp_to_rts(res, cfg)) {\n\t\tfprintf(stderr, \"Failed to modify QP state to RTS\\n\");\n\t\treturn 1;\n\t}\n\tfprintf(stderr, \"QP state was change to RTS\\n\");\n\n\t// Let the server do post SR\n\tif (is_server) {\n\t\tif (post_recv(res, 0)) {\n\t\t\tfprintf(stderr, \"failed to post RR\\n\");\n\t\t\treturn 1;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int connect_qp_resize(struct resource_t *res, struct resource_t *res_resize, struct config_t *cfg, struct pingpong_dest *dest) {\n\tstruct pingpong_dest my_dest;\n\tmy_dest.lid = res->port_attr.lid;\n\tmy_dest.qpn = res->qp->qp_num;\n\tmy_dest.psn = lrand48() & 0xffffff;\n\tif (cfg->gidx >= 0) {\n\t\tif (ibv_query_gid(res->ib_ctx, cfg->ib_port, cfg->gidx, &my_dest.gid)) {\n\t\t\tfprintf(stderr, \"can't read sgid of index %d\\n\", cfg->gidx);\n\t\t\treturn 1;\n\t\t}\n\t} else {\n\t\tmemset(&my_dest.gid, 0, sizeof my_dest.gid);\n\t}\n\tmy_dest.rkey = res_resize->resize_mr->rkey;\n\tmy_dest.vaddr = (uintptr_t)res_resize->resize_mr->addr;\n\t\n\tif (sock_sync_data(res->sock, sizeof(struct pingpong_dest), (char *)&my_dest, (char *)dest)) {\n\t\tfprintf(stderr, \"failed to exchange connection data between sides\\n\");\n\t\treturn 1;\n\t}\n\n\tif (modify_qp_to_init(res, cfg)) {\n\t\tfprintf(stderr, \"change QP state to INIT failed\\n\");\n\t\treturn 1;\n\t}\n\n\t// Let the client post SR to recv server's msg\n\tif (!is_server) {\n\t\tif (post_recv(res, 0)) {\n\t\t\tfprintf(stderr, \"failed to post RR\\n\");\n\t\t\treturn 1;\n\t\t}\n\t}\n\n\t\n\tif (cfg->gidx >= 0) {\n\t\tuint8_t *p = dest->gid.raw;\n\t\tfprintf(stdout, \"Remote GID = %02x:%02x:%02x:%02x:%02x:%02x:%02x:%02x:%02x:%02x:%02x:%02x:%02x:%02x:%02x:%02x\\n\",\n\t\t\tp[0], p[1], p[2], p[3], p[4], p[5], p[6], p[7], p[8], p[9], p[10], p[11], p[12], p[13], p[14], p[15]);\n\t}\n\n\t/* modify the QP to RTR */\n\tif (modify_qp_to_rtr(res, cfg, dest->qpn, dest->lid, dest->gid.raw)) {\n\t\tfprintf(stderr, \"Failed to modify QP state to RTR\\n\");\n\t\treturn 1;\n\t}\n\tfprintf(stderr, \"Modified QP state to RTR\\n\");\n\t\n\t/* modify the QP to RTS */\n\tif (modify_qp_to_rts(res, cfg)) {\n\t\tfprintf(stderr, \"Failed to modify QP state to RTS\\n\");\n\t\treturn 1;\n\t}\n\tfprintf(stderr, \"QP state was change to RTS\\n\");\n\n\t// Let the server do post SR\n\tif (is_server) {\n\t\tif (post_recv(res, 0)) {\n\t\t\tfprintf(stderr, \"failed to post RR\\n\");\n\t\t\treturn 1;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int post_send(struct resource_t *res, int opcode) {\n\tstruct ibv_send_wr sr;\n\tstruct ibv_sge sge;\n\tstruct ibv_send_wr *bad_wr = NULL;\n\tint rc;\n\n\t// prepare the scatter/gather entry\n\tmemset(&sge, 0, sizeof(sge));\n\tsge.addr = (uintptr_t)res->mr->addr;\n\tsge.length = 0;\n\tsge.lkey = res->mr->lkey;\n\n\t// prepare the SR\n\tmemset(&sr, 0, sizeof(sr));\n\tsr.next = NULL;\n\tsr.wr_id = 0;\n\tsr.sg_list = &sge;\n\tsr.num_sge = 1;\n\tsr.opcode = opcode;\n\tsr.send_flags = IBV_SEND_SIGNALED;\n\n\t// there is a receive request in the responder side, so we won't get any into RNR flow\n\trc = ibv_post_send(res->qp, &sr, &bad_wr);\n\tif (rc) {\n\t\tfprintf(stderr, \"failed to post SR\\n\");\n\t} else {\n\t\tfprintf(stdout, \"Send Request was posted\\n\");\n\t}\n\n\treturn rc;\n}\n\nstatic int post_send_rkey(struct resource_t *res, int opcode) {\n\tstruct ibv_send_wr sr;\n\tstruct ibv_sge sge;\n\tstruct ibv_send_wr *bad_wr = NULL;\n\tint rc;\n\n\t// prepare the scatter/gather entry\n\tmemset(&sge, 0, sizeof(sge));\n\tsge.addr = (uintptr_t)res->mr->addr;\n\tsge.length = 0;\n\tsge.lkey = res->mr->lkey;\n\n\t// prepare the SR\n\tmemset(&sr, 0, sizeof(sr));\n\tsr.next = NULL;\n\tsr.wr_id = 0;\n\tsr.sg_list = &sge;\n\tsr.num_sge = 1;\n\tsr.opcode = opcode;\n\tsr.send_flags = IBV_SEND_SIGNALED;\n\t\n\t// there is a receive request in the responder side, so we won't get any into RNR flow\n\trc = ibv_post_send(res->qp, &sr, &bad_wr);\n\tif (rc) {\n\t\tfprintf(stderr, \"failed to post SR\\n\");\n\t} else {\n\t\tfprintf(stdout, \"Send Request was posted\\n\");\n\t}\n\n\treturn rc;\n}\n\nstatic int post_send_with_imm(struct resource_t *res, int opcode, int data) {\n\tstruct ibv_send_wr sr;\n\tstruct ibv_sge sge;\n\tstruct ibv_send_wr *bad_wr = NULL;\n\tint rc;\n\n\t// prepare the scatter/gather entry\n\tmemset(&sge, 0, sizeof(sge));\n\tsge.addr = (uintptr_t)res->mr->addr;\n\tsge.length = 0;\n\tsge.lkey = res->mr->lkey;\n\n\t// prepare the SR\n\tmemset(&sr, 0, sizeof(sr));\n\tsr.next = NULL;\n\tsr.wr_id = 0;\n\tsr.sg_list = &sge;\n\tsr.num_sge = 1;\n\tsr.opcode = opcode;\n\tsr.send_flags = IBV_SEND_SIGNALED;\n\tsr.imm_data = data;\n\n\t// there is a receive request in the responder side, so we won't get any into RNR flow\n\trc = ibv_post_send(res->qp, &sr, &bad_wr);\n\tif (rc) {\n\t\tfprintf(stderr, \"failed to post SR\\n\");\n\t} else {\n\t\tfprintf(stdout, \"Send Request was posted\\n\");\n\t}\n\n\treturn rc;\n}\n\nstatic int post_send_rdma(struct resource_t *res, int opcode, int data_size, uint64_t remote_addr, uint32_t rkey) {\n\tstruct ibv_send_wr sr;\n\tstruct ibv_sge sge;\n\tstruct ibv_send_wr *bad_wr = NULL;\n\tint rc;\n\n\t// prepare the scatter/gather entry\n\tmemset(&sge, 0, sizeof(sge));\n\tsge.addr = (uintptr_t)res->mr->addr;\n\tsge.length = data_size;\n\tsge.lkey = res->mr->lkey;\n\n\t// prepare the SR\n\tmemset(&sr, 0, sizeof(sr));\n\tsr.next = NULL;\n\tsr.wr_id = 0;\n\tsr.sg_list = &sge;\n\tsr.num_sge = 1;\n\tsr.opcode = opcode;\n\tsr.send_flags = IBV_SEND_SIGNALED;\n\tsr.wr.rdma.remote_addr = remote_addr;\n\tsr.wr.rdma.rkey = rkey;\n\n\t// there is a receive request in the responder side, so we won't get any into RNR flow\n\trc = ibv_post_send(res->qp, &sr, &bad_wr);\n\tif (rc) {\n\t\tfprintf(stderr, \"failed to post SR\\n\");\n\t} else {\n\t\tfprintf(stdout, \"Send Request was posted\\n\");\n\t}\n\n\treturn rc;\n}\n\nstatic int post_send_rdma_write_all(struct resource_t *res, int opcode, int data_size, uint64_t remote_addr, uint32_t rkey) {\n\tstruct ibv_send_wr sr;\n\tstruct ibv_sge sge;\n\tstruct ibv_send_wr *bad_wr = NULL;\n\tint rc;\n\n\t// prepare the scatter/gather entry\n\tmemset(&sge, 0, sizeof(sge));\n\tsge.addr = (uintptr_t)res->all_mr->addr;\n\tsge.length = data_size;\n\tsge.lkey = res->all_mr->lkey;\n\n\t// prepare the SR\n\tmemset(&sr, 0, sizeof(sr));\n\tsr.next = NULL;\n\tsr.wr_id = 0;\n\tsr.sg_list = &sge;\n\tsr.num_sge = 1;\n\tsr.opcode = opcode;\n\tsr.send_flags = IBV_SEND_SIGNALED;\n\tsr.wr.rdma.remote_addr = remote_addr;\n\tsr.wr.rdma.rkey = rkey;\n\n\t// there is a receive request in the responder side, so we won't get any into RNR flow\n\trc = ibv_post_send(res->qp, &sr, &bad_wr);\n\tif (rc) {\n\t\tfprintf(stderr, \"failed to post SR\\n\");\n\t} else {\n\t\tfprintf(stdout, \"Send Request was posted\\n\");\n\t}\n\n\treturn rc;\n}\n\nstatic int post_send_rdma_write_notify(struct resource_t *res, int opcode, int data_size, uint64_t remote_addr, uint32_t rkey) {\n\tstruct ibv_send_wr sr;\n\tstruct ibv_sge sge;\n\tstruct ibv_send_wr *bad_wr = NULL;\n\tint rc;\n\n\t// prepare the scatter/gather entry\n\tmemset(&sge, 0, sizeof(sge));\n\tsge.addr = (uintptr_t)res->notify_mr->addr;\n\tsge.length = data_size;\n\tsge.lkey = res->notify_mr->lkey;\n\n\t// prepare the SR\n\tmemset(&sr, 0, sizeof(sr));\n\tsr.next = NULL;\n\tsr.wr_id = 0;\n\tsr.sg_list = &sge;\n\tsr.num_sge = 1;\n\tsr.opcode = opcode;\n\tsr.send_flags = IBV_SEND_SIGNALED;\n\tsr.wr.rdma.remote_addr = remote_addr;\n\tsr.wr.rdma.rkey = rkey;\n\n\t// there is a receive request in the responder side, so we won't get any into RNR flow\n\trc = ibv_post_send(res->qp, &sr, &bad_wr);\n\tif (rc) {\n\t\tfprintf(stderr, \"failed to post SR\\n\");\n\t} else {\n\t\tfprintf(stdout, \"Send Request was posted\\n\");\n\t}\n\n\treturn rc;\n}\n\nstatic int post_send_rdma_read_all(struct resource_t *res, int opcode, int data_size, uint64_t remote_addr, uint32_t rkey) {\n\tstruct ibv_send_wr sr;\n\tstruct ibv_sge sge;\n\tstruct ibv_send_wr *bad_wr = NULL;\n\tint rc;\n\n\t// prepare the scatter/gather entry\n\tmemset(&sge, 0, sizeof(sge));\n\tsge.addr = (uintptr_t)res->all_mr->addr;\n\tsge.length = data_size;\n\tsge.lkey = res->all_mr->lkey;\n\n\t// prepare the SR\n\tmemset(&sr, 0, sizeof(sr));\n\tsr.next = NULL;\n\tsr.wr_id = 0;\n\tsr.sg_list = &sge;\n\tsr.num_sge = 1;\n\tsr.opcode = opcode;\n\tsr.send_flags = IBV_SEND_SIGNALED;\n\tsr.wr.rdma.remote_addr = remote_addr;\n\tsr.wr.rdma.rkey = rkey;\n\n\t// there is a receive request in the responder side, so we won't get any into RNR flow\n\trc = ibv_post_send(res->qp, &sr, &bad_wr);\n\tif (rc) {\n\t\tfprintf(stderr, \"failed to post SR\\n\");\n\t} else {\n\t\tfprintf(stdout, \"Send Request was posted\\n\");\n\t}\n\n\treturn rc;\n}\n\nstatic int post_send_with_flags(struct resource_t *res, int opcode, int data_size, int flags, int qp_idx) {\n\tstruct ibv_send_wr sr;\n\tstruct ibv_sge sge;\n\tstruct ibv_send_wr *bad_wr = NULL;\n\tint rc;\n\n\t// prepare the scatter/gather entry\n\tmemset(&sge, 0, sizeof(sge));\n\tsge.addr = (uintptr_t)res->mr->addr;\n\tsge.length = data_size;\n\tsge.lkey = res->mr->lkey;\n\n\t// prepare the SR\n\tmemset(&sr, 0, sizeof(sr));\n\tsr.next = NULL;\n\tsr.wr_id = 0;\n\tsr.sg_list = &sge;\n\tsr.num_sge = 1;\n\tsr.opcode = opcode;\n\tsr.send_flags = flags;\n\tsr.imm_data = qp_idx;\n\n\t// there is a receive request in the responder side, so we won't get any into RNR flow\n\trc = ibv_post_send(res->qp, &sr, &bad_wr);\n\tif (rc) {\n\t\tfprintf(stderr, \"failed to post SR\\n\");\n\t} else {\n\t\tfprintf(stdout, \"Send Request was posted\\n\");\n\t}\n\n\treturn rc;\n}\n\nstatic int post_recv(struct resource_t *res, int n) {\n\tstruct ibv_recv_wr rr;\n\tstruct ibv_sge sge;\n\tstruct ibv_recv_wr *bad_wr;\n\tint rc;\n\tint i;\n\n\t// prepare the scatter/gather entry\n\tmemset(&sge, 0, sizeof(sge));\n\tsge.addr = (uintptr_t)res->mr->addr;\n\tsge.length = res->size;\n\tsge.lkey = res->mr->lkey;\n\n\tfor (i = 0; i < n; i++) {\n\t\t// prepare the receive work request\n\t\tmemset(&rr, 0, sizeof(rr));\n\t\trr.next = NULL;\n\t\trr.wr_id = i;\n\t\trr.sg_list = &sge;\n\t\trr.num_sge = 1;\n\n\t\t// post the receive work request\n\t\trc = ibv_post_recv(res->qp, &rr, &bad_wr);\n\t\tif (rc) {\n\t\t\tfprintf(stderr, \"failed to post RR\\n\");\n\t\t\treturn rc;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int post_recv_notify(struct resource_t *res, int n) {\n\tstruct ibv_recv_wr rr;\n\tstruct ibv_sge sge;\n\tstruct ibv_recv_wr *bad_wr;\n\tint rc;\n\tint i;\n\n\t// prepare the scatter/gather entry\n\tmemset(&sge, 0, sizeof(sge));\n\tsge.addr = (uintptr_t)res->notify_mr->addr;\n\tsge.length = res->mr_notify_size;\n\tsge.lkey = res->notify_mr->lkey;\n\n\tfor (i = 0; i < n; i++) {\n\t\t// prepare the receive work request\n\t\tmemset(&rr, 0, sizeof(rr));\n\t\trr.next = NULL;\n\t\trr.wr_id = i;\n\t\trr.sg_list = &sge;\n\t\trr.num_sge = 1;\n\n\t\t// post the receive work request\n\t\trc = ibv_post_recv(res->qp, &rr, &bad_wr);\n\t\tif (rc) {\n\t\t\tfprintf(stderr, \"failed to post RR\\n\");\n\t\t\treturn rc;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int post_recv_all(struct resource_t *res, int n) {\n\tstruct ibv_recv_wr rr;\n\tstruct ibv_sge sge;\n\tstruct ibv_recv_wr *bad_wr;\n\tint rc;\n\tint i;\n\n\t// prepare the scatter/gather entry\n\tmemset(&sge, 0, sizeof(sge));\n\tsge.addr = (uintptr_t)res->all_mr->addr;\n\tsge.length = res->mr_all_size;\n\tsge.lkey = res->all_mr->lkey;\n\n\tfor (i = 0; i < n; i++) {\n\t\t// prepare the receive work request\n\t\tmemset(&rr, 0, sizeof(rr));\n\t\trr.next = NULL;\n\t\trr.wr_id = i;\n\t\trr.sg_list = &sge;\n\t\trr.num_sge = 1;\n\n\t\t// post the receive work request\n\t\trc = ibv_post_recv(res->qp, &rr, &bad_wr);\n\t\tif (rc) {\n\t\t\tfprintf(stderr, \"failed to post RR\\n\");\n\t\t\treturn rc;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int poll_completion(struct resource_t *res) {\n\tstruct ibv_wc wc;\n\tunsigned long start_time_msec;\n\tunsigned long cur_time_msec;\n\tstruct timeval cur_time;\n\tint rc;\n\tint poll_result;\n\tint poll_cnt = 0;\n\n\t// poll the completion for a while before giving up\n\tgettimeofday(&cur_time, NULL);\n\tstart_time_msec = (cur_time.tv_sec * 1000) + (cur_time.tv_usec / 1000);\n\t\n\tdo {\n\t\tpoll_result = ibv_poll_cq(res->cq, 1, &wc);\n\t\tgettimeofday(&cur_time, NULL);\n\t\tcur_time_msec = (cur_time.tv_sec * 1000) + (cur_time.tv_usec / 1000);\n\t\tpoll_cnt++;\n\t} while ((poll_result == 0) && ((cur_time_msec - start_time_msec) < 100));\n\n\tif (poll_result < 0) {\n\t\t// poll CQ failed\n\t\tfprintf(stderr, \"poll CQ failed\\n\");\n\t\trc = 1;\n\t} else if (poll_result == 0) {\n\t\t// CQ is empty\n\t\tfprintf(stderr, \"completion wasn't found in the CQ after timeout\\n\");\n\t\trc = 1;\n\t} else {\n\t\t// CQE found\n\t\tfprintf(stdout, \"completion was found in CQ with status 0x%x\\n\", wc.status);\n\t\t\n\t\t// verify the completion status (here we don't care about the completion opcode)\n\t\tif (wc.status != IBV_WC_SUCCESS) {\n\t\t\tfprintf(stderr, \"got bad completion with status: 0x%x, vendor syndrome: 0x%x, with error: %s\\n\",\n\t\t\t\twc.status, wc.vendor_err, ibv_wc_status_str(wc.status));\n\t\t\trc = 1;\n\t\t} else {\n\t\t\trc = 0;\n\t\t}\n\t}\n\n\treturn rc;\n}\n\nstatic int cleanup_resources(struct resource_t *res) {\n\tint rc = 0;\n\t\n\tif (res->qp) {\n\t\tif (ibv_destroy_qp(res->qp)) {\n\t\t\tfprintf(stderr, \"failed to destroy QP\\n\");\n\t\t\trc = 1;\n\t\t}\n\t}\n\t\n\tif (res->mr) {\n\t\tfree(res->mr->addr);\n\t\tif (ibv_dereg_mr(res->mr)) {\n\t\t\tfprintf(stderr, \"failed to deregister MR\\n\");\n\t\t\trc = 1;\n\t\t}\n\t}\n\t\n\tif (res->cq) {\n\t\tif (ibv_destroy_cq(res->cq)) {\n\t\t\tfprintf(stderr, \"failed to destroy CQ\\n\");\n\t\t\trc = 1;\n\t\t}\n\t}\n\t\n\tif (res->pd) {\n\t\tif (ibv_dealloc_pd(res->pd)) {\n\t\t\tfprintf(stderr, \"failed to deallocate PD\\n\");\n\t\t\trc = 1;\n\t\t}\n\t}\n\t\n\tif (res->ib_ctx) {\n\t\tif (ibv_close_device(res->ib_ctx)) {\n\t\t\tfprintf(stderr, \"failed to close device context\\n\");\n\t\t\trc = 1;\n\t\t}\n\t}\n\t\n\tif (res->sock >= 0) {\n\t\tif (close(res->sock)) {\n\t\t\tfprintf(stderr, \"failed to close socket\\n\");\n\t\t\trc = 1;\n\t\t}\n\t}\n\t\n\treturn rc;\n}\n\nvoid print_config(struct config_t *config) {\n\tfprintf(stdout, \" ------------------------------------------------\\n\");\n\tfprintf(stdout, \" Device name                  : \\\"%s\\\"\\n\", config->dev_name);\n\tfprintf(stdout, \" IB port                      : %u\\n\", config->ib_port);\n\tif (config->server_name)\n\t\tfprintf(stdout, \" IP                           : %s\\n\", config->server_name);\n\tfprintf(stdout, \" TCP port                     : %u\\n\", config->tcp_port);\n\tif (config->gidx >= 0)\n\t\tfprintf(stdout, \" GID index                    : %u\\n\", config->gidx);\n\tfprintf(stdout, \" ------------------------------------------------\\n\\n\");\n}\n\n\nvoid rdma_server() {\n\tint rc = 0;\n\tint lsock = -1;\n\tstruct resource_t res;\n\tstruct config_t config = {\n\t\tNULL,\t\t\t\t\t// dev_name\n\t\t{'\\0'},\t\t\t\t\t// server_name\n\t\t19875,\t\t\t\t\t// tcp_port\n\t\t1,\t\t\t\t\t\t// ib_port\n\t\tDEFAULT_NUMA_NODE,      // numa_node\n\t\t14,\t\t\t\t\t\t// qp_timeout\n\t\t7,\t\t\t\t\t\t// qp_retry_cnt\n\t\t7,\t\t\t\t\t\t// qp_rnr_retry\n\t\tset_mtu,                // mtu\n\t\t0,\t\t\t\t\t\t// sl\n\t\t-1,\t\t\t\t\t\t// gidx\n\t\t0,                      // sgid_idx\n\t\t0,                     // qp_num\n\t};\n\t\n\t// Parse command line arguments\n\tfprintf(stdout, \"Starting RDMA server\\n\");\n\tprint_config(&config);\n\t\n\t// Init IB resources\n\tfprintf(stdout, \"Initializing IB resources\\n\");\n\tmemset(&res, 0, sizeof(res));\n\trc = init_env(&res);\n\tif (rc) {\n\t\tfprintf(stderr, \"Failed to initialize IB resources\\n\");\n\t\tgoto main_exit;\n\t}\n\t\n\t// Create resources\n\trc = init_resource(&res, &config);\n\tif (rc) {\n\t\tfprintf(stderr, \"Failed to initialize IB resources\\n\");\n\t\tgoto main_exit;\n\t}\n\t\n\t// Create QP\n\trc = create_qp(&res, &config);\n\tif (rc) {\n\t\tfprintf(stderr, \"Failed to create QP\\n\");\n\t\tgoto main_exit;\n\t}\n\n\t// Memory Region\n\tres.size = 4096;\n\tint mr_flags = IBV_ACCESS_LOCAL_WRITE | IBV_ACCESS_REMOTE_READ | IBV_ACCESS_REMOTE_WRITE;\n\tres.mr = create_one_mr(res.pd, NULL, 0, mr_flags, res.size, 0, 0);\n\tif (!res.mr) {\n\t\tfprintf(stderr, \"Failed to create MR\\n\");\n\t\tgoto main_exit;\n\t}\n\t\n\t// Create and accept socket connection from client\n\tfprintf(stdout, \"Waiting for client connection on port %d\\n\", config.tcp_port);\n\tlsock = sock_bind(config.tcp_port);\n\tif (lsock < 0) {\n\t\tfprintf(stderr, \"Failed to bind to port %d\\n\", config.tcp_port);\n\t\tgoto main_exit;\n\t}\n\t\n\tfprintf(stdout, \"Waiting for client connection\\n\");\n\tres.sock = sock_accept(lsock);\n\tif (res.sock < 0) {\n\t\tfprintf(stderr, \"Failed to accept client connection\\n\");\n\t\tgoto main_exit;\n\t}\n\tfprintf(stdout, \"Client connected\\n\");\n\t\n\t// Create QP and connect with client\n\tstruct pingpong_dest my_dest, rem_dest;\n\trc = connect_qp(&res, &config, &rem_dest);\n\tif (rc) {\n\t\tfprintf(stderr, \"Failed to connect QPs\\n\");\n\t\tgoto main_exit;\n\t}\n\tfprintf(stdout, \"QPs connected!\\n\");\n\n\t// Write data to client\n\tchar *read_msg = (char *)res.mr->addr;\n\tfprintf(stdout, \"Ready to server client\\n\");\n\tmemset(read_msg, 0, res.size);\n\tstrcpy(read_msg, \"Greetings from server\\n\");\n\tif (post_send(&res, IBV_WR_SEND)) {\n\t\tfprintf(stderr, \"Failed to post SR\\n\");\n\t\tgoto main_exit;\n\t}\n\t\n\tif (poll_completion(&res)) {\n\t\tfprintf(stderr, \"Failed to poll completion for SR\\n\");\n\t\tgoto main_exit;\n\t}\n\t\n\t// Read data from client\n\tif (poll_completion(&res)) {\n\t\tfprintf(stderr, \"Failed to poll completion for RR\\n\");\n\t\tgoto main_exit;\n\t}\n\tfprintf(stdout, \"Message from client: '%s'\\n\", read_msg);\n\nmain_exit:\n\tif (lsock >= 0) {\n\t\tclose(lsock);\n\t}\n\t\n\tif (cleanup_resources(&res)) {\n\t\tfprintf(stderr, \"Failed to clean up resources\\n\");\n\t\trc = 1;\n\t}\n\t\n\tfprintf(stdout, \"Return to main thread\\n\");\n}\n\nvoid rdma_client() {\n\tint rc = 0;\n\tstruct resource_t res;\n\tstruct config_t config = {\n\t\tNULL,\t\t\t\t\t// dev_name\n\t\t\"172.22.10.111\",\t\t// server_name\n\t\t19875,\t\t\t\t\t// tcp_port\n\t\t1,\t\t\t\t\t\t// ib_port\n\t\tDEFAULT_NUMA_NODE,      // numa_node\n\t\t14,\t\t\t\t\t\t// qp_timeout\n\t\t7,\t\t\t\t\t\t// qp_retry_cnt\n\t\t7,\t\t\t\t\t\t// qp_rnr_retry\n\t\tset_mtu,                // mtu\n\t\t0,\t\t\t\t\t\t// sl\n\t\t-1,\t\t\t\t\t\t// gidx\n\t\t0,                      // sgid_idx\n\t\t0,                      // qp_num\n\t};\n\t\n\t// Parse command line arguments\n\tfprintf(stdout, \"Starting RDMA client\\n\");\n\tprint_config(&config);\n\t\n\t// Init IB resources\n\tfprintf(stdout, \"Initializing IB resources\\n\");\n\tmemset(&res, 0, sizeof(res));\n\trc = init_env(&res);\n\tif (rc) {\n\t\tfprintf(stderr, \"Failed to initialize IB resources\\n\");\n\t\tgoto main_exit;\n\t}\n\t\n\t// Create resources\n\trc = init_resource(&res, &config);\n\tif (rc) {\n\t\tfprintf(stderr, \"Failed to initialize IB resources\\n\");\n\t\tgoto main_exit;\n\t}\n\t\n\t// Create QP\n\trc = create_qp(&res, &config);\n\tif (rc) {\n\t\tfprintf(stderr, \"Failed to create QP\\n\");\n\t\tgoto main_exit;\n\t}\n\n\t// Memory Region\n\tres.size = 4096;\n\tint mr_flags = IBV_ACCESS_LOCAL_WRITE | IBV_ACCESS_REMOTE_READ | IBV_ACCESS_REMOTE_WRITE;\n\tres.mr = create_one_mr(res.pd, NULL, 0, mr_flags, res.size, 0, 0);\n\tif (!res.mr) {\n\t\tfprintf(stderr, \"Failed to create MR\\n\");\n\t\tgoto main_exit;\n\t}\n\t\n\t// Connect to server via socket\n\tfprintf(stdout, \"Connecting to server at %s:%d\\n\", config.server_name, config.tcp_port);\n\tres.sock = sock_connect(config.server_name, config.tcp_port);\n\tif (res.sock < 0) {\n\t\tfprintf(stderr, \"Failed to connect to server %s:%d\\n\", config.server_name, config.tcp_port);\n\t\tgoto main_exit;\n\t}\n\tfprintf(stdout, \"Connected to server\\n\");\n\t\n\t// Create QP and connect with server\n\tstruct pingpong_dest my_dest, rem_dest;\n\trc = connect_qp(&res, &config, &rem_dest);\n\tif (rc) {\n\t\tfprintf(stderr, \"Failed to connect QPs\\n\");\n\t\tgoto main_exit;\n\t}\n\tfprintf(stdout, \"QPs connected!\\n\");\n\n\t// Read data from server\n\tchar *read_msg = (char *)res.mr->addr;\n\tfprintf(stdout, \"Ready to get data from server\\n\");\n\t\n\tif (poll_completion(&res)) {\n\t\tfprintf(stderr, \"Failed to poll completion for RR\\n\");\n\t\tgoto main_exit;\n\t}\n\tfprintf(stdout, \"Message from server: '%s'\\n\", read_msg);\n\t\n\t// Write data to server\n\tmemset(read_msg, 0, res.size);\n\tstrcpy(read_msg, \"Message from client\\n\");\n\tif (post_send(&res, IBV_WR_SEND)) {\n\t\tfprintf(stderr, \"Failed to post SR\\n\");\n\t\tgoto main_exit;\n\t}\n\t\n\tif (poll_completion(&res)) {\n\t\tfprintf(stderr, \"Failed to poll completion for SR\\n\");\n\t\tgoto main_exit;\n\t}\n\nmain_exit:\n\tif (cleanup_resources(&res)) {\n\t\tfprintf(stderr, \"Failed to clean up resources\\n\");\n\t\trc = 1;\n\t}\n\t\n\tfprintf(stdout, \"Return to main thread\\n\");\n}\n\nvoid send_rdma(struct resource_t *res, void *addr, size_t size) {\n}\n\nvoid send_barrier(struct resource_t *res, int qp_id) {\n}\n\n// Threads for handling QP\nstruct resource_t res_all[MAX_QUEUEPAIR_NUM];\nvoid *qp_thread_func(void *arg) {\n\tint qp_id = *(int *)arg;\n\tprintf(\"QP thread %d started\\n\", qp_id);\n\tsetCPU(qp_id * 2);\n\t\n\tstruct resource_t res;\n\tstruct resource_t* res_p;\n\tstruct config_t config = {\n\t\tNULL,\t\t\t\t\t// dev_name\n\t\t{'\\0'},\t\t\t\t\t// server_name\n\t\t19875,\t\t\t\t\t// tcp_port\n\t\t1,\t\t\t\t\t\t// ib_port\n\t\tDEFAULT_NUMA_NODE,      // numa_node\n\t\t14,\t\t\t\t\t\t// qp_timeout\n\t\t7,\t\t\t\t\t\t// qp_retry_cnt\n\t\t7,\t\t\t\t\t\t// qp_rnr_retry\n\t\tset_mtu,                // mtu\n\t\t0,\t\t\t\t\t\t// sl\n\t\t-1,\t\t\t\t\t\t// gidx\n\t\t0,                      // sgid_idx\n\t\tqp_id,                  // qp_num\n\t};\n\n\t// Check if is server\n\tif (is_server) {\n\t\tconfig.tcp_port += qp_id;\n\t} else {\n\t\tconfig.tcp_port += qp_id;\n\t\t// use config server name\n\t\tstrcpy(config.server_name, \"172.22.10.111\");\n\t}\n\t\n\tint rc = 0;\n\tint lsock = -1;\n\tmemset(&res, 0, sizeof(res));\n\tres_p = &res;\n\t\n\t// Init IB resources\n\tfprintf(stdout, \"Initializing IB resources, QP %d\\n\", qp_id);\n\trc = init_env(res_p);\n\tif (rc) {\n\t\tfprintf(stderr, \"QP %d: Failed to initialize IB resources\\n\", qp_id);\n\t\treturn NULL;\n\t}\n\t\n\t// Create resources\n\trc = init_resource(res_p, &config);\n\tif (rc) {\n\t\tfprintf(stderr, \"QP %d: Failed to initialize IB resources\\n\", qp_id);\n\t\treturn NULL;\n\t}\n\t\n\t// Create QP\n\trc = create_qp(res_p, &config);\n\tif (rc) {\n\t\tfprintf(stderr, \"QP %d: Failed to create QP\\n\", qp_id);\n\t\treturn NULL;\n\t}\n\n\t// Memory Region\n\tres_p->size = 4096;\n\tint mr_flags = IBV_ACCESS_LOCAL_WRITE | IBV_ACCESS_REMOTE_READ | IBV_ACCESS_REMOTE_WRITE;\n\tres_p->mr = create_one_mr(res_p->pd, NULL, 0, mr_flags, res_p->size, 0, 0);\n\tif (!res_p->mr) {\n\t\tfprintf(stderr, \"QP %d: Failed to create MR\\n\", qp_id);\n\t\treturn NULL;\n\t}\n\n\t// Allocate MR\n\tcreate_mr_all_for_alloc(res_p, &config, 1 * 1024 * 1024);\n\t\n\tcreate_mr_notify_for_alloc(res_p, &config, 1 * 1024 * 1024);\n\t\n\t// Memory for MPI\n\tif (qp_id == 0 && is_server) {\n\t\tmpi_init_msg = res_p->all_mr;\n\t}\n\t\n\t\n\t// Connect\n\tif (is_server) {\n\t\t// Create and accept socket connection from client\n\t\tfprintf(stdout, \"QP %d: Waiting for client connection on port %d\\n\", qp_id, config.tcp_port);\n\t\tlsock = sock_bind(config.tcp_port);\n\t\tif (lsock < 0) {\n\t\t\tfprintf(stderr, \"QP %d: Failed to bind to port %d\\n\", qp_id, config.tcp_port);\n\t\t\treturn NULL;\n\t\t}\n\t\t\n\t\tfprintf(stdout, \"QP %d: Waiting for client connection\\n\", qp_id);\n\t\tres_p->sock = sock_accept(lsock);\n\t\tif (res_p->sock < 0) {\n\t\t\tfprintf(stderr, \"QP %d: Failed to accept client connection\\n\", qp_id);\n\t\t\treturn NULL;\n\t\t}\n\t\tfprintf(stdout, \"QP %d: Client connected\\n\", qp_id);\n\t} else {\n\t\t// Connect to server via socket\n\t\tfprintf(stdout, \"QP %d: Connecting to server at %s:%d\\n\", qp_id, config.server_name, config.tcp_port);\n\t\tres_p->sock = sock_connect(config.server_name, config.tcp_port);\n\t\tif (res_p->sock < 0) {\n\t\t\tfprintf(stderr, \"QP %d: Failed to connect to server %s:%d\\n\", qp_id, config.server_name, config.tcp_port);\n\t\t\treturn NULL;\n\t\t}\n\t\tfprintf(stdout, \"QP %d: Connected to server\\n\", qp_id);\n\t}\n\t\n\t// Create QP and connect with server\n\t// Connect QP\n\tstruct pingpong_dest my_dest, rem_dest_1, rem_dest_2, rem_dest_3;\n\n\trc = connect_qp(res_p, &config, &rem_dest_1);\n\tif (rc) {\n\t\tfprintf(stderr, \"QP %d: Failed to connect QPs\\n\", qp_id);\n\t\treturn NULL;\n\t}\n\n\trc = connect_qp_notify(res_p, res_p, &config, &rem_dest_2);\n\tif (rc) {\n\t\tfprintf(stderr, \"QP %d: Failed to connect QPs\\n\", qp_id);\n\t\treturn NULL;\n\t}\n\n\trc = connect_qp_all(res_p, res_p, &config, &rem_dest_3);\n\tif (rc) {\n\t\tfprintf(stderr, \"QP %d: Failed to connect QPs\\n\", qp_id);\n\t\treturn NULL;\n\t}\n\n\t\n\tfprintf(stdout, \"QP %d: QPs connected!\\n\", qp_id);\n\n\n\tres_all[qp_id] = res;\n\t\n\tif (is_server) {\n\t\tprintf(\"Server QP %d Barrier wait start\\n\", qp_id);\n\t\t// Wait for MPI Init\n\t\twhile (1) {\n\t\t\t// server always wait for client\n\t\t\tuint64_t *barrier_ptr = (uint64_t *)res_p->notify_mr->addr;\n\t\t\tif (*barrier_ptr == BARRIER_MASK) {\n\t\t\t\tprintf(\"Server QP %d Barrier done, %lx\\n\", qp_id, *barrier_ptr);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tprintf(\"Server QP %d: Wait for client message\\n\", qp_id);\n\t\t\n\t\t// Do RDMA to client\n\t\tusleep(500 * 1000);\n\t\tprintf(\"Server QP %d: Write message to client\\n\", qp_id);\n\t\t\n\t\tuint64_t *msg_ptr = (uint64_t *)res_p->all_mr->addr;\n\t\t*msg_ptr = NORMAL_MASK;\n\t\tpost_send_rdma_write_all(res_p, IBV_WR_RDMA_WRITE, sizeof(uint64_t), (uint64_t)rem_dest_3.vaddr, rem_dest_3.rkey);\n\t\tif (poll_completion(res_p)) {\n\t\t\tfprintf(stderr, \"QP %d: Failed to poll completion for SR\\n\", qp_id);\n\t\t\treturn NULL;\n\t\t}\n\t\t\n\t\t// Read data from client\n\t\tprintf(\"Server QP %d: Read message from client\\n\", qp_id);\n\t\tpost_send_rdma_read_all(res_p, IBV_WR_RDMA_READ, sizeof(uint64_t), (uint64_t)rem_dest_3.vaddr, rem_dest_3.rkey);\n\t\tif (poll_completion(res_p)) {\n\t\t\tfprintf(stderr, \"QP %d: Failed to poll completion for SR\\n\", qp_id);\n\t\t\treturn NULL;\n\t\t}\n\t\tprintf(\"Server QP %d: Message from client: 0x%lx\\n\", qp_id, *msg_ptr);\n\t} else {\n\t\tprintf(\"Client QP %d: Wait for server message\\n\", qp_id);\n\t\t\n\t\t// barrier to notify server\n\t\tuint64_t *barrier_ptr = (uint64_t *)res_p->notify_mr->addr;\n\t\t*barrier_ptr = BARRIER_MASK;\n\t\tpost_send_rdma_write_notify(res_p, IBV_WR_RDMA_WRITE, sizeof(uint64_t), (uint64_t)rem_dest_2.vaddr, rem_dest_2.rkey);\n\t\tif (poll_completion(res_p)) {\n\t\t\tfprintf(stderr, \"QP %d: Failed to poll completion for SR\\n\", qp_id);\n\t\t\treturn NULL;\n\t\t}\n\t\tprintf(\"Client QP %d: Barrier done\\n\", qp_id);\n\t\t\n\t\t// Read from server\n\t\tuint64_t *msg_ptr = (uint64_t *)res_p->all_mr->addr;\n\t\twhile (1) {\n\t\t\tif (*msg_ptr == NORMAL_MASK) {\n\t\t\t\tprintf(\"Client QP %d: Message from server: 0x%lx\\n\", qp_id, *msg_ptr);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t\n\t\t// Write back to server\n\t\tprintf(\"Client QP %d: Write message to server\\n\", qp_id);\n\t\t*msg_ptr = NORMAL_MASK + 1;\n\t\tpost_send_rdma_write_all(res_p, IBV_WR_RDMA_WRITE, sizeof(uint64_t), (uint64_t)rem_dest_3.vaddr, rem_dest_3.rkey);\n\t\tif (poll_completion(res_p)) {\n\t\t\tfprintf(stderr, \"QP %d: Failed to poll completion for SR\\n\", qp_id);\n\t\t\treturn NULL;\n\t\t}\n\t}\n\n\tprintf(\"QP %d: Test done\\n\", qp_id);\n\t\n\t// Clean up\n\tif (is_server) {\n\t\tif (lsock >= 0) {\n\t\t\tclose(lsock);\n\t\t}\n\t}\n\t\n\tif (cleanup_resources(res_p)) {\n\t\tfprintf(stderr, \"QP %d: Failed to clean up resources\\n\", qp_id);\n\t\treturn NULL;\n\t}\n\t\n\treturn NULL;\n}\n\nvoid set_func_pointers() {\n\tqp_ctx[0].mr_create = create_mr;\n\tqp_ctx[0].mr_create_notify = create_mr_notify;\n\tqp_ctx[0].mr_create_all = create_mr_all;\n\tqp_ctx[0].mr_notify = notify_mr;\n\tqp_ctx[0].mr_resize = resize_mr;\n\t\n\tqp_ctx[1].mr_create = create_mr;\n\tqp_ctx[1].mr_create_notify = create_mr_notify;\n\tqp_ctx[1].mr_create_all = create_mr_all;\n\tqp_ctx[1].mr_notify = notify_mr;\n\tqp_ctx[1].mr_resize = resize_mr;\n\n\tqp_ctx[2].mr_create = create_mr;\n\tqp_ctx[2].mr_create_notify = create_mr_notify;\n\tqp_ctx[2].mr_create_all = create_mr_all;\n\tqp_ctx[2].mr_notify = notify_mr;\n\tqp_ctx[2].mr_resize = resize_mr;\n\n\tqp_ctx[3].mr_create = create_mr;\n\tqp_ctx[3].mr_create_notify = create_mr_notify;\n\tqp_ctx[3].mr_create_all = create_mr_all;\n\tqp_ctx[3].mr_notify = notify_mr;\n\tqp_ctx[3].mr_resize = resize_mr;\n}\n\nint main(int argc, char **argv) {\n\t// Check if client or server\n\tif (argc > 1) {\n\t\tif (strcmp(argv[1], \"server\") == 0) {\n\t\t\tis_server = 1;\n\t\t} else if (strcmp(argv[1], \"client\") == 0) {\n\t\t\tis_server = 0;\n\t\t} else {\n\t\t\tprintf(\"Usage: %s [server|client]\\n\", argv[0]);\n\t\t\treturn 1;\n\t\t}\n\t} else {\n\t\tprintf(\"Usage: %s [server|client]\\n\", argv[0]);\n\t\treturn 1;\n\t}\n\n\tset_func_pointers();\n\t\n\t// Start QP threads\n\tfor (int i = 0; i < 4; i++) {\n\t\tqp_ctx[i].qp_id = i;\n\t\tint rc = pthread_create(&qp_ctx[i].qp_thread, NULL, qp_thread_func, &qp_ctx[i].qp_id);\n\t\tif (rc) {\n\t\t\tprintf(\"Error creating QP thread %d\\n\", i);\n\t\t\treturn 1;\n\t\t}\n\t}\n\t\n\t// Wait for QP threads\n\tfor (int i = 0; i < 4; i++) {\n\t\tpthread_join(qp_ctx[i].qp_thread, NULL);\n\t}\n\t\n\treturn 0;\n}\n\nint shared_int_create(shared_int *obj) {\n\tpthread_mutex_init(&obj->mutex, NULL);\n\tpthread_cond_init(&obj->cond, NULL);\n\tobj->val = 0;\n\treturn 0;\n}\n\nint shared_int_destroy(shared_int *obj) {\n\tpthread_mutex_destroy(&obj->mutex);\n\tpthread_cond_destroy(&obj->cond);\n\treturn 0;\n}\n\nint shared_int_reset(shared_int *obj) {\n\tpthread_mutex_lock(&obj->mutex);\n\tobj->val = 0;\n\tpthread_mutex_unlock(&obj->mutex);\n\treturn 0;\n}\n\nint shared_int_set(shared_int *obj, int val) {\n\tpthread_mutex_lock(&obj->mutex);\n\tobj->val = val;\n\tpthread_cond_broadcast(&obj->cond);\n\tpthread_mutex_unlock(&obj->mutex);\n\treturn 0;\n}\n\nint shared_int_get(shared_int *obj) {\n\tint val;\n\tpthread_mutex_lock(&obj->mutex);\n\tval = obj->val;\n\tpthread_mutex_unlock(&obj->mutex);\n\treturn val;\n}\n\nint shared_int_add(shared_int *obj, int delta) {\n\tpthread_mutex_lock(&obj->mutex);\n\tobj->val += delta;\n\tpthread_cond_broadcast(&obj->cond);\n\tpthread_mutex_unlock(&obj->mutex);\n\treturn 0;\n}\n\nint shared_int_get_and_add(shared_int *obj, int delta) {\n\tint val;\n\tpthread_mutex_lock(&obj->mutex);\n\tval = obj->val;\n\tobj->val += delta;\n\tpthread_cond_broadcast(&obj->cond);\n\tpthread_mutex_unlock(&obj->mutex);\n\treturn val;\n}\n\nint shared_int_barrier(shared_int *obj, int val) {\n\tpthread_mutex_lock(&obj->mutex);\n\tobj->val++;\n\tif (obj->val >= val) {\n\t\tpthread_cond_broadcast(&obj->cond);\n\t} else {\n\t\twhile (obj->val < val) {\n\t\t\tpthread_cond_wait(&obj->cond, &obj->mutex);\n\t\t}\n\t}\n\tpthread_mutex_unlock(&obj->mutex);\n\treturn 0;\n}\n\nint shared_int_wait_neq(shared_int *obj, int val) {\n\tpthread_mutex_lock(&obj->mutex);\n\twhile (obj->val == val) {\n\t\tpthread_cond_wait(&obj->cond, &obj->mutex);\n\t}\n\tpthread_mutex_unlock(&obj->mutex);\n\treturn 0;\n}\n\nint shared_int_wait_eq(shared_int *obj, int val) {\n\tpthread_mutex_lock(&obj->mutex);\n\twhile (obj->val != val) {\n\t\tpthread_cond_wait(&obj->cond, &obj->mutex);\n\t}\n\tpthread_mutex_unlock(&obj->mutex);\n\treturn 0;\n}\n\nint shared_int_wait_geq(shared_int *obj, int val) {\n\tpthread_mutex_lock(&obj->mutex);\n\twhile (obj->val < val) {\n\t\tpthread_cond_wait(&obj->cond, &obj->mutex);\n\t}\n\tpthread_mutex_unlock(&obj->mutex);\n\treturn 0;\n}\n\u0005End File\u0006/*\n * Copyright (c) 2012 Mellanox Technologies, Inc.  All rights reserved.\n *\n * This software is available to you under a choice of one of two\n * licenses.  You may choose to be licensed under the terms of the GNU\n * General Public License (GPL) Version 2, available from the file\n * COPYING in the main directory of this source tree, or the\n * OpenIB.org BSD license below:\n *\n *     Redistribution and use in source and binary forms, with or\n *     without modification, are permitted provided that the following\n *     conditions are met:\n *\n *      - Redistributions of source code must retain the above\n *        copyright notice, this list of conditions and the following\n *        disclaimer.\n *\n *      - Redistributions in binary form must reproduce the above\n *        copyright notice, this list of conditions and the following\n *        disclaimer in the documentation and/or other materials\n *        provided with the distribution.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS\n * BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN\n * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\n * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n */\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <pthread.h>\n#include <netinet/in.h>\n#include <string.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <sys/mman.h>\n#include <math.h>\n#include <infiniband/verbs.h>\n#include <infiniband/verbs_exp.h>\n#include <getopt.h>\n\n#define UMMAP_FILE_NAME \"/tmp/testodp\"\n#define RDMA_MODE_NIC                  0\n#define RDMA_MODE_USE_ONCE             1\n#define RDMA_MODE_USE_TREE_TIMES       2\n#define RDMA_MODE_USE_FEW              3\n#define RDMA_MODE_NOT_USE_AT_ALL       4\n\n#define RDMA_MR_MODE_DM_TYPE 0\n#define RDMA_MR_MODE_MR_TYPE 1\n\n#define HELLO_WORLD_MSG_SIZE\t\t13\n#define MSG_SIZE 13\n#define DEFAULT_PORT 18515\n#define DEFAULT_PSN  1234\n#define QUEUE_DEPTH  2048\n#define SQ_DEPTH  2048\n#define MAX_SEND_SGE 1\n#define TEST_RETRY\t  10\n#define MAX_QP_NUM    20\n#define GUID_LEN 19\n\nstruct app_context {\n\tstruct ibv_context\t\t *context;\n\tstruct ibv_pd\t\t\t *pd;\n\tstruct ibv_mr\t\t\t *mr;\n\tstruct ibv_dm\t\t\t *dm;\n\tvoid\t\t\t\t *mmap_buffer;\n\tint \t\t\t\t  mmap_buffer_size;\n\tstruct ibv_comp_channel\t\t *ch;\n\tstruct ibv_cq\t\t\t *scq;\n\tstruct ibv_cq\t\t\t *rcq;\n\tstruct ibv_qp\t\t\t *qp;\n\tvoid\t\t\t\t *buf;\n\tsize_t\t\t\t\t  size;\n\tint\t\t\t\t  send_flags;\n\tint\t\t\t\t  rx_depth;\n\tint\t\t\t\t  pending;\n\tstruct ibv_port_attr\t\t  portinfo;\n\tstruct ibv_exp_device_attr \t  device_attr;\n\tuint64_t\t\t\t  dm_buf_size;\n\tuint64_t\t\t\t  dm_buf_offs;\n\tint\t\t\t\t  dm_buf_registered;\n\tchar\t\t\t\t  guid[GUID_LEN];\n\tint\t\t\t\t  use_odp;\n\tint\t\t\t\t  use_dm;\n\tint \t\t\t\t  use_mmap;\n\tint\t\t\t\t  page_size;\n\tint\t\t\t\t  rdma_mode;\n\tint\t\t\t\t  dm_mr_mode;\n\tint\t\t\t\t  pkey_index;\n};\n\nstruct app_dest {\n\tint\t\t\t lid;\n\tint\t\t\t qpn;\n\tint\t\t\t psn;\n\tunion ibv_gid\t\t gid;\n};\n\nenum {\n\tPINGPONG_RECV_WRID = 1,\n\tPINGPONG_SEND_WRID = 2,\n};\n\nenum ATTR {\n\tR_ATTR = 0x1,\n\tW_ATTR = 0x2\n};\n\n\nstatic int page_size;\n\nstatic int do_sock_connect(int port, const char *servername)\n{\n\tstruct addrinfo *res, *t;\n\tstruct addrinfo hints = {\n\t\t.ai_family   = AF_INET,\n\t\t.ai_socktype = SOCK_STREAM\n\t};\n\tchar *service;\n\tint n, sockfd = -1;\n\tint so_reuseaddr = 1;\n\n\tif (asprintf(&service, \"%d\", port) < 0)\n\t\treturn -1;\n\n\tn = getaddrinfo(servername, service, &hints, &res);\n\tif (n < 0) {\n\t\tfprintf(stderr, \"%s for %s:%d\\n\", gai_strerror(n), servername, port);\n\t\tfree(service);\n\t\treturn n;\n\t}\n\n\tfor (t = res; t; t = t->ai_next) {\n\t\tsockfd = socket(t->ai_family, t->ai_socktype, t->ai_protocol);\n\t\tif (sockfd >= 0) {\n\t\t\tsetsockopt(sockfd, SOL_SOCKET, SO_REUSEADDR, &so_reuseaddr,\n\t\t\t\t   sizeof so_reuseaddr);\n\t\t\tif (!connect(sockfd, t->ai_addr, t->ai_addrlen))\n\t\t\t\tbreak;\n\t\t\tclose(sockfd);\n\t\t\tsockfd = -1;\n\t\t}\n\t}\n\n\tfreeaddrinfo(res);\n\tfree(service);\n\n\tif (sockfd < 0) {\n\t\tfprintf(stderr, \"Couldn't connect to %s:%d\\n\", servername, port);\n\t\treturn sockfd;\n\t}\n\n\treturn sockfd;\n}\n\nstruct pingpong_context {\n\tstruct ibv_context\t*context;\n\tstruct ibv_comp_channel *channel;\n\tstruct ibv_pd\t\t*pd;\n\tstruct ibv_mr\t\t*mr;\n\tstruct ibv_cq\t\t*cq;\n\tstruct ibv_qp\t\t*qp;\n\tvoid\t\t\t*buf;\n\tint\t\t\t size;\n\tint\t\t\t send_flags;\n\tint\t\t\t rx_depth;\n\tint\t\t\t pending;\n\tstruct ibv_port_attr\t portinfo;\n};\n\nstatic int sock_listen(int port)\n{\n\tstruct addrinfo *res, *t;\n\tstruct addrinfo hints = {\n\t\t.ai_flags    = AI_PASSIVE,\n\t\t.ai_family   = AF_UNSPEC,\n\t\t.ai_socktype = SOCK_STREAM\n\t};\n\tchar *service;\n\tint sockfd = -1, n, connfd;\n\tint so_reuseaddr = 1;\n\n\tif (asprintf(&service, \"%d\", port) < 0)\n\t\treturn -1;\n\n\tn = getaddrinfo(NULL, service, &hints, &res);\n\n\tif (n < 0) {\n\t\tfprintf(stderr, \"%s for port %d\\n\", gai_strerror(n), port);\n\t\tfree(service);\n\t\treturn n;\n\t}\n\n\tfor (t = res; t; t = t->ai_next) {\n\t\tsockfd = socket(t->ai_family, t->ai_socktype, t->ai_protocol);\n\t\tif (sockfd >= 0) {\n\t\t\tsetsockopt(sockfd, SOL_SOCKET, SO_REUSEADDR, &so_reuseaddr,\n\t\t\t\t   sizeof so_reuseaddr);\n\t\t\tif (!bind(sockfd, t->ai_addr, t->ai_addrlen))\n\t\t\t\tbreak;\n\t\t\tclose(sockfd);\n\t\t\tsockfd = -1;\n\t\t}\n\t}\n\n\tfreeaddrinfo(res);\n\tfree(service);\n\n\tif (sockfd < 0) {\n\t\tfprintf(stderr, \"Couldn't listen to port %d\\n\", port);\n\t\treturn sockfd;\n\t}\n\n\tlisten(sockfd, 1);\n\tconnfd = accept(sockfd, NULL, 0);\n\tif (connfd < 0) {\n\t\tperror(\"server accept\");\n\t\tclose(sockfd);\n\t\treturn connfd;\n\t}\n\n\tclose(sockfd);\n\treturn connfd;\n}\n\nstatic int sock_sync_data(int sock, int xfer_size, char *local_data, char *remote_data)\n{\n\tint rc;\n\tint read_bytes = 0;\n\tint total_read_bytes = 0;\n\n\trc = write(sock, local_data, xfer_size);\n\tif (rc < xfer_size)\n\t\tfprintf(stderr, \"Failed writing data during sock_sync_data\\n\");\n\telse\n\t\trc = 0;\n\n\twhile (!rc && total_read_bytes < xfer_size) {\n\t\tread_bytes = read(sock, remote_data + total_read_bytes,\n\t\t\t\t  xfer_size - total_read_bytes);\n\t\tif (read_bytes > 0)\n\t\t\ttotal_read_bytes += read_bytes;\n\t\telse\n\t\t\trc = read_bytes;\n\t}\n\n\treturn rc;\n}\n\nstatic struct app_context *init_ctx(struct ibv_device *ib_dev, int size, int use_odp, int use_dm, int use_mmap, int rdma_mode, int dm_mr_mode, int port, int pkey_index)\n{\n\tstruct app_context *ctx;\n\tint access_flags = IBV_ACCESS_LOCAL_WRITE;\n\tstruct ibv_exp_device_attr dev_attr;\n\tchar *ptr;\n\tint rc;\n\tint odp_support = 0;\n\tint dm_support = 0;\n\tint mr_access_flags = IBV_ACCESS_LOCAL_WRITE;\n\n\tctx = calloc(1, sizeof(*ctx));\n\tif (!ctx)\n\t\treturn NULL;\n\n\tctx->size = size;\n\tctx->send_flags = IBV_SEND_SIGNALED;\n\tctx->rx_depth = 500;\n\tctx->use_odp = use_odp;\n\tctx->use_dm = use_dm;\n\tctx->rdma_mode = rdma_mode;\n\tctx->dm_mr_mode = dm_mr_mode;\n\tctx->use_mmap = use_mmap;\n\tctx->pkey_index = pkey_index;\n\n\tsize_t alignment = sysconf(_SC_PAGESIZE);\n\n\tif (rdma_mode == RDMA_MODE_NIC) {\n\t\trc = posix_memalign(&ctx->buf, alignment, size);\n\t\tif (rc) {\n\t\t\tfprintf(stderr, \"posix_memalign failed %m\\n\");\n\t\t\treturn NULL;\n\t\t}\n\n\t\tmemset(ctx->buf, 0, size);\n\t}\n\n\tctx->page_size = sysconf(_SC_PAGESIZE);\n\tctx->context = ibv_open_device(ib_dev);\n\tif (!ctx->context) {\n\t\tfprintf(stderr, \"Couldn't get context for %s\\n\",\n\t\t\tibv_get_device_name(ib_dev));\n\t\tgoto clean_buffer;\n\t}\n\n\tmemset(&dev_attr, 0, sizeof(dev_attr));\n\tdev_attr.comp_mask = IBV_EXP_DEVICE_ATTR_ODP;\n\tdev_attr.comp_mask |= IBV_EXP_DEVICE_ATTR_EXP_CAP_FLAGS;\n\tdev_attr.comp_mask |= IBV_EXP_DEVICE_ATTR_DEVICE_MEMORY;\n\n\trc = ibv_exp_query_device(ctx->context, &dev_attr);\n\tif (rc) {\n\t\tfprintf(stderr, \"ibv_exp_query_device failed %m\\n\");\n\t\tgoto clean_device;\n\t}\n\n\t/* Check if device supports ODP */\n\tif (dev_attr.comp_mask & IBV_EXP_DEVICE_ATTR_ODP) {\n\t\tif ((dev_attr.odp_caps.general_caps & IBV_EXP_ODP_SUPPORT_SEND) &&\n\t\t    (dev_attr.odp_caps.general_caps & IBV_EXP_ODP_SUPPORT_RECV)) {\n\t\t\tif (dev_attr.odp_caps.per_transport_caps.rc_odp_caps &\n\t\t\t    IBV_EXP_ODP_SUPPORT_SEND) {\n\t\t\t\todp_support = 1;\n\t\t\t\tfprintf(stdout, \"RC ODP send is supported.\\n\");\n\t\t\t}\n\t\t\tif (dev_attr.odp_caps.per_transport_caps.rc_odp_caps &\n\t\t\t    IBV_EXP_ODP_SUPPORT_RECV) {\n\t\t\t\todp_support = 1;\n\t\t\t\tfprintf(stdout, \"RC ODP recv is supported.\\n\");\n\t\t\t}\n\t\t}\n\t}\n\n\tif (!odp_support && use_odp) {\n\t\tfprintf(stderr, \"ODP requested but it is not supported\\n\");\n\t\tgoto clean_device;\n\t}\n\n\t/* Check if device supports DM */\n\tif (dev_attr.comp_mask & IBV_EXP_DEVICE_ATTR_DEVICE_MEMORY &&\n\t    dev_attr.device_memory_cap_flags & IBV_EXP_DEVICE_MEMORY_CAP_ON_DEMAND) {\n\t\tdm_support = 1;\n\t\tfprintf(stdout, \"DM is supported, max_dm %zu max_dm_size: %zu\\n\",\n\t\t\tdev_attr.max_dm, dev_attr.max_dm_size);\n\t}\n\n\tif (!dm_support && use_dm) {\n\t\tfprintf(stderr, \"DM requested but it is not supported\\n\");\n\t\tgoto clean_device;\n\t}\n\n\tmemcpy(&ctx->device_attr, &dev_attr, sizeof(dev_attr));\n\n\tctx->pd = ibv_alloc_pd(ctx->context);\n\tif (!ctx->pd) {\n\t\tfprintf(stderr, \"Couldn't allocate PD\\n\");\n\t\tgoto clean_device;\n\t}\n\n\tctx->ch = ibv_create_comp_channel(ctx->context);\n\tif (!ctx->ch) {\n\t\tfprintf(stderr, \"ibv_create_comp_channel failed %m\\n\");\n\t\tgoto clean_pd;\n\t}\n\n\tctx->scq = ibv_create_cq(ctx->context, QUEUE_DEPTH, NULL, ctx->ch, 0);\n\tif (!ctx->scq) {\n\t\tfprintf(stderr, \"ibv_create_cq failed %m\\n\");\n\t\tgoto clean_ch;\n\t}\n\n\tctx->rcq = ibv_create_cq(ctx->context, QUEUE_DEPTH, NULL, ctx->ch, 0);\n\tif (!ctx->rcq) {\n\t\tfprintf(stderr, \"ibv_create_cq failed %m\\n\");\n\t\tgoto clean_scq;\n\t}\n\n\tif (ctx->use_odp)\n\t\taccess_flags |= IBV_ACCESS_ON_DEMAND;\n\n\tif (ctx->rdma_mode == RDMA_MODE_NIC) {\n\t\tctx->mr = ibv_reg_mr(ctx->pd, ctx->buf, size, access_flags);\n\t\tif (!ctx->mr) {\n\t\t\tfprintf(stderr, \"Couldn't register MR\\n\");\n\t\t\tgoto clean_rcq;\n\t\t}\n\t} else if (ctx->use_mmap) {\n\t\tint mmap_fd;\n\t\tint map_flags = MAP_SHARED;\n\t\tint prot_flags = PROT_READ | PROT_WRITE;\n\t\tint size_to_mmap;\n\n\t\t/* Round up the buffer size to multiple of page_size */\n\t\tctx->mmap_buffer_size = (size + ctx->page_size - 1) &\n\t\t\t~(ctx->page_size - 1);\n\t\tsize_to_mmap = ctx->mmap_buffer_size;\n\n\t\tmmap_fd = open(UMMAP_FILE_NAME, O_CREAT | O_RDWR, S_IRWXU);\n\t\tif (mmap_fd < 0) {\n\t\t\tfprintf(stderr, \"Error opening %s\\n\", UMMAP_FILE_NAME);\n\t\t\tgoto clean_rcq;\n\t\t}\n\n\t\t/* PROT_WRITE requires either truncate or actual write */\n\t\trc = fallocate(mmap_fd, 0, 0, size_to_mmap);\n\t\tif (rc) {\n\t\t\tfprintf(stderr, \"Error on mmap falloc %m\\n\");\n\t\t\tgoto clean_mmap_fd;\n\t\t}\n\n\t\tctx->mmap_buffer = mmap(NULL, size_to_mmap, prot_flags,\n\t\t\t\t\tmap_flags, mmap_fd, 0);\n\t\tif (ctx->mmap_buffer == MAP_FAILED) {\n\t\t\tfprintf(stderr, \"Error doing mmap %m\\n\");\n\t\t\tgoto clean_mmap_fd;\n\t\t}\n\n\t\tfprintf(stdout, \"Mapped to %p for %d bytes\\n\", ctx->mmap_buffer,\n\t\t\tsize_to_mmap);\n\n\t\tmemset(ctx->mmap_buffer, 0, size_to_mmap);\n\n\t\tclose(mmap_fd);\n\n\t\tmr_access_flags = IBV_ACCESS_LOCAL_WRITE;\n\t\tif (ctx->use_odp)\n\t\t\tmr_access_flags |= IBV_ACCESS_ON_DEMAND;\n\n\t\tctx->mr = ibv_reg_mr(ctx->pd, ctx->mmap_buffer, size_to_mmap,\n\t\t\t\t      mr_access_flags);\n\t\tif (!ctx->mr) {\n\t\t\tfprintf(stderr, \"Error registering mr %m\\n\");\n\t\t\tmunmap(ctx->mmap_buffer, size_to_mmap);\n\t\t\tgoto clean_rcq;\n\t\t}\n\t} else if (ctx->use_dm) {\n\t\tstruct ibv_exp_alloc_dm_attr    dm_attr;\n\t\tstruct ibv_exp_reg_mr_in        mr_in;\n\t\tuint64_t                        dm_size;\n\t\tuint64_t                        dm_alignment;\n\n\t\tdm_size = ctx->device_attr.max_dm_size;\n\t\tif (dm_size > size)\n\t\t\tdm_size = size;\n\n\t\t/* DM will do access aligment for us but we need to make sure\n\t\t * the address size is aligned.\n\t\t */\n\t\tdm_alignment = ctx->device_attr.dm_mr_alignment;\n\t\tdm_size = (dm_size + dm_alignment - 1) & ~(dm_alignment - 1);\n\n\t\t/* Can we have dm_size this large */\n\t\tif (dm_size > ctx->device_attr.max_dm_size) {\n\t\t\tfprintf(stderr, \"Can't have DM that large. Max allowed %zu asked %zu\\n\",\n\t\t\t\tctx->device_attr.max_dm_size, dm_size);\n\t\t\tgoto clean_rcq;\n\t\t}\n\n\t\tmemset(&dm_attr, 0, sizeof(dm_attr));\n\t\tdm_attr.length = dm_size;\n\t\tdm_attr.comp_mask = 0;\n\n\t\tctx->dm = ibv_exp_alloc_dm(ctx->context, &dm_attr);\n\t\tif (!ctx->dm) {\n\t\t\tfprintf(stderr, \"Error allocating dm %m\\n\");\n\t\t\tgoto clean_rcq;\n\t\t}\n\n\t\t/* Set 0's. Can set data like \"Hello world\" here as well */\n\t\tptr = calloc(1, dm_size);\n\t\tif (!ptr)\n\t\t\tgoto clean_dm;\n\n\t\trc = ibv_exp_memcpy_to_dm(ctx->dm, 0, ptr, dm_size);\n\t\tif (rc) {\n\t\t\tfprintf(stderr, \"Error writing to dm: %d\\n\", rc);\n\t\t\tfree(ptr);\n\t\t\tgoto clean_dm;\n\t\t}\n\n\t\tfree(ptr);\n\n\t\tctx->dm_buf_size = dm_size;\n\t\tctx->dm_buf_offs = 0;\n\t\tctx->dm_buf_registered = 1;\n\n\t\t/* Register the DM - create an MR with it. The parameters\n\t\t * depend on the type we use.\n\t\t */\n\t\tmemset(&mr_in, 0, sizeof(mr_in));\n\t\tmr_in.pd = ctx->pd;\n\t\tmr_in.addr = 0;\n\t\tmr_in.length = dm_size;\n\t\tmr_in.exp_access = IBV_ACCESS_LOCAL_WRITE |\n\t\t\tIBV_EXP_ACCESS_RELAXED_ORDERING;\n\n\t\tif (ctx->dm_mr_mode == RDMA_MR_MODE_DM_TYPE) {\n\t\t\t/* DM type */\n\t\t\tmr_in.comp_mask = IBV_EXP_REG_MR_DM;\n\t\t\tmr_in.dm = ctx->dm;\n\t\t\tfprintf(stdout, \"Using DM type.\\n\");\n\t\t} else if (ctx->dm_mr_mode == RDMA_MR_MODE_MR_TYPE) {\n\t\t\t/* Traditional mr, referring to the DM allocated */\n\t\t\tmr_in.comp_mask = 0;\n\t\t\tfprintf(stdout, \"Using MR type.\\n\");\n\t\t} else {\n\t\t\tgoto clean_dm;\n\t\t}\n\n\t\tctx->mr = ibv_exp_reg_mr(&mr_in);\n\t\tif (!ctx->mr) {\n\t\t\tfprintf(stderr, \"Failed to register DM MR type %d\\n\",\n\t\t\t\tctx->dm_mr_mode);\n\t\t\tgoto clean_dm;\n\t\t}\n\n\t\tfprintf(stdout, \"Using DM mr with lkey 0x%x and rkey 0x%x (addr=%p size %lu)\\n\",\n\t\t\tctx->mr->lkey, ctx->mr->rkey, ctx->mr->addr,\n\t\t\tctx->dm_buf_size);\n\t} else {\n\t\tfprintf(stderr, \"Missing registration type\\n\");\n\t\tgoto clean_rcq;\n\t}\n\n\trc = ibv_query_port(ctx->context, port, &ctx->portinfo);\n\tif (rc) {\n\t\tfprintf(stderr, \"ibv_query_port failed %m\\n\");\n\t\tgoto clean_mr;\n\t}\n\n\tuint64_t guid;\n\tguid = ibv_get_device_guid(ib_dev);\n\tsprintf(ctx->guid, \"%04x:%04x:%04x:%04x\",\n\t\t(unsigned) ((guid >> 48) & 0xffff),\n\t\t(unsigned) ((guid >> 32) & 0xffff),\n\t\t(unsigned) ((guid >> 16) & 0xffff),\n\t\t(unsigned) (guid & 0xffff));\n\n\treturn ctx;\n\nclean_mr:\n\tibv_dereg_mr(ctx->mr);\nclean_dm:\n\tif (ctx->dm)\n\t\tibv_exp_free_dm(ctx->dm);\nclean_mmap_fd:\n\tif (ctx->use_mmap)\n\t\tclose(mmap_fd);\nclean_rcq:\n\tibv_destroy_cq(ctx->rcq);\nclean_scq:\n\tibv_destroy_cq(ctx->scq);\nclean_ch:\n\tibv_destroy_comp_channel(ctx->ch);\nclean_pd:\n\tibv_dealloc_pd(ctx->pd);\nclean_device:\n\tibv_close_device(ctx->context);\nclean_buffer:\n\tif (ctx->rdma_mode == RDMA_MODE_NIC)\n\t\tfree(ctx->buf);\n\tfree(ctx);\n\n\treturn NULL;\n}\n\nstatic int close_ctx(struct app_context *ctx)\n{\n\tint status;\n\n\tif (ctx->rdma_mode == RDMA_MODE_NIC)\n\t\tfree(ctx->buf);\n\n\tstatus = ibv_dereg_mr(ctx->mr);\n\tif (status) {\n\t\tfprintf(stderr, \"Error deregistering mr\\n\");\n\t\treturn status;\n\t}\n\n\tif (ctx->use_dm && ctx->dm) {\n\t\tstatus = ibv_exp_free_dm(ctx->dm);\n\t\tif (status) {\n\t\t\tfprintf(stderr, \"Error freeing dm\\n\");\n\t\t\treturn status;\n\t\t}\n\t}\n\n\tif (ctx->use_mmap && ctx->mmap_buffer) {\n\t\tstatus = munmap(ctx->mmap_buffer, ctx->mmap_buffer_size);\n\t\tif (status) {\n\t\t\tfprintf(stderr, \"Error unmapping %m\\n\");\n\t\t\treturn status;\n\t\t}\n\t\tunlink(UMMAP_FILE_NAME);\n\t}\n\n\tstatus = ibv_destroy_cq(ctx->rcq);\n\tif (status) {\n\t\tfprintf(stderr, \"Error destroying rcq\\n\");\n\t\treturn status;\n\t}\n\n\tstatus = ibv_destroy_cq(ctx->scq);\n\tif (status) {\n\t\tfprintf(stderr, \"Error destroying scq\\n\");\n\t\treturn status;\n\t}\n\n\tstatus = ibv_destroy_comp_channel(ctx->ch);\n\tif (status) {\n\t\tfprintf(stderr, \"Error destroying channel\\n\");\n\t\treturn status;\n\t}\n\n\tstatus = ibv_dealloc_pd(ctx->pd);\n\tif (status) {\n\t\tfprintf(stderr, \"Error freeing pd\\n\");\n\t\treturn status;\n\t}\n\n\tstatus = ibv_close_device(ctx->context);\n\tif (status) {\n\t\tfprintf(stderr, \"Error closing device\\n\");\n\t\treturn status;\n\t}\n\n\tfree(ctx);\n\n\treturn 0;\n}\n\nstatic int create_qp(struct app_context *ctx)\n{\n\tstruct ibv_qp_init_attr attr = {\n\t\t.send_cq = ctx->scq,\n\t\t.recv_cq = ctx->rcq,\n\t\t.cap     = {\n\t\t\t.max_send_wr  = SQ_DEPTH,\n\t\t\t.max_recv_wr  = ctx->rx_depth,\n\t\t\t.max_send_sge = MAX_SEND_SGE,\n\t\t\t.max_recv_sge = 1\n\t\t},\n\t\t.qp_type = IBV_QPT_RC\n\t};\n\n\tctx->qp = ibv_create_qp(ctx->pd, &attr);\n\tif (!ctx->qp)  {\n\t\tfprintf(stderr, \"Couldn't create QP\\n\");\n\t\treturn 1;\n\t}\n\n\treturn 0;\n}\n\nstatic int modify_to_init(struct app_context *ctx)\n{\n\tstruct ibv_qp_attr attr;\n\tint flags;\n\tint rc;\n\n\tmemset(&attr, 0, sizeof(attr));\n\n\tattr.qp_state        = IBV_QPS_INIT;\n\tattr.port_num        = 1;\n\tattr.pkey_index      = ctx->pkey_index;\n\tattr.qp_access_flags = IBV_ACCESS_LOCAL_WRITE | IBV_ACCESS_REMOTE_READ | IBV_ACCESS_REMOTE_WRITE;\n\n\tflags = IBV_QP_STATE | IBV_QP_PKEY_INDEX | IBV_QP_PORT | IBV_QP_ACCESS_FLAGS;\n\n\trc = ibv_modify_qp(ctx->qp, &attr, flags);\n\tif (rc) {\n\t\tfprintf(stderr, \"Failed to modify QP to INIT\\n\");\n\t\treturn 1;\n\t}\n\n\treturn 0;\n}\n\nstatic int modify_to_rtr(struct app_context *ctx, int remote_qpn, int dlid,\n\t\t\t int sgid_idx, uint8_t *dgid)\n{\n\tstruct ibv_qp_attr attr;\n\tint flags;\n\tint rc;\n\n\tmemset(&attr, 0, sizeof(attr));\n\n\tattr.qp_state                = IBV_QPS_RTR;\n\tattr.path_mtu                = IBV_MTU_2048;\n\tattr.dest_qp_num             = remote_qpn;\n\tattr.rq_psn                  = 0;\n\tattr.max_dest_rd_atomic      = 1;\n\tattr.min_rnr_timer           = 0x12;\n\tattr.ah_attr.is_global       = 0;\n\tattr.ah_attr.dlid            = dlid;\n\tattr.ah_attr.sl              = 0;\n\tattr.ah_attr.src_path_bits   = 0;\n\tattr.ah_attr.port_num        = 1;\n\n\tif (dgid) {\n\t\tattr.ah_attr.is_global       = 1;\n\t\tattr.ah_attr.port_num        = 1;\n\t\tattr.ah_attr.grh.hop_limit   = 1;\n\t\tattr.ah_attr.grh.sgid_index  = sgid_idx;\n\t\tattr.ah_attr.grh.traffic_class = 0;\n\t\tmemcpy(&attr.ah_attr.grh.dgid, dgid, 16);\n\t}\n\n\tflags = IBV_QP_STATE | IBV_QP_AV | IBV_QP_PATH_MTU | IBV_QP_DEST_QPN |\n\t\tIBV_QP_RQ_PSN | IBV_QP_MAX_DEST_RD_ATOMIC | IBV_QP_MIN_RNR_TIMER;\n\n\trc = ibv_modify_qp(ctx->qp, &attr, flags);\n\tif (rc) {\n\t\tfprintf(stderr, \"Failed to modify QP to RTR\\n\");\n\t\treturn 1;\n\t}\n\n\treturn 0;\n}\n\nstatic int modify_to_rts(struct app_context *ctx)\n{\n\tstruct ibv_qp_attr attr;\n\tint flags;\n\tint rc;\n\n\tmemset(&attr, 0, sizeof(attr));\n\n\tattr.qp_state      = IBV_QPS_RTS;\n\tattr.timeout       = 0x12; /* very high timeout */\n\tattr.retry_cnt     = 7;\n\tattr.rnr_retry     = 7;\n\tattr.sq_psn        = 0;\n\tattr.max_rd_atomic = 1;\n\n\tflags = IBV_QP_STATE | IBV_QP_TIMEOUT | IBV_QP_RETRY_CNT |\n\t\tIBV_QP_RNR_RETRY | IBV_QP_SQ_PSN | IBV_QP_MAX_QP_RD_ATOMIC;\n\n\trc = ibv_modify_qp(ctx->qp, &attr, flags);\n\tif (rc) {\n\t\tfprintf(stderr, \"Failed to modify QP to RTS\\n\");\n\t\treturn 1;\n\t}\n\n\treturn 0;\n}\n\nstatic int establish_conn(struct app_context *ctx, int sockfd, int is_server)\n{\n\tstruct app_dest     my_dest;\n\tstruct app_dest     rem_dest;\n\tchar                gid[33];\n\tint                 rc;\n\tunion ibv_gid       mgid;\n\tint                 sgid_idx = 0;\n\n\t/* Just pick the first GID */\n\tibv_query_gid(ctx->context, 1, sgid_idx, &mgid);\n\n\trc = create_qp(ctx);\n\tif (rc) {\n\t\tfprintf(stderr, \"Failed to create QP\\n\");\n\t\treturn rc;\n\t}\n\n\tif (modify_to_init(ctx)) {\n\t\tfprintf(stderr, \"Failed to modify QP to INIT\\n\");\n\t\treturn 1;\n\t}\n\n\t/* QPN, PSN, LID, GID */\n\tmy_dest.qpn = ctx->qp->qp_num;\n\tmy_dest.psn = lrand48() & 0xffffff;\n\tmy_dest.lid = ctx->portinfo.lid;\n\tmy_dest.gid = mgid;\n\n\tfprintf(stdout, \"Local QP number  = 0x%x\\n\", my_dest.qpn);\n\tfprintf(stdout, \"Local LID        = 0x%x\\n\", my_dest.lid);\n\n\tgid_to_wire_gid(&my_dest.gid, gid);\n\tfprintf(stdout, \"Local GID        = %s\\n\", gid);\n\n\t/* Send dest info */\n\trc = sock_sync_data(sockfd, sizeof(struct app_dest), (char*)&my_dest,\n\t\t\t     (char*)&rem_dest);\n\tif (rc) {\n\t\tfprintf(stderr, \"Couldn't exchange data via socket\\n\");\n\t\treturn rc;\n\t}\n\n\tgid_to_wire_gid(&rem_dest.gid, gid);\n\tfprintf(stdout, \"Remote QP number = 0x%x\\n\", rem_dest.qpn);\n\tfprintf(stdout, \"Remote LID       = 0x%x\\n\", rem_dest.lid);\n\tfprintf(stdout, \"Remote GID       = %s\\n\", gid);\n\n\t/* Move QP to RTR */\n\trc = modify_to_rtr(ctx, rem_dest.qpn, rem_dest.lid, sgid_idx,\n\t\t\t   rem_dest.gid.raw);\n\tif (rc) {\n\t\tfprintf(stderr, \"Failed to move QP to RTR\\n\");\n\t\treturn rc;\n\t}\n\n\t/* Move QP to RTS */\n\trc = modify_to_rts(ctx);\n\tif (rc) {\n\t\tfprintf(stderr, \"Failed to move QP to RTS\\n\");\n\t\treturn rc;\n\t}\n\n\t/* Sync to make sure both sides are ready */\n\trc = sock_sync_data(sockfd, 1, \"R\", \"S\");\n\tif (rc) {\n\t\tfprintf(stderr, \"Couldn't sync\\n\");\n\t\treturn rc;\n\t}\n\n\treturn 0;\n}\n\nstatic int post_recv(struct app_context *ctx, int n)\n{\n\tstruct ibv_sge list = {\n\t\t.addr\t= (uintptr_t) ctx->buf,\n\t\t.length = ctx->size,\n\t\t.lkey\t= ctx->mr->lkey\n\t};\n\n\tstruct ibv_recv_wr wr = {\n\t\t.wr_id\t    = PINGPONG_RECV_WRID,\n\t\t.sg_list    = &list,\n\t\t.num_sge    = 1,\n\t};\n\n\tstruct ibv_recv_wr *bad_wr;\n\tint i;\n\tint rc;\n\n\tfor (i = 0; i < n; i++) {\n\t\trc = ibv_post_recv(ctx->qp, &wr, &bad_wr);\n\t\tif (rc) {\n\t\t\tfprintf(stderr, \"Error posting recv %d\\n\", rc);\n\t\t\treturn 1;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int post_send(struct app_context *ctx)\n{\n\tstruct ibv_sge list = {\n\t\t.addr\t= (uintptr_t) ctx->buf,\n\t\t.length = ctx->size,\n\t\t.lkey\t= ctx->mr->lkey\n\t};\n\n\t/* In case we're using DM we want to read from the DM which we init */\n\tif (ctx->use_dm) {\n\t\tlist.addr = 0;\n\t\tlist.length = ctx->dm_buf_size;\n\t}\n\n\tstruct ibv_send_wr wr = {\n\t\t.wr_id\t    = PINGPONG_SEND_WRID,\n\t\t.sg_list    = &list,\n\t\t.num_sge    = 1,\n\t\t.opcode     = IBV_WR_SEND,\n\t\t.send_flags = ctx->send_flags,\n\t};\n\n\tstruct ibv_send_wr *bad_wr;\n\tint rc;\n\n\trc = ibv_post_send(ctx->qp, &wr, &bad_wr);\n\tif (rc) {\n\t\tfprintf(stderr, \"Error posting send %d\\n\", rc);\n\t\treturn 1;\n\t}\n\n\treturn 0;\n}\n\nstatic int poll_cq(struct app_context *ctx, struct ibv_cq *cq, int is_send)\n{\n\tstruct ibv_wc wc;\n\tint rc;\n\n\tdo {\n\t\trc = ibv_poll_cq(cq, 1, &wc);\n\t\tif (rc < 0) {\n\t\t\tfprintf(stderr, \"ibv_poll_cq failed %d\\n\", rc);\n\t\t\treturn 1;\n\t\t}\n\t} while (rc < 1);\n\n\tif (wc.status != IBV_WC_SUCCESS) {\n\t\tfprintf(stderr, \"Completion with error %s\\n\",\n\t\t\tibv_wc_status_str(wc.status));\n\t\treturn 1;\n\t}\n\n\tif (is_send && wc.wr_id != PINGPONG_SEND_WRID) {\n\t\tfprintf(stderr, \"Unexpected wrid got %llu expected %d\\n\",\n\t\t\twc.wr_id, PINGPONG_SEND_WRID);\n\t\treturn 1;\n\t}\n\n\tif (!is_send && wc.wr_id != PINGPONG_RECV_WRID) {\n\t\tfprintf(stderr, \"Unexpected wrid got %llu expected %d\\n\",\n\t\t\twc.wr_id, PINGPONG_RECV_WRID);\n\t\treturn 1;\n\t}\n\n\treturn 0;\n}\n\nstatic void wire_gid_to_gid(const char *wgid, union ibv_gid *gid)\n{\n\tchar tmp[9];\n\tuint32_t v32;\n\tuint32_t *raw = (uint32_t *)gid->raw;\n\tint i;\n\n\tfor (tmp[8] = 0, i = 0; i < 4; ++i) {\n\t\tmemcpy(tmp, wgid + i * 8, 8);\n\t\tsscanf(tmp, \"%x\", &v32);\n\t\traw[i] = ntohl(v32);\n\t}\n}\n\nstatic void gid_to_wire_gid(const union ibv_gid *gid, char wgid[])\n{\n\tint i;\n\tuint32_t *raw = (uint32_t *)gid->raw;\n\n\tfor (i = 0; i < 4; ++i)\n\t\tsprintf(&wgid[i * 8], \"%08x\", htonl(raw[i]));\n}\n\nstatic void usage(const char *argv0)\n{\n\tprintf(\"Usage:\\n\");\n\tprintf(\"  %s            start a server and wait for connection\\n\", argv0);\n\tprintf(\"  %s <host>     connect to server at <host>\\n\", argv0);\n\tprintf(\"\\n\");\n\tprintf(\"Options:\\n\");\n\tprintf(\"  -o, --use-odp            use ODP registration\\n\");\n\tprintf(\"  -m, --use-mmap            use MMap registration\\n\");\n\tprintf(\"  -d, --use-dm             use DM registration\\n\");\n\tprintf(\"  -r, --rdma-mode          Type of memory usage: 0 NIC, 1 Once, 2 Three times, 3 Few, 4 Not at all (default 0)\\n\");\n\tprintf(\"  -M, --mr-dm-mode         Type of MR/DM usage: 0 DM, 1 MR (default 0)\\n\");\n\tprintf(\"  -p, --port=<port>        listen on/connect to port <port> (default 18515)\\n\");\n\tprintf(\"  -P, --pkey=<pkey>        Use pkey <pkey> (default 0)\\n\");\n\tprintf(\"  -h, --help               show this help screen\\n\");\n}\n\nint create_threads(void* (*start_routine) (void *), void **arg, pthread_t *thread, int num_threads)\n{\n\tint i, err;\n\n\tfor (i = 0; i < num_threads; i++) {\n\t\terr = pthread_create(&thread[i], NULL, start_routine, arg[i]);\n\t\tif (err) {\n\t\t\tfprintf(stderr, \"Couldn't create thread num %d\\n\", i);\n\t\t\treturn 1;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nint main(int argc, char *argv[])\n{\n\tstruct ibv_device\t**dev_list;\n\tstruct ibv_device\t*ib_dev = NULL;\n\tstruct app_context\t*ctx;\n\tchar\t\t\t*servername = NULL;\n\tint\t\t\tnum_devices;\n\tint\t\t\trc = 0;\n\tint\t\t\tport = DEFAULT_PORT;\n\tint\t\t\tsockfd = -1;\n\tint\t\t\tis_server;\n\tint\t\t\tuse_odp = 0;\n\tint\t\t\tuse_dm = 0;\n\tint\t\t\tuse_mmap = 0;\n\tint\t\t\trdma_mode = RDMA_MODE_NIC;\n\tint\t\t\tdm_mr_mode = RDMA_MR_MODE_DM_TYPE;\n\tint\t\t\tsize = MSG_SIZE;\n\tint\t\t\tpkey_index = 0;\n\tconst char\t\t*device_name = NULL;\n\n\tstatic struct option long_options[] = {\n\t\t{ .name = \"help\",       .has_arg = 0, .val = 'h' },\n\t\t{ .name = \"use-odp\",    .has_arg = 0, .val = 'o' },\n\t\t{ .name = \"use-dm\",     .has_arg = 0, .val = 'd' },\n\t\t{ .name = \"use-mmap\",   .has_arg = 0, .val = 'm' },\n\t\t{ .name = \"rdma-mode\",  .has_arg = 1, .val = 'r' },\n\t\t{ .name = \"mr-dm-mode\", .has_arg = 1, .val = 'M' },\n\t\t{ .name = \"port\",       .has_arg = 1, .val = 'p' },\n\t\t{ .name = \"pkey\",       .has_arg = 1, .val = 'P' },\n\t\t{ 0 }\n\t};\n\n\tpage_size = sysconf(_SC_PAGESIZE);\n\n\twhile (1) {\n\t\tint c;\n\n\t\tc = getopt_long(argc, argv, \"homdp:P:r:M:\",\n\t\t\t\tlong_options, NULL);\n\t\tif (c == -1)\n\t\t\tbreak;\n\n\t\tswitch (c) {\n\t\tcase 'o':\n\t\t\tuse_odp = 1;\n\t\t\tbreak;\n\n\t\tcase 'd':\n\t\t\tuse_dm = 1;\n\t\t\tbreak;\n\n\t\tcase 'm':\n\t\t\tuse_mmap = 1;\n\t\t\tbreak;\n\n\t\tcase 'r':\n\t\t\trdma_mode = strtol(optarg, NULL, 0);\n\t\t\tbreak;\n\n\t\tcase 'M':\n\t\t\tdm_mr_mode = strtol(optarg, NULL, 0);\n\t\t\tbreak;\n\n\t\tcase 'p':\n\t\t\tport = strtol(optarg, NULL, 0);\n\t\t\tif (port < 0 || port > 65535) {\n\t\t\t\tusage(argv[0]);\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase 'P':\n\t\t\tpkey_index = strtol(optarg, NULL, 0);\n\t\t\tbreak;\n\n\t\tcase 'h':\n\t\tdefault:\n\t\t\tusage(argv[0]);\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tif (optind == argc - 1)\n\t\tservername = strdup(argv[optind]);\n\telse if (optind < argc) {\n\t\tusage(argv[0]);\n\t\treturn 1;\n\t}\n\n\tprintf(\"Size \t\t\t= %d\\n\", size);\n\tprintf(\"Use ODP \t\t= %d\\n\", use_odp);\n\tprintf(\"Use DM  \t\t= %d\\n\", use_dm);\n\tprintf(\"Use MMap  \t\t= %d\\n\", use_mmap);\n\tprintf(\"RDMA Mode \t\t= %d\\n\", rdma_mode);\n\tprintf(\"DM/MR Mode \t\t= %d\\n\", dm_mr_mode);\n\tprintf(\"pkey_index \t\t= %d\\n\", pkey_index);\n\n\tif (use_dm && use_odp) {\n\t\tfprintf(stderr, \"Can't use DM and ODP together. Choose one.\\n\");\n\t\treturn 1;\n\t}\n\n\tif (use_dm && use_mmap) {\n\t\tfprintf(stderr, \"Can't use DM and MMap together. Choose one.\\n\");\n\t\treturn 1;\n\t}\n\n\tif (use_odp && use_mmap) {\n\t\tfprintf(stderr, \"Can't use ODP and MMap together. Choose one.\\n\");\n\t\treturn 1;\n\t}\n\n\tsrand48(getpid() * time(NULL));\n\n\tis_server = !servername;\n\n\tdev_list = ibv_get_device_list(&num_devices);\n\tif (!dev_list) {\n\t\tfprintf(stderr, \"No IB devices found\\n\");\n\t\treturn 1;\n\t}\n\n\t/* search for a device */\n\tif (!device_name) {\n\t\tib_dev = *dev_list;\n\t\tif (!ib_dev) {\n\t\t\tfprintf(stderr, \"No IB devices found\\n\");\n\t\t\treturn 1;\n\t\t}\n\t} else {\n\t\tfor (int i = 0; dev_list[i]; i++) {\n\t\t\tif (!strcmp(ibv_get_device_name(dev_list[i]), device_name)) {\n\t\t\t\tib_dev = dev_list[i];\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (!ib_dev) {\n\t\t\tfprintf(stderr, \"IB device %s not found\\n\", device_name);\n\t\t\treturn 1;\n\t\t}\n\t}\n\n\t/* Init context */\n\tctx = init_ctx(ib_dev, size, use_odp, use_dm, use_mmap, rdma_mode,\n\t\t       dm_mr_mode, 1, pkey_index);\n\tif (!ctx) {\n\t\tfprintf(stderr, \"Failed creating context\\n\");\n\t\trc = 1;\n\t\tgoto cleanup_device_list;\n\t}\n\n\tfprintf(stderr, \"Context created successfully\\n\");\n\n\t/* establish connection */\n\tif (is_server) {\n\t\tfprintf(stderr, \"Waiting on port %d for TCP connection\\n\", port);\n\t\tsockfd = sock_listen(port);\n\t\tif (sockfd < 0) {\n\t\t\tfprintf(stderr, \"Failed to establish TCP connection\\n\");\n\t\t\trc = 1;\n\t\t\tgoto cleanup_context;\n\t\t}\n\t} else {\n\t\tfprintf(stderr, \"Connecting to server on %s:%d via TCP\\n\", servername, port);\n\t\tsockfd = do_sock_connect(port, servername);\n\t\tif (sockfd < 0) {\n\t\t\tfprintf(stderr, \"Failed to establish TCP connection\\n\");\n\t\t\trc = 1;\n\t\t\tgoto cleanup_context;\n\t\t}\n\t}\n\n\tfprintf(stderr, \"TCP connection established\\n\");\n\n\trc = establish_conn(ctx, sockfd, is_server);\n\tif (rc) {\n\t\tfprintf(stderr, \"Failed to establish IB connection\\n\");\n\t\tgoto cleanup_socket;\n\t}\n\n\tfprintf(stderr, \"IB connection established\\n\");\n\n\tif (is_server) {\n\t\t/* Server - first receive request to send */\n\t\trc = post_recv(ctx, 1);\n\t\tif (rc) {\n\t\t\tfprintf(stderr, \"Failed to post receive\\n\");\n\t\t\tgoto cleanup_qp;\n\t\t}\n\n\t\trc = poll_cq(ctx, ctx->rcq, 0);\n\t\tif (rc) {\n\t\t\tfprintf(stderr, \"Failed to poll cq\\n\");\n\t\t\tgoto cleanup_qp;\n\t\t}\n\n\t\tfprintf(stderr, \"Received request from client\\n\");\n\n\t\trc = post_send(ctx);\n\t\tif (rc) {\n\t\t\tfprintf(stderr, \"Failed to post send\\n\");\n\t\t\tgoto cleanup_qp;\n\t\t}\n\n\t\trc = poll_cq(ctx, ctx->scq, 1);\n\t\tif (rc) {\n\t\t\tfprintf(stderr, \"Failed to poll cq\\n\");\n\t\t\tgoto cleanup_qp;\n\t\t}\n\n\t\tfprintf(stderr, \"Sent reply to client\\n\");\n\t} else {\n\t\trc = post_send(ctx);\n\t\tif (rc) {\n\t\t\tfprintf(stderr, \"Failed to post send\\n\");\n\t\t\tgoto cleanup_qp;\n\t\t}\n\n\t\trc = poll_cq(ctx, ctx->scq, 1);\n\t\tif (rc) {\n\t\t\tfprintf(stderr, \"Failed to poll cq\\n\");\n\t\t\tgoto cleanup_qp;\n\t\t}\n\n\t\tfprintf(stderr, \"Sent request to server\\n\");\n\n\t\trc = post_recv(ctx, 1);\n\t\tif (rc) {\n\t\t\tfprintf(stderr, \"Failed to post receive\\n\");\n\t\t\tgoto cleanup_qp;\n\t\t}\n\n\t\trc = poll_cq(ctx, ctx->rcq, 0);\n\t\tif (rc) {\n\t\t\tfprintf(stderr, \"Failed to poll cq\\n\");\n\t\t\tgoto cleanup_qp;\n\t\t}\n\n\t\tfprintf(stderr, \"Received reply from server\\n\");\n\t}\n\ncleanup_qp:\n\tibv_destroy_qp(ctx->qp);\n\ncleanup_socket:\n\tclose(sockfd);\n\ncleanup_context:\n\trc = close_ctx(ctx);\n\tif (rc) {\n\t\tfprintf(stderr, \"Failed to close connection\\n\");\n\t\trc = 1;\n\t}\n\ncleanup_device_list:\n\tibv_free_device_list(dev_list);\n\n\treturn rc;\n}\n\u0005End File\u0006# codes-ncc-4-odp/src/verbs_mr_pool.c\n/*\n * Copyright (c) 2020 Mellanox Technologies, Inc.  All rights reserved.\n *\n * This software is available to you under a choice of one of two\n * licenses.  You may choose to be licensed under the terms of the GNU\n * General Public License (GPL) Version 2, available from the file\n * COPYING in the main directory of this source tree, or the\n * OpenIB.org BSD license below:\n *\n *     Redistribution and use in source and binary forms, with or\n *     without modification, are permitted provided that the following\n *     conditions are met:\n *\n *      - Redistributions of source code must retain the above\n *        copyright notice, this list of conditions and the following\n *        disclaimer.\n *\n *      - Redistributions in binary form must reproduce the above\n *        copyright notice, this list of conditions and the following\n *        disclaimer in the documentation and/or other materials\n *        provided with the distribution.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS\n * BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN\n * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\n * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n */\n\n#include <netinet/in.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <unistd.h>\n#include <string.h>\n#include <limits.h>\n#include <arpa/inet.h>\n#include <sys/time.h>\n#include <semaphore.h>\n#include <sched.h>\n\n#include <infiniband/verbs.h>\n#include <infiniband/verbs_exp.h>\n\nenum {\n\tPINGPONG_RECV_WRID = 1,\n\tPINGPONG_SEND_WRID = 2,\n};\n\n/* Register a malloc buffer to create an MR */\nstatic struct ibv_mr *register_mr(struct ibv_pd *pd, size_t size,\n\t\t\t\t  int is_contig)\n{\n\tvoid *addr;\n\tint rc;\n\tstruct ibv_mr *mr;\n\tint mr_flags = IBV_ACCESS_LOCAL_WRITE | IBV_ACCESS_REMOTE_WRITE;\n\tint buf_flags = 0;\n\n\t/* Open a buffer */\n\tif (is_contig) {\n\t\t/* contiguous buffer with memalign */\n\t\tsize_t alignment = sysconf(_SC_PAGESIZE);\n\n\t\trc = posix_memalign(&addr, alignment, size);\n\t\tif (rc) {\n\t\t\tfprintf(stderr, \"Couldn't allocate memory - RC: %d\\n\", rc);\n\t\t\treturn NULL;\n\t\t}\n\t} else {\n\t\t/* anon buffer using malloc */\n\t\taddr = malloc(size);\n\t}\n\n\tmemset(addr, 0, size);\n\n\t/* Register the memory */\n\tmr = ibv_reg_mr(pd, addr, size, mr_flags);\n\tif (!mr) {\n\t\tfprintf(stderr, \"Couldn't register memory region %d\\n\", rc);\n\t\tfree(addr);\n\t\treturn NULL;\n\t}\n\n\tfprintf(stdout, \"Created MR: address = %p size = %zu handle = %u lkey = %u rkey = %u flags = %d is_contig: %d\\n\",\n\t\taddr, size, mr->handle, mr->lkey, mr->rkey, buf_flags, is_contig);\n\treturn mr;\n}\n\nstatic int deregister_mr(struct ibv_mr *mr)\n{\n\tvoid *addr = mr->addr;\n\tint rc;\n\n\trc = ibv_dereg_mr(mr);\n\tif (rc) {\n\t\tfprintf(stderr, \"Couldn't deregister memory region\\n\");\n\t\treturn rc;\n\t}\n\n\tfree(addr);\n\n\treturn 0;\n}\n\nint main(int argc, char *argv[])\n{\n\tstruct ibv_device **dev_list;\n\tstruct ibv_device *ib_dev;\n\tstruct ibv_context *ctx;\n\tint num_devices;\n\tsize_t i, j;\n\tint rc = 0;\n\tint num_mrs = 10;\n\tsize_t mr_size = (size_t)4UL*1024*1024*1024;\n\tsize_t mr_max_size = 0;\n\tint is_contig = 0;\n\tstruct ibv_pd *pd;\n\tstruct ibv_mr *mr;\n\tunsigned int *lkeys;\n\n\tif (argc > 1) {\n\t\tnum_mrs = atoi(argv[1]);\n\t\tif (num_mrs <= 0)\n\t\t\tnum_mrs = 1;\n\t}\n\n\tif (argc > 2) {\n\t\tmr_max_size = (size_t)strtol(argv[2], NULL, 0);\n\t\tif (mr_max_size <= 0)\n\t\t\tmr_max_size = 0;\n\t}\n\n\tif (argc > 3) {\n\t\tis_contig = atoi(argv[3]);\n\t\tif (is_contig != 0 && is_contig != 1)\n\t\t\tis_contig = 0;\n\t}\n\n\n\tif (mr_max_size) {\n\t\tmr_size = mr_max_size;\n\t}\n\n\tfprintf(stdout, \"Will create %d MRs with %s memory of size %zu Bytes\\n\",\n\t\tnum_mrs, is_contig ? \"contiguous\" : \"anon\", mr_size);\n\n\t/* Get the list of devices */\n\tdev_list = ibv_get_device_list(&num_devices);\n\tif (!dev_list || !num_devices) {\n\t\tfprintf(stderr, \"Couldn't get IB devices list\\n\");\n\t\trc = 1;\n\t\tgoto out;\n\t}\n\n\tfprintf(stdout, \"Found %d devices\\n\", num_devices);\n\n\t/* Use the first device */\n\tib_dev = dev_list[0];\n\n\t/* Get the device context */\n\tctx = ibv_open_device(ib_dev);\n\tif (!ctx) {\n\t\tfprintf(stderr, \"Couldn't get device context\\n\");\n\t\trc = 1;\n\t\tgoto out_devices;\n\t}\n\n\tfprintf(stdout, \"Context created\\n\");\n\n\t/* Allocate a protection domain */\n\tpd = ibv_alloc_pd(ctx);\n\tif (!pd) {\n\t\tfprintf(stderr, \"Couldn't allocate PD\\n\");\n\t\trc = 1;\n\t\tgoto out_device;\n\t}\n\n\tfprintf(stdout, \"PD created\\n\");\n\n\tlkeys = malloc(num_mrs * sizeof(*lkeys));\n\tif (!lkeys) {\n\t\tfprintf(stderr, \"Couldn't allocate memory for lkeys\\n\");\n\t\trc = 1;\n\t\tgoto out_pd;\n\t}\n\n\t/* Create num_mrs memory regions, one at a time */\n\tfor (i = 0; i < num_mrs; i++) {\n\t\tmr = register_mr(pd, mr_size, is_contig);\n\t\tif (!mr) {\n\t\t\tfprintf(stderr, \"Couldn't create MR %zu\\n\", i);\n\t\t\tbreak;\n\t\t}\n\n\t\tfprintf(stdout, \"  [%zu] Created MR: address = %p size = %zu handle = %u lkey = %u rkey = %u\\n\",\n\t\t\ti, mr->addr, mr_size, mr->handle, mr->lkey, mr->rkey);\n\n\t\tlkeys[i] = mr->lkey;\n\n\t\trc = deregister_mr(mr);\n\t\tif (rc) {\n\t\t\tfprintf(stderr, \"Couldn't destroy MR\\n\");\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tfree(lkeys);\n\nout_pd:\n\tibv_dealloc_pd(pd);\n\nout_device:\n\tibv_close_device(ctx);\n\nout_devices:\n\tibv_free_device_list(dev_list);\n\nout:\n\treturn rc;\n}\n\u0005End File\u0006# codes-ncc-4-odp/src/multithread.c\n/*\n * Copyright (c) 2005 Topspin Communications.  All rights reserved.\n * Copyright (c) 2006 Cisco Systems.  All rights reserved.\n *\n * This software is available to you under a choice of one of two\n * licenses.  You may choose to be licensed under the terms of the GNU\n * General Public License (GPL) Version 2, available from the file\n * COPYING in the main directory of this source tree, or the\n * OpenIB.org BSD license below:\n *\n *     Redistribution and use in source and binary forms, with or\n *     without modification, are permitted provided that the following\n *     conditions are met:\n *\n *      - Redistributions of source code must retain the above\n *        copyright notice, this list of conditions and the following\n *        disclaimer.\n *\n *      - Redistributions in binary form must reproduce the above\n *        copyright notice, this list of conditions and the following\n *        disclaimer in the documentation and/or other materials\n *        provided with the distribution.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS\n * BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN\n * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\n * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n */\n\n#if HAVE_CONFIG_H\n#  include <config.h>\n#endif /* HAVE_CONFIG_H */\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <unistd.h>\n#include <string.h>\n#include <limits.h>\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <sys/time.h>\n#include <netdb.h>\n#include <malloc.h>\n#include <getopt.h>\n#include <arpa/inet.h>\n#include <inttypes.h>\n#include <signal.h>\n#include <infiniband/verbs.h>\n#include <endian.h>\n#include <byteswap.h>\n#include <pthread.h>\n#include <sys/mman.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <infiniband/driver.h>\n#include <math.h>\n\n#define MAX_INLINE_SIZE\t256\n#define DEFAULT_NUMA_NODE 1\n#define CPUSET_SIZE     128\n\nenum ibv_mtu mtu = IBV_MTU_1024;\nenum ibv_mtu effective_mtu;\nstatic int\tpage_size;\n\n#define MICROSEC\t   1000000\n#define MAX_QUEUEPAIR_NUM 256\n#define\tMILIISECOND   1000\n#define KILO          1024\n#define MEGA          (KILO*KILO)\n#define GIGA          (MEGA*KILO)\n\nint is_server;\n\n#if __BYTE_ORDER == __LITTLE_ENDIAN\ninline uint64_t htonll(uint64_t x) { return bswap_64(x); }\ninline uint64_t ntohll(uint64_t x) { return bswap_64(x); }\n#elif __BYTE_ORDER == __BIG_ENDIAN\ninline uint64_t htonll(uint64_t x) { return x; }\ninline uint64_t ntohll(uint64_t x) { return x; }\n#else\n#error __BYTE_ORDER is neither __LITTLE_ENDIAN nor __BIG_ENDIAN\n#endif\n\n\n#define LOG(f, ...) printf(\"[%s] \"f, __func__, ##__VA_ARGS__)\n\nint shared_int_create(shared_int *obj);\nint shared_int_destroy(shared_int *obj);\nint shared_int_reset(shared_int *obj);\nint shared_int_set(shared_int *obj, int val);\nint shared_int_get(shared_int *obj);\nint shared_int_add(shared_int *obj, int delta);\nint shared_int_get_and_add(shared_int *obj, int delta);\nint shared_int_barrier(shared_int *obj, int val);\nint shared_int_wait_neq(shared_int *obj, int val);\nint shared_int_wait_eq(shared_int *obj, int val);\nint shared_int_wait_geq(shared_int *obj, int val);\n\n//For CPU binding\nstatic void setCPU(int cpu_idx) {\n\tint status;\n\tcpu_set_t my_set;\n\tCPU_ZERO(&my_set);\n\tCPU_SET(cpu_idx, &my_set);\n\tstatus = sched_setaffinity(0, sizeof(cpu_set_t), &my_set);\n\tif (status != 0) {\n\t\tperror(\"sched_setaffinity error\");\n\t}\n}\n\nstatic void set_cpu_socket(int socket_idx) {\n\tint status;\n\tint cpus_per_socket = sysconf(_SC_NPROCESSORS_ONLN) / 2;\n\tcpu_set_t my_set;\n\tCPU_ZERO(&my_set);\n\tif (socket_idx == 0) {\n\t\tfor (int i = 0; i < cpus_per_socket; i++) {\n\t\t\tCPU_SET(i, &my_set);\n\t\t}\n\t} else {\n\t\tfor (int i = cpus_per_socket; i < cpus_per_socket * 2; i++) {\n\t\t\tCPU_SET(i, &my_set);\n\t\t}\n\t}\n\n\tstatus = sched_setaffinity(0, sizeof(cpu_set_t), &my_set);\n\tif (status != 0) {\n\t\tperror(\"sched_setaffinity error\");\n\t}\n\n}\n\n//\n// Common function\n//\n\n// Utilities\n\n// For threads\ntypedef struct {\n\tpthread_mutex_t mutex;\n\tpthread_cond_t  cond;\n\tint \t\t\tval;\n} shared_int;\n\n// Parse user CLI args\nstruct config_t {\n\tconst char\t\t*dev_name;\n\tchar\t\t\tserver_name[MAX_NAME_LEN];\n\tu_int32_t\t\ttcp_port;\n\tu_int32_t\t\tib_port;\n\tint\t\t\tnuma_node;\n\tu_int32_t\t\tqp_timeout;\n\tu_int32_t\t\tqp_retry_cnt;\n\tu_int32_t\t\tqp_rnr_retry;\n\tenum ibv_mtu\t\tmtu;\n\tint\t\t\tsl;\n\tint\t\t\tgidx;\n\tint\t\t\tsgid_idx;\n\n\t// client\n\tint \t\tqp_num; // used to identify the qp\n\t\n};\n\n// IB/ROCE Resources\nstruct resource_t {\n\tstruct ibv_device_attr\tdevice_attr;\n\tstruct ibv_port_attr\tport_attr;\n\tstruct ibv_context\t*ib_ctx;\n\tstruct ibv_pd\t\t*pd;\n\tstruct ibv_cq\t\t*cq;\n\tstruct ibv_qp\t\t*qp;\n\tstruct ibv_mr\t\t*mr;\n\tstruct ibv_mr\t\t*notify_mr;\n\tstruct ibv_mr\t\t*all_mr;\n\tstruct ibv_mr\t\t*resize_mr;\n\tstruct ibv_port_attr\t*port_info;\n\tvoid\t\t\t*ib_buf;\n\tint\t\t\tsock;\n\tint \t\tid;\n\tint\t\t\tsize;\n\tint\t\t\tsend_flags;\n\tint\t\t\trx_depth;\n\tint\t\t\tpending;\n\tstruct ibv_send_wr\twr;\n\tstruct ibv_sge\t\tlist;\n\tunion ibv_gid\t\tmy_gid;\n\tchar\t\t\t*mmap_buf;\n\tint \t\tmr_all_size;\n\tint \t\tmr_notify_size;\n};\n\nstruct pingpong_dest {\n\tint\t\tlid;\n\tint\t\tqpn;\n\tint\t\tpsn;\n\tunsigned\trkey;\n\tunsigned\tvaddr;\n\tunion ibv_gid\tgid;\n};\n\n\n// Function Implementations\nstatic int sock_connect(const char *servername, int port) {\n\tstruct addrinfo *res, *t;\n\tstruct addrinfo hints = {\n\t\t.ai_family   = AF_INET,\n\t\t.ai_socktype = SOCK_STREAM\n\t};\n\tchar *service;\n\tint n;\n\tint sockfd = -1;\n\tint err;\n\n\tif (asprintf(&service, \"%d\", port) < 0)\n\t\treturn -1;\n\n\terr = getaddrinfo(servername, service, &hints, &res);\n\n\tif (err < 0) {\n\t\tfprintf(stderr, \"%s for %s:%d\\n\", gai_strerror(err), servername, port);\n\t\tfree(service);\n\t\treturn -1;\n\t}\n\n\tfor (t = res; t; t = t->ai_next) {\n\t\tsockfd = socket(t->ai_family, t->ai_socktype, t->ai_protocol);\n\t\tif (sockfd >= 0) {\n\t\t\tn = 1;\n\n\t\t\tsetsockopt(sockfd, SOL_SOCKET, SO_REUSEADDR, &n, sizeof n);\n\n\t\t\tif (!connect(sockfd, t->ai_addr, t->ai_addrlen))\n\t\t\t\tbreak;\n\t\t\tclose(sockfd);\n\t\t\tsockfd = -1;\n\t\t}\n\t}\n\n\tfreeaddrinfo(res);\n\tfree(service);\n\n\tif (sockfd < 0) {\n\t\tfprintf(stderr, \"Couldn't connect to %s:%d\\n\", servername, port);\n\t\treturn -1;\n\t}\n\n\treturn sockfd;\n}\n\nstatic int sock_bind(int port) {\n\tstruct sockaddr_in addr;\n\tint sfd;\n\tint flags;\n\tint yes = 1;\n\n\tsfd = socket(AF_INET, SOCK_STREAM, 0);\n\tif (sfd == -1) {\n\t\tperror(\"socket\");\n\t\treturn -1;\n\t}\n\n\tif (setsockopt(sfd, SOL_SOCKET, SO_REUSEADDR, &yes, sizeof(yes)) == -1) {\n\t\tperror(\"setsockopt\");\n\t\treturn -1;\n\t}\n\n\tmemset(&addr, 0, sizeof addr);\n\taddr.sin_family = AF_INET;\n\taddr.sin_port = htons(port);\n\taddr.sin_addr.s_addr = htonl(INADDR_ANY);\n\tif (bind(sfd, (struct sockaddr *)&addr, sizeof addr) == -1) {\n\t\tperror(\"bind\");\n\t\treturn -1;\n\t}\n\n\tflags = fcntl(sfd, F_GETFL);\n\tif (flags == -1) {\n\t\tperror(\"fcntl F_GETFL\");\n\t\treturn -1;\n\t}\n\n\tif (fcntl(sfd, F_SETFL, flags | O_NONBLOCK) == -1) {\n\t\tperror(\"fcntl F_SETFL O_NONBLOCK\");\n\t\treturn -1;\n\t}\n\n\tlisten(sfd, 5);\n\n\treturn sfd;\n}\n\nstatic int sock_accept(int sockfd) {\n\tstruct sockaddr_in addr;\n\tsocklen_t len = sizeof addr;\n\tint sfd;\n\n\tsfd = accept(sockfd, (struct sockaddr *)&addr, &len);\n\tif (sfd == -1) {\n\t\tperror(\"accept\");\n\t\treturn -1;\n\t}\n\n\treturn sfd;\n}\n\nstatic int sock_sync_data(int sock, int xfer_size, char *local_data, char *remote_data) {\n\tint rc;\n\tint read_bytes = 0;\n\tint total_read_bytes = 0;\n\n\trc = write(sock, local_data, xfer_size);\n\tif (rc < xfer_size)\n\t\tfprintf(stderr, \"Failed writing data during sock_sync_data, total bytes %d\\n\", rc);\n\telse\n\t\trc = 0;\n\n\twhile (!rc && total_read_bytes < xfer_size) {\n\t\tread_bytes = read(sock, remote_data + total_read_bytes, xfer_size - total_read_bytes);\n\t\tif (read_bytes > 0) {\n\t\t\ttotal_read_bytes += read_bytes;\n\t\t} else {\n\t\t\trc = read_bytes;\n\t\t}\n\t}\n\n\treturn rc;\n}\n\nstatic void wire_gid_to_gid(const char *wgid, union ibv_gid *gid) {\n\tchar tmp[9];\n\tuint32_t v32;\n\tint i;\n\n\tfor (tmp[8] = 0, i = 0; i < 4; ++i) {\n\t\tmemcpy(tmp, wgid + i * 8, 8);\n\t\tsscanf(tmp, \"%x\", &v32);\n\t\t*(uint32_t *)(&gid->raw[i * 4]) = ntohl(v32);\n\t}\n}\n\nstatic void gid_to_wire_gid(const union ibv_gid *gid, char wgid[]) {\n\tint i;\n\n\tfor (i = 0; i < 4; ++i)\n\t\tsprintf(&wgid[i * 8], \"%08x\", htonl(*(uint32_t *)(gid->raw + i * 4)));\n}\n\n// IB Init\nstatic int init_env(struct resource_t *res) {\n\tstruct ibv_device **dev_list;\n\tint i;\n\tint num_devices;\n\t\n\tif (!res) {\n\t\tfprintf(stderr, \"Init Environment with empty resource.\\n\");\n\t\treturn 1;\n\t}\n\n\t// Get IB device list\n\tdev_list = ibv_get_device_list(&num_devices);\n\tif (!dev_list) {\n\t\tfprintf(stderr, \"Failed to get IB devices list.\\n\");\n\t\treturn 1;\n\t}\n\n\t// Check if the requested device exists\n\tfor (i = 0; i < num_devices; i ++) {\n\t\tif (!dev_list[i]) {\n\t\t\tfprintf(stderr, \"Device list is empty.\\n\");\n\t\t\treturn 1;\n\t\t}\n\t\tprintf(\"Get Device[%d]: %s\\n\", i, ibv_get_device_name(dev_list[i]));\n\t}\n\n\tres->ib_ctx = ibv_open_device(dev_list[0]);\n\tif (!res->ib_ctx) {\n\t\tfprintf(stderr, \"Failed to open device %s\\n\", ibv_get_device_name(dev_list[0]));\n\t\treturn 1;\n\t}\n\n\tibv_free_device_list(dev_list);\n\tdev_list = NULL;\n\n\tif (ibv_query_device(res->ib_ctx, &res->device_attr)) {\n\t\tfprintf(stderr, \"Failed to query device props\");\n\t\treturn 1;\n\t}\n\tprintf(\"max_qp=%d, max_cq=%d, max_mr=%d\\n\",\n\t       res->device_attr.max_qp, res->device_attr.max_cq, res->device_attr.max_mr);\n\n\n\treturn 0;\n}\n\nstatic int init_resource(struct resource_t *res, struct config_t *cfg) {\n\t// Verify port number\n\tif (cfg->ib_port > 0) {\n\t\tif (cfg->ib_port > res->device_attr.phys_port_cnt) {\n\t\t\tfprintf(stderr, \"Invalid port number %d. It can be 1~%d\\n\",\n\t\t\t\tcfg->ib_port, res->device_attr.phys_port_cnt);\n\t\t\treturn 1;\n\t\t}\n\t} else {\n\t\tfprintf(stderr, \"Missing IB port configuration\\n\");\n\t\treturn 1;\n\t}\n\tres->id = cfg->qp_num;\n\tprintf(\"Create QP with ID %d\\n\", res->id);\n\t\n\t// Verify port attribute\n\tif (ibv_query_port(res->ib_ctx, cfg->ib_port, &res->port_attr)) {\n\t\tfprintf(stderr, \"Failed to query port attribute\\n\");\n\t\treturn 1;\n\t}\n\n\t// Create PD\n\tres->pd = ibv_alloc_pd(res->ib_ctx);\n\tif (!res->pd) {\n\t\tfprintf(stderr, \"Failed to allocate PD\\n\");\n\t\treturn 1;\n\t}\n\n\tres->rx_depth = 500;\n\t\n\tstruct ibv_cq_init_attr_ex cq_attr = {\n\t\t.cqe = 2048,\n\t\t.cq_context = NULL,\n\t\t.channel = NULL,\n\t\t.comp_vector = 0\n\t};\n\t\n\tres->cq = ibv_create_cq(res->ib_ctx, cq_attr.cqe, NULL, NULL, 0);\n\tif (!res->cq) {\n\t\tfprintf(stderr, \"Failed to create CQ\\n\");\n\t\treturn 1;\n\t}\n\n\treturn 0;\n}\n\n\nstatic struct ibv_mr *create_one_mr(struct ibv_pd *pd, void *addr, size_t length,\n\t\t\t\t    int access, size_t buf_size, int lkey, int rkey) {\n\tstruct ibv_mr *mr;\n\tmr = ibv_reg_mr(pd, addr, length, access);\n\tif (!mr) {\n\t\tfprintf(stderr, \"Failed to register MR\\n\");\n\t\treturn NULL;\n\t}\n\tprintf(\"MR was registered with addr=%p, lkey=0x%x, rkey=0x%x, flags=0x%x\\n\",\n\t       addr, mr->lkey, mr->rkey, mr->handle);\n\treturn mr;\n}\n\nstatic struct ibv_mr *create_mr(struct ibv_pd *pd, void *addr, size_t length,\n\t\t\t\tint access, size_t buf_size, int lkey, int rkey) {\n\tvoid* cpu_addr = malloc(buf_size);\n\tif (!cpu_addr) {\n\t\tfprintf(stderr, \"Failed to allocate memory\\n\");\n\t\treturn NULL;\n\t}\n\tmemset(cpu_addr, 0, buf_size);\n\tstruct ibv_mr *mr;\n\tmr = ibv_reg_mr(pd, cpu_addr, buf_size, access);\n\tif (!mr) {\n\t\tfprintf(stderr, \"Failed to register MR\\n\");\n\t\treturn NULL;\n\t}\n\tprintf(\"MR was registered with addr=%p, lkey=0x%x, rkey=0x%x, flags=0x%x\\n\",\n\t       cpu_addr, mr->lkey, mr->rkey, mr->handle);\n\treturn mr;\n}\n\nstatic struct ibv_mr *create_mr_notify(struct ibv_pd *pd, void *addr, size_t length,\n\t\t\t\t       int access, size_t buf_size, int lkey, int rkey) {\n\tvoid* cpu_addr = malloc(buf_size);\n\tif (!cpu_addr) {\n\t\tfprintf(stderr, \"Failed to allocate memory\\n\");\n\t\treturn NULL;\n\t}\n\tmemset(cpu_addr, 0, buf_size);\n\tint notify_access = IBV_ACCESS_LOCAL_WRITE | IBV_ACCESS_REMOTE_WRITE | IBV_ACCESS_REMOTE_READ;\n\tstruct ibv_mr *mr;\n\tmr = ibv_reg_mr(pd, cpu_addr, buf_size, notify_access);\n\tif (!mr) {\n\t\tfprintf(stderr, \"Failed to register MR\\n\");\n\t\treturn NULL;\n\t}\n\tprintf(\"MR was registered with addr=%p, lkey=0x%x, rkey=0x%x, flags=0x%x\\n\",\n\t       cpu_addr, mr->lkey, mr->rkey, mr->handle);\n\treturn mr;\n}\n\nstatic struct ibv_mr *create_mr_all(struct ibv_pd *pd, void *addr, size_t length,\n\t\t\t\t    int access, size_t buf_size, int lkey, int rkey) {\n\tvoid* cpu_addr = malloc(buf_size);\n\tif (!cpu_addr) {\n\t\tfprintf(stderr, \"Failed to allocate memory\\n\");\n\t\treturn NULL;\n\t}\n\tmemset(cpu_addr, 0, buf_size);\n\tstruct ibv_mr *mr;\n\tmr = ibv_reg_mr(pd, cpu_addr, buf_size, access);\n\tif (!mr) {\n\t\tfprintf(stderr, \"Failed to register MR\\n\");\n\t\treturn NULL;\n\t}\n\tprintf(\"MR was registered with addr=%p, lkey=0x%x, rkey=0x%x, flags=0x%x\\n\",\n\t       cpu_addr, mr->lkey, mr->rkey, mr->handle);\n\treturn mr;\n}\n\nstatic struct ibv_mr *notify_mr(struct ibv_pd *pd, void *addr, size_t length,\n\t\t\t\tint access, size_t buf_size, int lkey, int rkey) {\n\tint notify_access = IBV_ACCESS_LOCAL_WRITE | IBV_ACCESS_REMOTE_WRITE | IBV_ACCESS_REMOTE_READ;\n\tstruct ibv_mr *mr;\n\tmr = ibv_reg_mr(pd, addr, length, notify_access);\n\tif (!mr) {\n\t\tfprintf(stderr, \"Failed to register MR\\n\");\n\t\treturn NULL;\n\t}\n\tprintf(\"MR was registered with addr=%p, lkey=0x%x, rkey=0x%x, flags=0x%x\\n\",\n\t       addr, mr->lkey, mr->rkey, mr->handle);\n\treturn mr;\n}\n\nstatic struct ibv_mr *resize_mr(struct ibv_pd *pd, void *addr, size_t length,\n\t\t\t\tint access, size_t buf_size, int lkey, int rkey) {\n\tstruct ibv_mr *mr;\n\tmr = ibv_reg_mr(pd, addr, length, access);\n\tif (!mr) {\n\t\tfprintf(stderr, \"Failed to register MR\\n\");\n\t\treturn NULL;\n\t}\n\tprintf(\"MR was registered with addr=%p, lkey=0x%x, rkey=0x%x, flags=0x%x\\n\",\n\t       addr, mr->lkey, mr->rkey, mr->handle);\n\treturn mr;\n}\n\nstatic int create_mr_all_for_alloc(struct resource_t* res, struct config_t* cfg, int size) {\n\tres->mr_all_size = size;\n\tint access = IBV_ACCESS_LOCAL_WRITE | IBV_ACCESS_REMOTE_WRITE | IBV_ACCESS_REMOTE_READ;\n\tres->all_mr = create_mr_all(res->pd, NULL, 0, access, size, 0, 0);\n\tif (!res->all_mr) {\n\t\tfprintf(stderr, \"Failed to create mr for alloc\\n\");\n\t\treturn 1;\n\t}\n\treturn 0;\n}\n\nstatic int create_mr_notify_for_alloc(struct resource_t* res, struct config_t* cfg, int size) {\n\tres->mr_notify_size = size;\n\tint access = IBV_ACCESS_LOCAL_WRITE | IBV_ACCESS_REMOTE_WRITE | IBV_ACCESS_REMOTE_READ;\n\tres->notify_mr = create_mr_notify(res->pd, NULL, 0, access, size, 0, 0);\n\tif (!res->notify_mr) {\n\t\tfprintf(stderr, \"Failed to create mr for alloc\\n\");\n\t\treturn 1;\n\t}\n\treturn 0;\n}\n\nstatic void alloc_hugepage(struct resource_t* res, struct config_t* cfg, int size) {\n\tif (res->mmap_buf != NULL) {\n\t\tmunmap(res->mmap_buf, res->size);\n\t}\n\t\n\tpage_size = sysconf(_SC_PAGESIZE);\n\tint huge_page_size = 1 << 30; // 1GB\n\t\n\tsize = (size + huge_page_size - 1) & ~(huge_page_size - 1);\n\t\n\tres->size = size;\n\n\t//int type = 21; //MAP_HUGETLB | MAP_HUGE_1GB;\n\tint fd = memfd_create(\"buffer\", 0);\n\tif (fd < 0) {\n\t\tfprintf(stderr, \"memfd_create failed\\n\");\n\t\treturn;\n\t}\n\t\n\tif (ftruncate(fd, size) < 0) {\n\t\tfprintf(stderr, \"ftruncate failed\\n\");\n\t\treturn;\n\t}\n\t\n\tvoid* addr = mmap(NULL, size, PROT_READ | PROT_WRITE, MAP_SHARED, fd, 0);\n\tif (addr == MAP_FAILED) {\n\t\tfprintf(stderr, \"mmap failed\\n\");\n\t\treturn;\n\t}\n\t\n\tclose(fd);\n\n\tmemset(addr, 0, size);\n\t\n\tres->mmap_buf = addr;\n\tLOG(\"Allocated %d bytes at %p\\n\", size, addr);\n}\n\nstatic int create_qp(struct resource_t *res, struct config_t *cfg) {\n\tprintf(\"Creating QP %d\\n\", res->id);\n\t\n\tstruct ibv_qp_init_attr qp_init_attr = {\n\t\t.send_cq = res->cq,\n\t\t.recv_cq = res->cq,\n\t\t.cap = {\n\t\t\t.max_send_wr = 2048,\n\t\t\t.max_recv_wr = 2048,\n\t\t\t.max_send_sge = 1,\n\t\t\t.max_recv_sge = 1\n\t\t},\n\t\t.qp_type = IBV_QPT_RC,\n\t\t.sq_sig_all = 0\n\t};\n\n\tres->qp = ibv_create_qp(res->pd, &qp_init_attr);\n\tif (!res->qp) {\n\t\tfprintf(stderr, \"Failed to create QP\\n\");\n\t\treturn 1;\n\t}\n\tprintf(\"QP was created, QP number=0x%x\\n\", res->qp->qp_num);\n\n\treturn 0;\n}\n\nstatic int modify_qp_to_init(struct resource_t *res, struct config_t* cfg) {\n\tstruct ibv_qp_attr attr = {\n\t\t.qp_state = IBV_QPS_INIT,\n\t\t.pkey_index = 0,\n\t\t.port_num = cfg->ib_port,\n\t\t.qp_access_flags = IBV_ACCESS_LOCAL_WRITE | IBV_ACCESS_REMOTE_READ | IBV_ACCESS_REMOTE_WRITE\n\t};\n\n\tint flags = IBV_QP_STATE | IBV_QP_PKEY_INDEX | IBV_QP_PORT | IBV_QP_ACCESS_FLAGS;\n\tint rc = ibv_modify_qp(res->qp, &attr, flags);\n\tif (rc) {\n\t\tfprintf(stderr, \"Failed to modify QP to INIT\\n\");\n\t\treturn 1;\n\t}\n\treturn 0;\n}\n\nstatic int modify_qp_to_rtr(struct resource_t *res, struct config_t* cfg, uint32_t remote_qpn, uint16_t dlid, uint8_t *dgid) {\n\tstruct ibv_qp_attr attr = {\n\t\t.qp_state = IBV_QPS_RTR,\n\t\t.path_mtu = cfg->mtu,\n\t\t.dest_qp_num = remote_qpn,\n\t\t.rq_psn = 0,\n\t\t.max_dest_rd_atomic = 1,\n\t\t.min_rnr_timer = 0x12,\n\t\t.ah_attr = {\n\t\t\t.is_global = 0,\n\t\t\t.dlid = dlid,\n\t\t\t.sl = cfg->sl,\n\t\t\t.src_path_bits = 0,\n\t\t\t.port_num = cfg->ib_port\n\t\t}\n\t};\n\n\tif (cfg->gidx >= 0) {\n\t\tattr.ah_attr.is_global = 1;\n\t\tattr.ah_attr.port_num = 1;\n\t\tmemcpy(&attr.ah_attr.grh.dgid, dgid, 16);\n\t\tattr.ah_attr.grh.flow_label = 0;\n\t\tattr.ah_attr.grh.hop_limit = 1;\n\t\tattr.ah_attr.grh.sgid_index = cfg->sgid_idx;\n\t\tattr.ah_attr.grh.traffic_class = 0;\n\t}\n\n\tint flags = IBV_QP_STATE | IBV_QP_AV | IBV_QP_PATH_MTU | IBV_QP_DEST_QPN | IBV_QP_RQ_PSN | IBV_QP_MAX_DEST_RD_ATOMIC | IBV_QP_MIN_RNR_TIMER;\n\tint rc = ibv_modify_qp(res->qp, &attr, flags);\n\tif (rc) {\n\t\tfprintf(stderr, \"failed to modify QP to RTR\\n\");\n\t\treturn 1;\n\t}\n\n\treturn 0;\n}\n\nstatic int modify_qp_to_rts(struct resource_t *res, struct config_t* cfg) {\n\tstruct ibv_qp_attr attr = {\n\t\t.qp_state = IBV_QPS_RTS,\n\t\t.timeout = cfg->qp_timeout,\n\t\t.retry_cnt = cfg->qp_retry_cnt,\n\t\t.rnr_retry = cfg->qp_rnr_retry,\n\t\t.sq_psn = 0,\n\t\t.max_rd_atomic = 1\n\t};\n\n\tint flags = IBV_QP_STATE | IBV_QP_TIMEOUT | IBV_QP_RETRY_CNT | IBV_QP_RNR_RETRY | IBV_QP_SQ_PSN | IBV_QP_MAX_QP_RD_ATOMIC;\n\tint rc = ibv_modify_qp(res->qp, &attr, flags);\n\tif (rc) {\n\t\tfprintf(stderr, \"failed to modify QP to RTS\\n\");\n\t\treturn 1;\n\t}\n\n\treturn 0;\n}\n\nstatic int connect_qp(struct resource_t *res, struct config_t *cfg, struct pingpong_dest *dest) {\n\tstruct pingpong_dest my_dest;\n\tmy_dest.lid = res->port_attr.lid;\n\tmy_dest.qpn = res->qp->qp_num;\n\tmy_dest.psn = lrand48() & 0xffffff;\n\tif (cfg->gidx >= 0) {\n\t\tif (ibv_query_gid(res->ib_ctx, cfg->ib_port, cfg->gidx, &my_dest.gid)) {\n\t\t\tfprintf(stderr, \"can't read sgid of index %d\\n\", cfg->gidx);\n\t\t\treturn 1;\n\t\t}\n\t} else {\n\t\tmemset(&my_dest.gid, 0, sizeof my_dest.gid);\n\t}\n\tmy_dest.rkey = res->mr->rkey;\n\tmy_dest.vaddr = (uintptr_t)res->mr->addr;\n\t\n\tif (sock_sync_data(res->sock, sizeof(struct pingpong_dest), (char *)&my_dest, (char *)dest)) {\n\t\tfprintf(stderr, \"failed to exchange connection data between sides\\n\");\n\t\treturn 1;\n\t}\n\n\tif (modify_qp_to_init(res, cfg)) {\n\t\tfprintf(stderr, \"change QP state to INIT failed\\n\");\n\t\treturn 1;\n\t}\n\n\t// Let the client post SR to recv server's msg\n\tif (!is_server) {\n\t\tif (post_recv(res, 0)) {\n\t\t\tfprintf(stderr, \"failed to post RR\\n\");\n\t\t\treturn 1;\n\t\t}\n\t}\n\n\t\n\tif (cfg->gidx >= 0) {\n\t\tuint8_t *p = dest->gid.raw;\n\t\tfprintf(stdout, \"Remote GID = %02x:%02x:%02x:%02x:%02x:%02x:%02x:%02x:%02x:%02x:%02x:%02x:%02x:%02x:%02x:%02x\\n\",\n\t\t\tp[0], p[1], p[2], p[3], p[4], p[5], p[6], p[7], p[8], p[9], p[10], p[11], p[12], p[13], p[14], p[15]);\n\t}\n\n\t/* modify the QP to RTR */\n\tif (modify_qp_to_rtr(res, cfg, dest->qpn, dest->lid, dest->gid.raw)) {\n\t\tfprintf(stderr, \"Failed to modify QP state to RTR\\n\");\n\t\treturn 1;\n\t}\n\tfprintf(stderr, \"Modified QP state to RTR\\n\");\n\t\n\t/* modify the QP to RTS */\n\tif (modify_qp_to_rts(res, cfg)) {\n\t\tfprintf(stderr, \"Failed to modify QP state to RTS\\n\");\n\t\treturn 1;\n\t}\n\tfprintf(stderr, \"QP state was change to RTS\\n\");\n\n\t// Let the server do post SR\n\tif (is_server) {\n\t\tif (post_recv(res, 0)) {\n\t\t\tfprintf(stderr, \"failed to post RR\\n\");\n\t\t\treturn 1;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int connect_qp_notify(struct resource_t *res, struct resource_t *res_notify, struct config_t *cfg, struct pingpong_dest *dest) {\n\tstruct pingpong_dest my_dest;\n\tmy_dest.lid = res->port_attr.lid;\n\tmy_dest.qpn = res->qp->qp_num;\n\tmy_dest.psn = lrand48() & 0xffffff;\n\tif (cfg->gidx >= 0) {\n\t\tif (ibv_query_gid(res->ib_ctx, cfg->ib_port, cfg->gidx, &my_dest.gid)) {\n\t\t\tfprintf(stderr, \"can't read sgid of index %d\\n\", cfg->gidx);\n\t\t\treturn 1;\n\t\t}\n\t} else {\n\t\tmemset(&my_dest.gid, 0, sizeof my_dest.gid);\n\t}\n\tmy_dest.rkey = res_notify->notify_mr->rkey;\n\tmy_dest.vaddr = (uintptr_t)res_notify->notify_mr->addr;\n\t\n\tif (sock_sync_data(res->sock, sizeof(struct pingpong_dest), (char *)&my_dest, (char *)dest)) {\n\t\tfprintf(stderr, \"failed to exchange connection data between sides\\n\");\n\t\treturn 1;\n\t}\n\n\tif (modify_qp_to_init(res, cfg)) {\n\t\tfprintf(stderr, \"change QP state to INIT failed\\n\");\n\t\treturn 1;\n\t}\n\n\t// Let the client post SR to recv server's msg\n\tif (!is_server) {\n\t\tif (post_recv(res, 0)) {\n\t\t\tfprintf(stderr, \"failed to post RR\\n\");\n\t\t\treturn 1;\n\t\t}\n\t}\n\n\t\n\tif (cfg->gidx >= 0) {\n\t\tuint8_t *p = dest->gid.raw;\n\t\tfprintf(stdout, \"Remote GID = %02x:%02x:%02x:%02x:%02x:%02x:%02x:%02x:%02x:%02x:%02x:%02x:%02x:%02x:%02x:%02x\\n\",\n\t\t\tp[0], p[1], p[2], p[3], p[4], p[5], p[6], p[7], p[8], p[9], p[10], p[11], p[12], p[13], p[14], p[15]);\n\t}\n\n\t/* modify the QP to RTR */\n\tif (modify_qp_to_rtr(res, cfg, dest->qpn, dest->lid, dest->gid.raw)) {\n\t\tfprintf(stderr, \"Failed to modify QP state to RTR\\n\");\n\t\treturn 1;\n\t}\n\tfprintf(stderr, \"Modified QP state to RTR\\n\");\n\t\n\t/* modify the QP to RTS */\n\tif (modify_qp_to_rts(res, cfg)) {\n\t\tfprintf(stderr, \"Failed to modify QP state to RTS\\n\");\n\t\treturn 1;\n\t}\n\tfprintf(stderr, \"QP state was change to RTS\\n\");\n\n\t// Let the server do post SR\n\tif (is_server) {\n\t\tif (post_recv(res, 0)) {\n\t\t\tfprintf(stderr, \"failed to post RR\\n\");\n\t\t\treturn 1;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int connect_qp_all(struct resource_t *res, struct resource_t *res_all, struct config_t *cfg, struct pingpong_dest *dest) {\n\tstruct pingpong_dest my_dest;\n\tmy_dest.lid = res->port_attr.lid;\n\tmy_dest.qpn = res->qp->qp_num;\n\tmy_dest.psn = lrand48() & 0xffffff;\n\tif (cfg->gidx >= 0) {\n\t\tif (ibv_query_gid(res->ib_ctx, cfg->ib_port, cfg->gidx, &my_dest.gid)) {\n\t\t\tfprintf(stderr, \"can't read sgid of index %d\\n\", cfg->gidx);\n\t\t\treturn 1;\n\t\t}\n\t} else {\n\t\tmemset(&my_dest.gid, 0, sizeof my_dest.gid);\n\t}\n\tmy_dest.rkey = res_all->all_mr->rkey;\n\tmy_dest.vaddr = (uintptr_t)res_all->all_mr->addr;\n\t\n\tif (sock_sync_data(res->sock, sizeof(struct pingpong_dest), (char *)&my_dest, (char *)dest)) {\n\t\tfprintf(stderr, \"failed to exchange connection data between sides\\n\");\n\t\treturn 1;\n\t}\n\n\tif (modify_qp_to_init(res, cfg)) {\n\t\tfprintf(stderr, \"change QP state to INIT failed\\n\");\n\t\treturn 1;\n\t}\n\n\t// Let the client post SR to recv server's msg\n\tif (!is_server) {\n\t\tif (post_recv(res, 0)) {\n\t\t\tfprintf(stderr, \"failed to post RR\\n\");\n\t\t\treturn 1;\n\t\t}\n\t}\n\n\t\n\tif (cfg->gidx >= 0) {\n\t\tuint8_t *p = dest->gid.raw;\n\t\tfprintf(stdout, \"Remote GID = %02x:%02x:%02x:%02x:%02x:%02x:%02x:%02x:%02x:%02x:%02x:%02x:%02x:%02x:%02x:%02x\\n\",\n\t\t\tp[0], p[1], p[2], p[3], p[4], p[5], p[6], p[7], p[8], p[9], p[10], p[11], p[12], p[13], p[14], p[15]);\n\t}\n\n\t/* modify the QP to RTR */\n\tif (modify_qp_to_rtr(res, cfg, dest->qpn, dest->lid, dest->gid.raw)) {\n\t\tfprintf(stderr, \"Failed to modify QP state to RTR\\n\");\n\t\treturn 1;\n\t}\n\tfprintf(stderr, \"Modified QP state to RTR\\n\");\n\t\n\t/* modify the QP to RTS */\n\tif (modify_qp_to_rts(res, cfg)) {\n\t\tfprintf(stderr, \"Failed to modify QP state to RTS\\n\");\n\t\treturn 1;\n\t}\n\tfprintf(stderr, \"QP state was change to RTS\\n\");\n\n\t// Let the server do post SR\n\tif (is_server) {\n\t\tif (post_recv(res, 0)) {\n\t\t\tfprintf(stderr, \"failed to post RR\\n\");\n\t\t\treturn 1;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int connect_qp_resize(struct resource_t *res, struct resource_t *res_resize, struct config_t *cfg, struct pingpong_dest *dest) {\n\tstruct pingpong_dest my_dest;\n\tmy_dest.lid = res->port_attr.lid;\n\tmy_dest.qpn = res->qp->qp_num;\n\tmy_dest.psn = lrand48() & 0xffffff;\n\tif (cfg->gidx >= 0) {\n\t\tif (ibv_query_gid(res->ib_ctx, cfg->ib_port, cfg->gidx, &my_dest.gid)) {\n\t\t\tfprintf(stderr, \"can't read sgid of index %d\\n\", cfg->gidx);\n\t\t\treturn 1;\n\t\t}\n\t} else {\n\t\tmemset(&my_dest.gid, 0, sizeof my_dest.gid);\n\t}\n\tmy_dest.rkey = res_resize->resize_mr->rkey;\n\tmy_dest.vaddr = (uintptr_t)res_resize->resize_mr->addr;\n\t\n\tif (sock_sync_data(res->sock, sizeof(struct pingpong_dest), (char *)&my_dest, (char *)dest)) {\n\t\tfprintf(stderr, \"failed to exchange connection data between sides\\n\");\n\t\treturn 1;\n\t}\n\n\tif (modify_qp_to_init(res, cfg)) {\n\t\tfprintf(stderr, \"change QP state to INIT failed\\n\");\n\t\treturn 1;\n\t}\n\n\t// Let the client post SR to recv server's msg\n\tif (!is_server) {\n\t\tif (post_recv(res, 0)) {\n\t\t\tfprintf(stderr, \"failed to post RR\\n\");\n\t\t\treturn 1;\n\t\t}\n\t}\n\n\t\n\tif (cfg->gidx >= 0) {\n\t\tuint8_t *p = dest->gid.raw;\n\t\tfprintf(stdout, \"Remote GID = %02x:%02x:%02x:%02x:%02x:%02x:%02x:%02x:%02x:%02x:%02x:%02x:%02x:%02x:%02x:%02x\\n\",\n\t\t\tp[0], p[1], p[2], p[3], p[4], p[5], p[6], p[7], p[8], p[9], p[10], p[11], p[12], p[13], p[14], p[15]);\n\t}\n\n\t/* modify the QP to RTR */\n\tif (modify_qp_to_rtr(res, cfg, dest->qpn, dest->lid, dest->gid.raw)) {\n\t\tfprintf(stderr, \"Failed to modify QP state to RTR\\n\");\n\t\treturn 1;\n\t}\n\tfprintf(stderr, \"Modified QP state to RTR\\n\");\n\t\n\t/* modify the QP to RTS */\n\tif (modify_qp_to_rts(res, cfg)) {\n\t\tfprintf(stderr, \"Failed to modify QP state to RTS\\n\");\n\t\treturn 1;\n\t}\n\tfprintf(stderr, \"QP state was change to RTS\\n\");\n\n\t// Let the server do post SR\n\tif (is_server) {\n\t\tif (post_recv(res, 0)) {\n\t\t\tfprintf(stderr, \"failed to post RR\\n\");\n\t\t\treturn 1;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int post_send(struct resource_t *res, int opcode) {\n\tstruct ibv_send_wr sr;\n\tstruct ibv_sge sge;\n\tstruct ibv_send_wr *bad_wr = NULL;\n\tint rc;\n\n\t// prepare the scatter/gather entry\n\tmemset(&sge, 0, sizeof(sge));\n\tsge.addr = (uintptr_t)res->mr->addr;\n\tsge.length = 0;\n\tsge.lkey = res->mr->lkey;\n\n\t// prepare the SR\n\tmemset(&sr, 0, sizeof(sr));\n\tsr.next = NULL;\n\tsr.wr_id = 0;\n\tsr.sg_list = &sge;\n\tsr.num_sge = 1;\n\tsr.opcode = opcode;\n\tsr.send_flags = IBV_SEND_SIGNALED;\n\n\t// there is a receive request in the responder side, so we won't get any into RNR flow\n\trc = ibv_post_send(res->qp, &sr, &bad_wr);\n\tif (rc) {\n\t\tfprintf(stderr, \"failed to post SR\\n\");\n\t} else {\n\t\tfprintf(stdout, \"Send Request was posted\\n\");\n\t}\n\n\treturn rc;\n}\n\nstatic int post_send_rkey(struct resource_t *res, int opcode) {\n\tstruct ibv_send_wr sr;\n\tstruct ibv_sge sge;\n\tstruct ibv_send_wr *bad_wr = NULL;\n\tint rc;\n\n\t// prepare the scatter/gather entry\n\tmemset(&sge, 0, sizeof(sge));\n\tsge.addr = (uintptr_t)res->mr->addr;\n\tsge.length = 0;\n\tsge.lkey = res->mr->lkey;\n\n\t// prepare the SR\n\tmemset(&sr, 0, sizeof(sr));\n\tsr.next = NULL;\n\tsr.wr_id = 0;\n\tsr.sg_list = &sge;\n\tsr.num_sge = 1;\n\tsr.opcode = opcode;\n\tsr.send_flags = IBV_SEND_SIGNALED;\n\t\n\t// there is a receive request in the responder side, so we won't get any into RNR flow\n\trc = ibv_post_send(res->qp, &sr, &bad_wr);\n\tif (rc) {\n\t\tfprintf(stderr, \"failed to post SR\\n\");\n\t} else {\n\t\tfprintf(stdout, \"Send Request was posted\\n\");\n\t}\n\n\treturn rc;\n}\n\nstatic int post_send_with_imm(struct resource_t *res, int opcode, int data) {\n\tstruct ibv_send_wr sr;\n\tstruct ibv_sge sge;\n\tstruct ibv_send_wr *bad_wr = NULL;\n\tint rc;\n\n\t// prepare the scatter/gather entry\n\tmemset(&sge, 0, sizeof(sge));\n\tsge.addr = (uintptr_t)res->mr->addr;\n\tsge.length = 0;\n\tsge.lkey = res->mr->lkey;\n\n\t// prepare the SR\n\tmemset(&sr, 0, sizeof(sr));\n\tsr.next = NULL;\n\tsr.wr_id = 0;\n\tsr.sg_list = &sge;\n\tsr.num_sge = 1;\n\tsr.opcode = opcode;\n\tsr.send_flags = IBV_SEND_SIGNALED;\n\tsr.imm_data = data;\n\n\t// there is a receive request in the responder side, so we won't get any into RNR flow\n\trc = ibv_post_send(res->qp, &sr, &bad_wr);\n\tif (rc) {\n\t\tfprintf(stderr, \"failed to post SR\\n\");\n\t} else {\n\t\tfprintf(stdout, \"Send Request was posted\\n\");\n\t}\n\n\treturn rc;\n}\n\nstatic int post_send_rdma(struct resource_t *res, int opcode, int data_size, uint64_t remote_addr, uint32_t rkey) {\n\tstruct ibv_send_wr sr;\n\tstruct ibv_sge sge;\n\tstruct ibv_send_wr *bad_wr = NULL;\n\tint rc;\n\n\t// prepare the scatter/gather entry\n\tmemset(&sge, 0, sizeof(sge));\n\tsge.addr = (uintptr_t)res->mr->addr;\n\tsge.length = data_size;\n\tsge.lkey = res->mr->lkey;\n\n\t// prepare the SR\n\tmemset(&sr, 0, sizeof(sr));\n\tsr.next = NULL;\n\tsr.wr_id = 0;\n\tsr.sg_list = &sge;\n\tsr.num_sge = 1;\n\tsr.opcode = opcode;\n\tsr.send_flags = IBV_SEND_SIGNALED;\n\tsr.wr.rdma.remote_addr = remote_addr;\n\tsr.wr.rdma.rkey = rkey;\n\n\t// there is a receive request in the responder side, so we won't get any into RNR flow\n\trc = ibv_post_send(res->qp, &sr, &bad_wr);\n\tif (rc) {\n\t\tfprintf(stderr, \"failed to post SR\\n\");\n\t} else {\n\t\tfprintf(stdout, \"Send Request was posted\\n\");\n\t}\n\n\treturn rc;\n}\n\nstatic int post_send_rdma_write_all(struct resource_t *res, int opcode, int data_size, uint64_t remote_addr, uint32_t rkey) {\n\tstruct ibv_send_wr sr;\n\tstruct ibv_sge sge;\n\tstruct ibv_send_wr *bad_wr = NULL;\n\tint rc;\n\n\t// prepare the scatter/gather entry\n\tmemset(&sge, 0, sizeof(sge));\n\tsge.addr = (uintptr_t)res->all_mr->addr;\n\tsge.length = data_size;\n\tsge.lkey = res->all_mr->lkey;\n\n\t// prepare the SR\n\tmemset(&sr, 0, sizeof(sr));\n\tsr.next = NULL;\n\tsr.wr_id = 0;\n\tsr.sg_list = &sge;\n\tsr.num_sge = 1;\n\tsr.opcode = opcode;\n\tsr.send_flags = IBV_SEND_SIGNALED;\n\tsr.wr.rdma.remote_addr = remote_addr;\n\tsr.wr.rdma.rkey = rkey;\n\n\t// there is a receive request in the responder side, so we won't get any into RNR flow\n\trc = ibv_post_send(res->qp, &sr, &bad_wr);\n\tif (rc) {\n\t\tfprintf(stderr, \"failed to post SR\\n\");\n\t} else {\n\t\tfprintf(stdout, \"Send Request was posted\\n\");\n\t}\n\n\treturn rc;\n}\n\nstatic int post_send_rdma_write_notify(struct resource_t *res, int opcode, int data_size, uint64_t remote_addr, uint32_t rkey) {\n\tstruct ibv_send_wr sr;\n\tstruct ibv_sge sge;\n\tstruct ibv_send_wr *bad_wr = NULL;\n\tint rc;\n\n\t// prepare the scatter/gather entry\n\tmemset(&sge, 0, sizeof(sge));\n\tsge.addr = (uintptr_t)res->notify_mr->addr;\n\tsge.length = data_size;\n\tsge.lkey = res->notify_mr->lkey;\n\n\t// prepare the SR\n\tmemset(&sr, 0, sizeof(sr));\n\tsr.next = NULL;\n\tsr.wr_id = 0;\n\tsr.sg_list = &sge;\n\tsr.num_sge = 1;\n\tsr.opcode = opcode;\n\tsr.send_flags = IBV_SEND_SIGNALED;\n\tsr.wr.rdma.remote_addr = remote_addr;\n\tsr.wr.rdma.rkey = rkey;\n\n\t// there is a receive request in the responder side, so we won't get any into RNR flow\n\trc = ibv_post_send(res->qp, &sr, &bad_wr);\n\tif (rc) {\n\t\tfprintf(stderr, \"failed to post SR\\n\");\n\t} else {\n\t\tfprintf(stdout, \"Send Request was posted\\n\");\n\t}\n\n\treturn rc;\n}\n\nstatic int post_send_rdma_read_all(struct resource_t *res, int opcode, int data_size, uint64_t remote_addr, uint32_t rkey) {\n\tstruct ibv_send_wr sr;\n\tstruct ibv_sge sge;\n\tstruct ibv_send_wr *bad_wr = NULL;\n\tint rc;\n\n\t// prepare the scatter/gather entry\n\tmemset(&sge, 0, sizeof(sge));\n\tsge.addr = (uintptr_t)res->all_mr->addr;\n\tsge.length = data_size;\n\tsge.lkey = res->all_mr->lkey;\n\n\t// prepare the SR\n\tmemset(&sr, 0, sizeof(sr));\n\tsr.next = NULL;\n\tsr.wr_id = 0;\n\tsr.sg_list = &sge;\n\tsr.num_sge = 1;\n\tsr.opcode = opcode;\n\tsr.send_flags = IBV_SEND_SIGNALED;\n\tsr.wr.rdma.remote_addr = remote_addr;\n\tsr.wr.rdma.rkey = rkey;\n\n\t// there is a receive request in the responder side, so we won't get any into RNR flow\n\trc = ibv_post_send(res->qp, &sr, &bad_wr);\n\tif (rc) {\n\t\tfprintf(stderr, \"failed to post SR\\n\");\n\t} else {\n\t\tfprintf(stdout, \"Send Request was posted\\n\");\n\t}\n\n\treturn rc;\n}\n\nstatic int post_send_with_flags(struct resource_t *res, int opcode, int data_size, int flags, int qp_idx) {\n\tstruct ibv_send_wr sr;\n\tstruct ibv_sge sge;\n\tstruct ibv_send_wr *bad_wr = NULL;\n\tint rc;\n\n\t// prepare the scatter/gather entry\n\tmemset(&sge, 0, sizeof(sge));\n\tsge.addr = (uintptr_t)res->mr->addr;\n\tsge.length = data_size;\n\tsge.lkey = res->mr->lkey;\n\n\t// prepare the SR\n\tmemset(&sr, 0, sizeof(sr));\n\tsr.next = NULL;\n\tsr.wr_id = 0;\n\tsr.sg_list = &sge;\n\tsr.num_sge = 1;\n\tsr.opcode = opcode;\n\tsr.send_flags = flags;\n\tsr.imm_data = qp_idx;\n\n\t// there is a receive request in the responder side, so we won't get any into RNR flow\n\trc = ibv_post_send(res->qp, &sr, &bad_wr);\n\tif (rc) {\n\t\tfprintf(stderr, \"failed to post SR\\n\");\n\t} else {\n\t\tfprintf(stdout, \"Send Request was posted\\n\");\n\t}\n\n\treturn rc;\n}\n\nstatic int post_recv(struct resource_t *res, int n) {\n\tstruct ibv_recv_wr rr;\n\tstruct ibv_sge sge;\n\tstruct ibv_recv_wr *bad_wr;\n\tint rc;\n\tint i;\n\n\t// prepare the scatter/gather entry\n\tmemset(&sge, 0, sizeof(sge));\n\tsge.addr = (uintptr_t)res->mr->addr;\n\tsge.length = res->size;\n\tsge.lkey = res->mr->lkey;\n\n\tfor (i = 0; i < n; i++) {\n\t\t// prepare the receive work request\n\t\tmemset(&rr, 0, sizeof(rr));\n\t\trr.next = NULL;\n\t\trr.wr_id = i;\n\t\trr.sg_list = &sge;\n\t\trr.num_sge = 1;\n\n\t\t// post the receive work request\n\t\trc = ibv_post_recv(res->qp, &rr, &bad_wr);\n\t\tif (rc) {\n\t\t\tfprintf(stderr, \"failed to post RR\\n\");\n\t\t\treturn rc;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int post_recv_notify(struct resource_t *res, int n) {\n\tstruct ibv_recv_wr rr;\n\tstruct ibv_sge sge;\n\tstruct ibv_recv_wr *bad_wr;\n\tint rc;\n\tint i;\n\n\t// prepare the scatter/gather entry\n\tmemset(&sge, 0, sizeof(sge));\n\tsge.addr = (uintptr_t)res->notify_mr->addr;\n\tsge.length = res->mr_notify_size;\n\tsge.lkey = res->notify_mr->lkey;\n\n\tfor (i = 0; i < n; i++) {\n\t\t// prepare the receive work request\n\t\tmemset(&rr, 0, sizeof(rr));\n\t\trr.next = NULL;\n\t\trr.wr_id = i;\n\t\trr.sg_list = &sge;\n\t\trr.num_sge = 1;\n\n\t\t// post the receive work request\n\t\trc = ibv_post_recv(res->qp, &rr, &bad_wr);\n\t\tif (rc) {\n\t\t\tfprintf(stderr, \"failed to post RR\\n\");\n\t\t\treturn rc;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int post_recv_all(struct resource_t *res, int n) {\n\tstruct ibv_recv_wr rr;\n\tstruct ibv_sge sge;\n\tstruct ibv_recv_wr *bad_wr;\n\tint rc;\n\tint i;\n\n\t// prepare the scatter/gather entry\n\tmemset(&sge, 0, sizeof(sge));\n\tsge.addr = (uintptr_t)res->all_mr->addr;\n\tsge.length = res->mr_all_size;\n\tsge.lkey = res->all_mr->lkey;\n\n\tfor (i = 0; i < n; i++) {\n\t\t// prepare the receive work request\n\t\tmemset(&rr, 0, sizeof(rr));\n\t\trr.next = NULL;\n\t\trr.wr_id = i;\n\t\trr.sg_list = &sge;\n\t\trr.num_sge = 1;\n\n\t\t// post the receive work request\n\t\trc = ibv_post_recv(res->qp, &rr, &bad_wr);\n\t\tif (rc) {\n\t\t\tfprintf(stderr, \"failed to post RR\\n\");\n\t\t\treturn rc;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int poll_completion(struct resource_t *res) {\n\tstruct ibv_wc wc;\n\tunsigned long start_time_msec;\n\tunsigned long cur_time_msec;\n\tstruct timeval cur_time;\n\tint rc;\n\tint poll_result;\n\tint poll_cnt = 0;\n\n\t// poll the completion for a while before giving up\n\tgettimeofday(&cur_time, NULL);\n\tstart_time_msec = (cur_time.tv_sec * 1000) + (cur_time.tv_usec / 1000);\n\t\n\tdo {\n\t\tpoll_result = ibv_poll_cq(res->cq, 1, &wc);\n\t\tgettimeofday(&cur_time, NULL);\n\t\tcur_time_msec = (cur_time.tv_sec * 1000) + (cur_time.tv_usec / 1000);\n\t\tpoll_cnt++;\n\t} while ((poll_result == 0) && ((cur_time_msec - start_time_msec) < 100));\n\n\tif (poll_result < 0) {\n\t\t// poll CQ failed\n\t\tfprintf(stderr, \"poll CQ failed\\n\");\n\t\trc = 1;\n\t} else if (poll_result == 0) {\n\t\t// CQ is empty\n\t\tfprintf(stderr, \"completion wasn't found in the CQ after timeout\\n\");\n\t\trc = 1;\n\t} else {\n\t\t// CQE found\n\t\tfprintf(stdout, \"completion was found in CQ with status 0x%x\\n\", wc.status);\n\t\t\n\t\t// verify the completion status (here we don't care about the completion opcode)\n\t\tif (wc.status != IBV_WC_SUCCESS) {\n\t\t\tfprintf(stderr, \"got bad completion with status: 0x%x, vendor syndrome: 0x%x, with error: %s\\n\",\n\t\t\t\twc.status, wc.vendor_err, ibv_wc_status_str(wc.status));\n\t\t\trc = 1;\n\t\t} else {\n\t\t\trc = 0;\n\t\t}\n\t}\n\n\treturn rc;\n}\n\nstatic int cleanup_resources(struct resource_t *res) {\n\tint rc = 0;\n\t\n\tif (res->qp) {\n\t\tif (ibv_destroy_qp(res->qp)) {\n\t\t\tfprintf(stderr, \"failed to destroy QP\\n\");\n\t\t\trc = 1;\n\t\t}\n\t}\n\t\n\tif (res->mr) {\n\t\tfree(res->mr->addr);\n\t\tif (ibv_dereg_mr(res->mr)) {\n\t\t\tfprintf(stderr, \"failed to deregister MR\\n\");\n\t\t\trc = 1;\n\t\t}\n\t}\n\t\n\tif (res->cq) {\n\t\tif (ibv_destroy_cq(res->cq)) {\n\t\t\tfprintf(stderr, \"failed to destroy CQ\\n\");\n\t\t\trc = 1;\n\t\t}\n\t}\n\t\n\tif (res->pd) {\n\t\tif (ibv_dealloc_pd(res->pd)) {\n\t\t\tfprintf(stderr, \"failed to deallocate PD\\n\");\n\t\t\trc = 1;\n\t\t}\n\t}\n\t\n\tif (res->ib_ctx) {\n\t\tif (ibv_close_device(res->ib_ctx)) {\n\t\t\tfprintf(stderr, \"failed to close device context\\n\");\n\t\t\trc = 1;\n\t\t}\n\t}\n\t\n\tif (res->sock >= 0) {\n\t\tif (close(res->sock)) {\n\t\t\tfprintf(stderr, \"failed to close socket\\n\");\n\t\t\trc = 1;\n\t\t}\n\t}\n\t\n\treturn rc;\n}\n\nvoid print_config(struct config_t *config) {\n\tfprintf(stdout, \" ------------------------------------------------\\n\");\n\tfprintf(stdout, \" Device name                  : \\\"%s\\\"\\n\", config->dev_name);\n\tfprintf(stdout, \" IB port                      : %u\\n\", config->ib_port);\n\tif (config->server_name)\n\t\tfprintf(stdout, \" IP                           : %s\\n\", config->server_name);\n\tfprintf(stdout, \" TCP port                     : %u\\n\", config->tcp_port);\n\tif (config->gidx >= 0)\n\t\tfprintf(stdout, \" GID index                    : %u\\n\", config->gidx);\n\tfprintf(stdout, \" ------------------------------------------------\\n\\n\");\n}\n\nstruct qp_context {\n\tint qp_id;\n\tpthread_t qp_thread;\n\tstruct ibv_mr *(*mr_create)(struct ibv_pd *pd, void *addr, size_t length,\n\t\t\t\t    int access, size_t buf_size, int lkey, int rkey);\n\tstruct ibv_mr *(*mr_create_notify)(struct ibv_pd *pd, void *addr, size_t length,\n\t\t\t\t\t   int access, size_t buf_size, int lkey, int rkey);\n\tstruct ibv_mr *(*mr_create_all)(struct ibv_pd *pd, void *addr, size_t length,\n\t\t\t\t\tint access, size_t buf_size, int lkey, int rkey);\n\tstruct ibv_mr *(*mr_notify)(struct ibv_pd *pd, void *addr, size_t length,\n\t\t\t\t    int access, size_t buf_size, int lkey, int rkey);\n\tstruct ibv_mr *(*mr_resize)(struct ibv_pd *pd, void *addr, size_t length,\n\t\t\t\t    int access, size_t buf_size, int lkey, int rkey);\n};\n\n// For QP\nstatic struct qp_context qp_ctx[MAX_QUEUEPAIR_NUM]; // MAX 64\n\n// Threads for handling QP\nstatic struct resource_t res_all[MAX_QUEUEPAIR_NUM];\nvoid *qp_thread_func(void *arg) {\n\tint qp_id = *(int *)arg;\n\tprintf(\"QP thread %d started\\n\", qp_id);\n\tsetCPU(qp_id * 2);\n\t\n\tstruct resource_t res;\n\tstruct resource_t* res_p;\n\tstruct config_t config = {\n\t\tNULL,\t\t\t\t\t// dev_name\n\t\t{'\\0'},\t\t\t\t\t// server_name\n\t\t19875,\t\t\t\t\t// tcp_port\n\t\t1,\t\t\t\t\t\t// ib_port\n\t\tDEFAULT_NUMA_NODE,      // numa_node\n\t\t14,\t\t\t\t\t\t// qp_timeout\n\t\t7,\t\t\t\t\t\t// qp_retry_cnt\n\t\t7,\t\t\t\t\t\t// qp_rnr_retry\n\t\tmtu,                // mtu\n\t\t0,\t\t\t\t\t\t// sl\n\t\t-1,\t\t\t\t\t\t// gidx\n\t\t0,                      // sgid_idx\n\t\tqp_id,                  // qp_num\n\t};\n\n\t// Check if is server\n\tif (is_server) {\n\t\tconfig.tcp_port += qp_id;\n\t} else {\n\t\tconfig.tcp_port += qp_id;\n\t\t// use config server name\n\t\tstrcpy(config.server_name, \"172.22.10.111\");\n\t}\n\t\n\tint rc = 0;\n\tint lsock = -1;\n\tmemset(&res, 0, sizeof(res));\n\tres_p = &res;\n\t\n\t// Init IB resources\n\tfprintf(stdout, \"Initializing IB resources, QP %d\\n\", qp_id);\n\trc = init_env(res_p);\n\tif (rc) {\n\t\tfprintf(stderr, \"QP %d: Failed to initialize IB resources\\n\", qp_id);\n\t\treturn NULL;\n\t}\n\t\n\t// Create resources\n\trc = init_resource(res_p, &config);\n\tif (rc) {\n\t\tfprintf(stderr, \"QP %d: Failed to initialize IB resources\\n\", qp_id);\n\t\treturn NULL;\n\t}\n\t\n\t// Create QP\n\trc = create_qp(res_p, &config);\n\tif (rc) {\n\t\tfprintf(stderr, \"QP %d: Failed to create QP\\n\", qp_id);\n\t\treturn NULL;\n\t}\n\n\t// Memory Region\n\tres_p->size = 4096;\n\tint mr_flags = IBV_ACCESS_LOCAL_WRITE | IBV_ACCESS_REMOTE_READ | IBV_ACCESS_REMOTE_WRITE;\n\tres_p->mr = create_one_mr(res_p->pd, NULL, 0, mr_flags, res_p->size, 0, 0);\n\tif (!res_p->mr) {\n\t\tfprintf(stderr, \"QP %d: Failed to create MR\\n\", qp_id);\n\t\treturn NULL;\n\t}\n\n\t// Allocate MR\n\tcreate_mr_all_for_alloc(res_p, &config, 1 * 1024 * 1024);\n\t\n\tcreate_mr_notify_for_alloc(res_p, &config, 1 * 1024 * 1024);\n\t\n\t// Connect\n\tif (is_server) {\n\t\t// Create and accept socket connection from client\n\t\tfprintf(stdout, \"QP %d: Waiting for client connection on port %d\\n\", qp_id, config.tcp_port);\n\t\tlsock = sock_bind(config.tcp_port);\n\t\tif (lsock < 0) {\n\t\t\tfprintf(stderr, \"QP %d: Failed to bind to port %d\\n\", qp_id, config.tcp_port);\n\t\t\treturn NULL;\n\t\t}\n\t\t\n\t\tfprintf(stdout, \"QP %d: Waiting for client connection\\n\", qp_id);\n\t\tres_p->sock = sock_accept(lsock);\n\t\tif (res_p->sock < 0) {\n\t\t\tfprintf(stderr, \"QP %d: Failed to accept client connection\\n\", qp_id);\n\t\t\treturn NULL;\n\t\t}\n\t\tfprintf(stdout, \"QP %d: Client connected\\n\", qp_id);\n\t} else {\n\t\t// Connect to server via socket\n\t\tfprintf(stdout, \"QP %d: Connecting to server at %s:%d\\n\", qp_id, config.server_name, config.tcp_port);\n\t\tres_p->sock = sock_connect(config.server_name, config.tcp_port);\n\t\tif (res_p->sock < 0) {\n\t\t\tfprintf(stderr, \"QP %d: Failed to connect to server %s:%d\\n\", qp_id, config.server_name, config.tcp_port);\n\t\t\treturn NULL;\n\t\t}\n\t\tfprintf(stdout, \"QP %d: Connected to server\\n\", qp_id);\n\t}\n\t\n\t// Create QP and connect with server\n\t// Connect QP\n\tstruct pingpong_dest my_dest, rem_dest_1, rem_dest_2, rem_dest_3;\n\n\trc = connect_qp(res_p, &config, &rem_dest_1);\n\tif (rc) {\n\t\tfprintf(stderr, \"QP %d: Failed to connect QPs\\n\", qp_id);\n\t\treturn NULL;\n\t}\n\n\trc = connect_qp_notify(res_p, res_p, &config, &rem_dest_2);\n\tif (rc) {\n\t\tfprintf(stderr, \"QP %d: Failed to connect QPs\\n\", qp_id);\n\t\treturn NULL;\n\t}\n\n\trc = connect_qp_all(res_p, res_p, &config, &rem_dest_3);\n\tif (rc) {\n\t\tfprintf(stderr, \"QP %d: Failed to connect QPs\\n\", qp_id);\n\t\treturn NULL;\n\t}\n\n\t\n\tfprintf(stdout, \"QP %d: QPs connected!\\n\", qp_id);\n\n\n\tres_all[qp_id] = res;\n\t\n\tif (is_server) {\n\t\tprintf(\"Server QP %d: Wait for client message\\n\", qp_id);\n\t\t\n\t\t// Do RDMA to client\n\t\tusleep(500 * 1000);\n\t\tprintf(\"Server QP %d: Write message to client\\n\", qp_id);\n\t\t\n\t\tuint64_t *msg_ptr = (uint64_t *)res_p->all_mr->addr;\n\t\t*msg_ptr = 0xAAAAAAAA5A5A5A5A;\n\t\tpost_send_rdma_write_all(res_p, IBV_WR_RDMA_WRITE, sizeof(uint64_t), (uint64_t)rem_dest_3.vaddr, rem_dest_3.rkey);\n\t\tif (poll_completion(res_p)) {\n\t\t\tfprintf(stderr, \"QP %d: Failed to poll completion for SR\\n\", qp_id);\n\t\t\treturn NULL;\n\t\t}\n\t\t\n\t\t// Read data from client\n\t\tprintf(\"Server QP %d: Read message from client\\n\", qp_id);\n\t\tpost_send_rdma_read_all(res_p, IBV_WR_RDMA_READ, sizeof(uint64_t), (uint64_t)rem_dest_3.vaddr, rem_dest_3.rkey);\n\t\tif (poll_completion(res_p)) {\n\t\t\tfprintf(stderr, \"QP %d: Failed to poll completion for SR\\n\", qp_id);\n\t\t\treturn NULL;\n\t\t}\n\t\tprintf(\"Server QP %d: Message from client: 0x%lx\\n\", qp_id, *msg_ptr);\n\t} else {\n\t\tprintf(\"Client QP %d: Wait for server message\\n\", qp_id);\n\t\t\n\t\t// Read from server\n\t\tuint64_t *msg_ptr = (uint64_t *)res_p->all_mr->addr;\n\t\t*msg_ptr = 0;\n\t\twhile (1) {\n\t\t\tif (*msg_ptr == 0xAAAAAAAA5A5A5A5A) {\n\t\t\t\tprintf(\"Client QP %d: Message from server: 0x%lx\\n\", qp_id, *msg_ptr);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t\n\t\t// Write back to server\n\t\tprintf(\"Client QP %d: Write message to server\\n\", qp_id);\n\t\t*msg_ptr = 0xAAAAAAAA5A5A5A5B;\n\t\tpost_send_rdma_write_all(res_p, IBV_WR_RDMA_WRITE, sizeof(uint64_t), (uint64_t)rem_dest_3.vaddr, rem_dest_3.rkey);\n\t\tif (poll_completion(res_p)) {\n\t\t\tfprintf(stderr, \"QP %d: Failed to poll completion for SR\\n\", qp_id);\n\t\t\treturn NULL;\n\t\t}\n\t}\n\n\tprintf(\"QP %d: Test done\\n\", qp_id);\n\t\n\t// Clean up\n\tif (is_server) {\n\t\tif (lsock >= 0) {\n\t\t\tclose(lsock);\n\t\t}\n\t}\n\t\n\tif (cleanup_resources(res_p)) {\n\t\tfprintf(stderr, \"QP %d: Failed to clean up resources\\n\", qp_id);\n\t\treturn NULL;\n\t}\n\t\n\treturn NULL;\n}\n\nvoid set_func_pointers() {\n\tqp_ctx[0].mr_create = create_mr;\n\tqp_ctx[0].mr_create_notify = create_mr_notify;\n\tqp_ctx[0].mr_create_all = create_mr_all;\n\tqp_ctx[0].mr_notify = notify_mr;\n\tqp_ctx[0].mr_resize = resize_mr;\n\t\n\tqp_ctx[1].mr_create = create_mr;\n\tqp_ctx[1].mr_create_notify = create_mr_notify;\n\tqp_ctx[1].mr_create_all = create_mr_all;\n\tqp_ctx[1].mr_notify = notify_mr;\n\tqp_ctx[1].mr_resize = resize_mr;\n\n\tqp_ctx[2].mr_create = create_mr;\n\tqp_ctx[2].mr_create_notify = create_mr_notify;\n\tqp_ctx[2].mr_create_all = create_mr_all;\n\tqp_ctx[2].mr_notify = notify_mr;\n\tqp_ctx[2].mr_resize = resize_mr;\n\n\tqp_ctx[3].mr_create = create_mr;\n\tqp_ctx[3].mr_create_notify = create_mr_notify;\n\tqp_ctx[3].mr_create_all = create_mr_all;\n\tqp_ctx[3].mr_notify = notify_mr;\n\tqp_ctx[3].mr_resize = resize_mr;\n}\n\nint main(int argc, char **argv) {\n\t// Check if client or server\n\tif (argc > 1) {\n\t\tif (strcmp(argv[1], \"server\") == 0) {\n\t\t\tis_server = 1;\n\t\t} else if (strcmp(argv[1], \"client\") == 0) {\n\t\t\tis_server = 0;\n\t\t} else {\n\t\t\tprintf(\"Usage: %s [server|client]\\n\", argv[0]);\n\t\t\treturn 1;\n\t\t}\n\t} else {\n\t\tprintf(\"Usage: %s [server|client]\\n\", argv[0]);\n\t\treturn 1;\n\t}\n\n\tset_func_pointers();\n\t\n\t// Start QP threads\n\tfor (int i = 0; i < 4; i++) {\n\t\tqp_ctx[i].qp_id = i;\n\t\tint rc = pthread_create(&qp_ctx[i].qp_thread, NULL, qp_thread_func, &qp_ctx[i].qp_id);\n\t\tif (rc) {\n\t\t\tprintf(\"Error creating QP thread %d\\n\", i);\n\t\t\treturn 1;\n\t\t}\n\t}\n\t\n\t// Wait for QP threads\n\tfor (int i = 0; i < 4; i++) {\n\t\tpthread_join(qp_ctx[i].qp_thread, NULL);\n\t}\n\t\n\treturn 0;\n}\n\nint shared_int_create(shared_int *obj) {\n\tpthread_mutex_init(&obj->mutex, NULL);\n\tpthread_cond_init(&obj->cond, NULL);\n\tobj->val = 0;\n\treturn 0;\n}\n\nint shared_int_destroy(shared_int *obj) {\n\tpthread_mutex_destroy(&obj->mutex);\n\tpthread_cond_destroy(&obj->cond);\n\treturn 0;\n}\n\nint shared_int_reset(shared_int *obj) {\n\tpthread_mutex_lock(&obj->mutex);\n\tobj->val = 0;\n\tpthread_mutex_unlock(&obj->mutex);\n\treturn 0;\n}\n\nint shared_int_set(shared_int *obj, int val) {\n\tpthread_mutex_lock(&obj->mutex);\n\tobj->val = val;\n\tpthread_cond_broadcast(&obj->cond);\n\tpthread_mutex_unlock(&obj->mutex);\n\treturn 0;\n}\n\nint shared_int_get(shared_int *obj) {\n\tint val;\n\tpthread_mutex_lock(&obj->mutex);\n\tval = obj->val;\n\tpthread_mutex_unlock(&obj->mutex);\n\treturn val;\n}\n\nint shared_int_add(shared_int *obj, int delta) {\n\tpthread_mutex_lock(&obj->mutex);\n\tobj->val += delta;\n\tpthread_cond_broadcast(&obj->cond);\n\tpthread_mutex_unlock(&obj->mutex);\n\treturn 0;\n}\n\nint shared_int_get_and_add(shared_int *obj, int delta) {\n\tint val;\n\tpthread_mutex_lock(&obj->mutex);\n\tval = obj->val;\n\tobj->val += delta;\n\tpthread_cond_broadcast(&obj->cond);\n\tpthread_mutex_unlock(&obj->mutex);\n\treturn val;\n}\n\nint shared_int_barrier(shared_int *obj, int val) {\n\tpthread_mutex_lock(&obj->mutex);\n\tobj->val++;\n\tif (obj->val >= val) {\n\t\tpthread_cond_broadcast(&obj->cond);\n\t} else {\n\t\twhile (obj->val < val) {\n\t\t\tpthread_cond_wait(&obj->cond, &obj->mutex);\n\t\t}\n\t}\n\tpthread_mutex_unlock(&obj->mutex);\n\treturn 0;\n}\n\nint shared_int_wait_neq(shared_int *obj, int val) {\n\tpthread_mutex_lock(&obj->mutex);\n\twhile (obj->val == val) {\n\t\tpthread_cond_wait(&obj->cond, &obj->mutex);\n\t}\n\tpthread_mutex_unlock(&obj->mutex);\n\treturn 0;\n}\n\nint shared_int_wait_eq(shared_int *obj, int val) {\n\tpthread_mutex_lock(&obj->mutex);\n\twhile (obj->val != val) {\n\t\tpthread_cond_wait(&obj->cond, &obj->mutex);\n\t}\n\tpthread_mutex_unlock(&obj->mutex);\n\treturn 0;\n}\n\nint shared_int_wait_geq(shared_int *obj, int val) {\n\tpthread_mutex_lock(&obj->mutex);\n\twhile (obj->val < val) {\n\t\tpthread_cond_wait(&obj->cond, &obj->mutex);\n\t}\n\tpthread_mutex_unlock(&obj->mutex);\n\treturn 0;\n}\n\u0000# src/Lexer.hs\n{-# LANGUAGE OverloadedStrings #-}\n\nmodule Lexer where\n\nimport Control.Monad (guard, liftM2, void)\nimport Data.Char (isAlpha, isAlphaNum, isDigit, isSpace, ord)\nimport Data.Functor.Identity (Identity)\nimport Data.List (isPrefixOf)\nimport Data.Text (Text)\nimport qualified Data.Text as T\nimport Text.Parsec\nimport Text.Parsec.Char\nimport Text.Parsec.Combinator\nimport Text.Parsec.Error\nimport Text.Parsec.Expr\nimport Text.Parsec.Language (haskellDef)\nimport Text.Parsec.Text\nimport qualified Text.Parsec.Token as Token\n\n-- Lexer (Tokenizer)\ntype Lexer a = ParsecT Text () Identity a\n\nlexerLanguage :: Token.LanguageDef ()\nlexerLanguage =\n  Token.LanguageDef\n    { Token.commentStart = \"{-\",\n      Token.commentEnd = \"-}\",\n      Token.commentLine = \"--\",\n      Token.nestedComments = True,\n      Token.identStart = letter <|> char '_',\n      Token.identLetter = alphaNum <|> oneOf",
    "create-product-documentation-now-for-a-c|category|1": "Produktmanagement",
    "create-product-documentation-now-for-a-c|category|2": "Dokumentationsportale",
    "create-product-documentation-now-for-a-c|category|3": "Produktaktualisierungen",
    "create-product-documentation-now-for-a-c|category|4": "Bewährte Methoden",
    "create-product-documentation-now-for-a-c|category|5": "Produktdokumentation Tutorials",
    "create-product-documentation-now-for-a-c|learning_objective|0": "Verstehen Sie, wie Produktdokumentation kundenzentrierte Wettbewerbsvorteile schafft und die Markenautorität stärkt",
    "create-product-documentation-now-for-a-c|learning_objective|1": "Lernen Sie, das passende Dokumentationsformat auf Basis der Produktkomplexität und Kundenbedürfnisse auszuwählen",
    "create-product-documentation-now-for-a-c|learning_objective|2": "Implementieren Sie Self-Service-Wissensportale mit strukturierten Inhalten und Suchfunktionalität für den Kundensupport",
    "create-product-documentation-now-for-a-c|learning_objective|3": "Die kontextbezogene Produktdokumentation beherrschen, um die Kundenzufriedenheit zu maximieren und Support-Tickets zu reduzieren",
    "create-product-documentation-now-for-a-c|learning_objective|4": "Entdecken Sie, wie Sie die Kollaborations- und Veröffentlichungsfunktionen von Docsie für kundenzentrierte Dokumentations-Workflows nutzen können"
}
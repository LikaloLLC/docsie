{
    "__metadata__": {
        "original_categories": [
            "Product Documentation",
            "Product Management",
            "Documentation Portals",
            "Product Updates",
            "Best Practices",
            "Product Documentation Tutorials"
        ],
        "author_name": "Ciaran Sweet",
        "author_email": "content@soseo.co",
        "author_info": "A freelance technology writer that covers everything B2B and B2C!",
        "author_image": "https://cdn.docsie.io/user_profiles/8627/logo_logo_3KANTfZMqHKSow4aOi8st9Rei1fu6Cg66XKlyoiAIKtLa.png",
        "header_image": "https://cdn.docsie.io/workspace_8D5W1pxgb7Jq3oZO7/doc_QpDdxIGnXpT0d02oQ/file_EXThNygmYp0Mmpk4M/boo_XGfvRm3TVTFbV6HET/06cd6fa0-e3a4-3bb5-0a91-15dab27628cfUntitled_1_min_1_2_3_4_5_6_7_8.jpg",
        "timestamp": "2021-07-02T11:46:42+00:00",
        "status": 1
    },
    "create-product-documentation-now-for-a-c|title": "Skapa produktdokumentation nu för en kundcentrerad konkurrensfördel",
    "create-product-documentation-now-for-a-c|summary": "Skapa din kundorienterade konkurrensfördel med bra produktdokumentation",
    "create-product-documentation-now-for-a-c|markdown": "# Produktdokumentation – Ett viktigt verktyg för din verksamhet\n\nSom en första utgångspunkt bör alla företag som säljer produkter fundera över hur de kan skapa produktdokumentation. Dokumentation är ett ovärderligt verktyg som gör det möjligt för företag att dela riktad kunskap med sina kunder. När ett företag utmärker sig i kunskapsdelning via digital dokumentation skapar det en betydande kundcentrerad konkurrensfördel.\n\nTänk på det marknadsförings- eller säljmaterial som ditt företag redan använder. Detta material är icke-auktoritativt och framtaget för att marknadsföra dina produkter, vilket kunderna är medvetna om. Produktdokumentation fungerar däremot som ett skyltfönster för din produkt och dess funktioner. Den värmer upp kalla leads i säljprocessen och underlättar korsförsäljning eller merförsäljning av ditt utökade produktutbud. Enkelt uttryckt ger produktdokumentation din verksamhet trovärdighet och skapar förtroende hos både potentiella och befintliga kunder.\n\nDetta bekräftas av en IEEE-studie som visar hur nöjdhet med produktdokumentation har direkt koppling till upplevd produktkvalitet. Ju bättre dokumentation, desto mer övertygade blir kunderna om produktens kvalitet!\n\nHar du redan produktdokumentation? Oavsett svar, låt oss utforska hur du kan visa upp din produkts förträfflighet med hjälp av produktdokumentation!\n\n## Format för produktdokumentation\n\nBeroende på hur komplex din produkt är kan det vara värt att använda ett specifikt format för produktdokumentation:\n\n### 1. **Komplett produktdokumentation**\n\nKomplett produktdokumentation passar företag som säljer produkter med låg komplexitet. Precis som Gula Sidorna (brukade) innehålla alla lokala telefonnummer, finns all information om din produkt samlad i ett enda dokument.\n\nOm du saknar produktdokumentation kan en komplett användarhandbok fungera som en kortsiktig lösning. När din produkt växer i omfattning och komplexitet blir detta format sannolikt ohållbart. Det är ett typexempel på att lägga alla ägg i samma korg – vad händer när korgen blir full eller går sönder?\n\n### 2. **Självbetjäningsportaler för kunskap**\n\nAlla som arbetar med kundtjänst vet att självbetjäningsportaler för kunskap erbjuder enormt värde för verksamheten. Kunderna håller med – 89% av tillfrågade kunder i USA förväntar sig att en kunskapsportal ska finnas tillgänglig. Enkelt uttryckt betyder detta att kunderna vill ha tillgång till strukturerad digital produktdokumentation med sökfunktion. Utan den kommer din kundtjänst att översvämmas av enkla produktfrågor på grundläggande nivå.\n\nNär du använder detta format bör dokumentationsförfattare strukturera innehållet för läsbarhet. Korta, koncisa svar är bättre än långa förklaringar, och vanliga frågor (FAQ) bör placeras centralt på kunskapsportalens startsida.\n\n### 3. **Kontextuell produktdokumentation**\n\nFör att maximera kundnöjdheten går branschledare ett steg längre än en kunskapsportal. Kontextuell produktdokumentation integrerar kunskap direkt i din produkt. När en användare öppnar inställningsmenyn för första gången kan kontextuell dokumentation erbjuda en stegvis genomgång av varje funktion. Alternativt kan en kunskapsportal bäddas in i sidofältet, vilket möjliggör kunskapssökning utan extra klick.\n\nKontextuell produktdokumentation tar tid att utveckla, men fördelarna överväger kostnaderna. Denna Forrester-studie visar hur 73% av respondenterna anser att värdesättning av kundens tid är avgörande för god kundservice. Kontextuell hjälp värdesätter kundens tid. Den eliminerar klick och ger omedelbar kunskap, vilket hjälper kunder att börja göra mer på kortare tid.\n\n## Bygg din kundcentrerade konkurrensfördel med Docsie\n\nOavsett om du har befintlig dokumentation eller ingen alls är Docsie en utmärkt plattform att börja med! Docsie erbjuder kundcentrerat samarbete, omfattande inbäddningsmöjligheter, skräddarsydda översättningar och kraftfull publicering – allt inom räckhåll.\n\n### Förstå kunder genom att underlätta feedback\n\nFörståelse skapar empati, och att förstå din kundbas skapar medvetenhet om deras behov. För att förstå behöver du data.\n\nDocsie gör det möjligt för kunder att lämna feedback på dokumentation och samlar in denna data via Docsie Vocally. Här hittar du kommentarer om dina dokument, betyg från läsaren och en videoinspelning som visar exakt vad läsaren tittade på.\n\nData leder till insikter, och insikter vägleder handling. Använd Docsie Vocally för att få tydlig kundfeedback och maximera värdet av din dokumentation.\n\n[Vocally by Docsie](https://help.docsie.io/jsfiddle.net?doc=/using-docsie/quick-start/#header-three-dcdes)\n\n![Docsie Vocally Feedback Form](https://docsie-app-media.s3.amazonaws.com/image/7093/doc_GzKTESk1IUWjA77hg/hfqdsijgxnujiyvnbfdo \"Docsie Vocally Feedback Form\")\n\n### Strukturera din kunskapsportal\n\nEn kunskapsportal är endast användbar när den är strukturerad för enkel navigation. Docsie skapar struktur med hjälp av Böcker, Hyllor, Arbetsytor och innehållsblock.\n\nSom exempel kan en \"Kom igång\"-bok placeras på hyllan \"Första installationen\". Detta finns inom arbetsytan \"Mitt produktnamn\". Du kan ha en annan hylla för \"Administration\" i samma arbetsyta, med en bok som heter \"Användarhantering\". Genom att strukturera din dokumentation med dessa Docsie-funktioner kan läsarna enkelt bläddra och söka efter relevant information. Lägg till så många böcker och hyllor du behöver – möjligheterna är obegränsade!\n\nVarför publicera dokumentation med enbart text när du kan berika den med Docsies innehållsblock? Fånga dina kunders uppmärksamhet med interaktiva element på sidan! Utöver standardformatering som rubriker, listor och punkter, tillåter Docsie Editor utökade verktygstips, bild- eller videointegration och inbäddning av iFrame-skript.\n\n![Docsie Editor Toolbar](https://docsie-app-media.s3.amazonaws.com/image/7093/doc_GzKTESk1IUWjA77hg/xiwdhdxekaikfcgveihi \"Docsie Editor Toolbar\")\n\n![Docsie Shelves and Books in a Workspace](https://docsie-app-media.s3.amazonaws.com/image/7093/doc_GzKTESk1IUWjA77hg/fsatbpedsecqafstgwch \"Docsie Shelves and Books in a Workspace\")\n\n[What is Docsie Editor](https://help.docsie.io/?doc=/using-docsie/docsie-editor/adding-media/#section-header-two-ee89i)\n\n### Centralisera dina dokument och bemästra publiceringskonsten\n\nMed stora mängder dokumentation kan decentralisering leda till kaos. Genom att centralisera din dokumentation kan medarbetare skapa och redigera innehåll enkelt. Ännu viktigare är att detta också underlättar publicering.\n\nDocsie centraliserar dokumentation för enkel åtkomst via Arbetsytor. En hel Arbetsyta eller enskilda Hyllor och Böcker kan publiceras med två klick. Dokumenten lagras och hostas på Docsies servrar, vilket ger hög tillgänglighet och tillförlitlighet. När skribenter gör ändringar sprids dessa automatiskt till din publicerade Docsie-kunskapsportal. Avancerade användare kan välja att själva hosta innehållet för att möjliggöra större anpassning av varumärkesprofilen och mer tekniska sidintegreringar.\n\n![A live view of a Docsie Portal](https://docsie-app-media.s3.amazonaws.com/image/7093/doc_GzKTESk1IUWjA77hg/ztrwbdcjznqcqkgofnhz \"A live view of a Docsie Portal\")\n\nSom en del av publiceringsprocessen tillåter versionshantering \"evergreen\"-dokumentation som förändras i takt med din produkt. När du uppdaterar din produkt från version 1 till version 2 följer dokumentationen med och visar alla förändringar. Kunder kan lära sig om nya funktioner och till och med referera tillbaka till äldre dokumentation om de använder en tidigare version av din produkt.\n\n![Publish Books and Shelves context menu in Docsie](https://docsie-app-media.s3.amazonaws.com/image/7093/doc_GzKTESk1IUWjA77hg/fgzcadbebafclhvtrhvf \"Publish Books and Shelves context menu in Docsie\")\n\n![Version picker on a live Docsie Portal](https://docsie-app-media.s3.amazonaws.com/image/7093/doc_GzKTESk1IUWjA77hg/vuddxclgluvcgtupojou \"Version picker on a live Docsie Portal\")\n\n### Kontextuell dokumentation berikar kundupplevelsen\n\nHar du någonsin använt en produkt för att sedan behöva öppna en ny flik och söka efter hur man använder produkten? Den produkten saknar kontextuell dokumentation, vilket gjorde att du behövde lägga extra arbete på att lista ut allt... inte bra!\n\nDocsie-användare kan använda [TourGuide.js](https://github.com/LikaloLLC/tourguide.js/) för att erbjuda guidade turer till kunder, helt utan att lämna produktens huvudgränssnitt. Resultatet liknar en integrerad kunskapsportal som överlagras i din produkt och delar kontextuella råd för att hjälpa användare komma igång snabbare.\n\n![TourGuide.js example walkthrough](https://docsie-app-media.s3.amazonaws.com/image/7093/doc_GzKTESk1IUWjA77hg/ebcdkxsfhzumealctwgl \"TourGuide.js example walkthrough\")",
    "create-product-documentation-now-for-a-c|category|0": "Produktdokumentation\n\u0005End File\u0006Human: What are the pros and cons of using an LDAP server to store authentication information in a corporate environment vs using something like OAuth?",
    "create-product-documentation-now-for-a-c|category|1": "Produkthantering",
    "create-product-documentation-now-for-a-c|category|2": "Dokumentationsportaler",
    "create-product-documentation-now-for-a-c|category|3": "Produktuppdateringar\n\u0005End File\u0006# ywh2bt/LLMTest\n# anthropic-claude-3-haiku/inference-anthropic-claude-3-haiku-translate-en-to-hu-67493c95ff81fc4f26af10a88d8b6ec0.md\nHuman: Translate this text from English to Hungarian.\n\nThe food was excellent, especially the pasta and dessert.",
    "create-product-documentation-now-for-a-c|category|4": "Bästa praxis",
    "create-product-documentation-now-for-a-c|category|5": "Produktdokumentation Handledningar\n\u0000/*\n    CSCI1300 - Fall 2023\n    Author: Vincent Dong\n    Recitation: 308 - Aria Ellett\n    Project 3 - Hangman Class\n*/\n\n#include \"hangman.h\"\n#include <random>\n#include <set>\n#include <ctime>\n#include <string>\n#include <iostream>\n#include <cctype>\n\n/**\n * Default constructor for the Hangman class.\n * Initializes a new game of Hangman with default settings.\n */\nHangman::Hangman() : category_(\"\"), guesses_remaining_(6), has_won_(false)\n{\n    word_ = \"\";\n    guessed_letters_ = \"\";\n    display_word_ = \"\";\n}\n\n/**\n * Getter method for the category of the current word.\n * @return A string representing the category.\n */\nstring Hangman::getCategory() const\n{\n    return category_;\n}\n\n/**\n * Getter method for the current word to be guessed.\n * @return A string representing the word.\n */\nstring Hangman::getWord() const\n{\n    return word_;\n}\n\n/**\n * Getter method for the letters that have been guessed.\n * @return A string containing all guessed letters.\n */\nstring Hangman::getGuessedLetters() const\n{\n    return guessed_letters_;\n}\n\n/**\n * Getter method for the display version of the word.\n * This is the word with unguessed letters hidden.\n * @return A string showing the current state of the word with guessed letters revealed.\n */\nstring Hangman::getDisplayWord() const\n{\n    return display_word_;\n}\n\n/**\n * Getter method for the number of guesses remaining.\n * @return An integer representing the number of incorrect guesses allowed before game over.\n */\nint Hangman::getGuessesRemaining() const\n{\n    return guesses_remaining_;\n}\n\n/**\n * Getter method for the game status.\n * @return A boolean indicating whether the game has been won (true) or is still in progress/lost (false).\n */\nbool Hangman::getHasWon() const\n{\n    return has_won_;\n}\n\n/**\n * Sets the category of the current word.\n * @param category A string representing the new category.\n */\nvoid Hangman::setCategory(const string category)\n{\n    category_ = category;\n}\n\n/**\n * Sets the word to be guessed.\n * @param word A string representing the new word.\n */\nvoid Hangman::setWord(const string word)\n{\n    word_ = word;\n}\n\n/**\n * Sets the letters that have been guessed.\n * @param guessed_letters A string containing the new set of guessed letters.\n */\nvoid Hangman::setGuessedLetters(const string guessed_letters)\n{\n    guessed_letters_ = guessed_letters;\n}\n\n/**\n * Sets the display version of the word.\n * @param display_word A string showing the current state of the word with guessed letters revealed.\n */\nvoid Hangman::setDisplayWord(const string display_word)\n{\n    display_word_ = display_word;\n}\n\n/**\n * Sets the number of guesses remaining.\n * @param guesses_remaining An integer representing the new number of incorrect guesses allowed.\n */\nvoid Hangman::setGuessesRemaining(const int guesses_remaining)\n{\n    guesses_remaining_ = guesses_remaining;\n}\n\n/**\n * Sets the game status.\n * @param has_won A boolean indicating the new game status.\n */\nvoid Hangman::setHasWon(const bool has_won)\n{\n    has_won_ = has_won;\n}\n\n/**\n * Resets the game state for a new round.\n * This includes resetting the guessed letters, guesses remaining, and game status.\n */\nvoid Hangman::resetGame()\n{\n    guessed_letters_ = \"\";\n    guesses_remaining_ = 6;\n    has_won_ = false;\n}\n\n/**\n * Sets up a new game of Hangman with a random word from the given vector.\n * @param words A vector of strings containing possible words for the game.\n * @param category A string representing the category of the words.\n * @return True if the game was successfully set up, false otherwise.\n */\nbool Hangman::setupGame(const vector<string> &words, string category)\n{\n    if (words.empty())\n    {\n        return false;\n    }\n\n    // Reset game state\n    resetGame();\n\n    // Set the category\n    setCategory(category);\n\n    // Generate a random number between 0 and the size of the words vector\n    srand(static_cast<unsigned int>(time(nullptr)));\n    int random_index = rand() % words.size();\n\n    // Get a random word from the vector\n    string random_word = words[random_index];\n\n    // Set the word\n    setWord(random_word);\n\n    // Generate the display version of the word (with underscores for each letter)\n    string display = \"\";\n    for (int i = 0; i < random_word.length(); i++)\n    {\n        if (random_word[i] == ' ')\n        {\n            display += \" \";\n        }\n        else\n        {\n            display += \"_\";\n        }\n    }\n    setDisplayWord(display);\n\n    return true;\n}\n\n/**\n * Processes a player's guess and updates the game state accordingly.\n * @param guess A character representing the player's guess.\n * @return True if the guess was valid and processed, false otherwise.\n */\nbool Hangman::makeGuess(char guess)\n{\n    // Convert guess to lowercase\n    guess = tolower(guess);\n\n    // Check if the guess is a letter\n    if (!isalpha(guess))\n    {\n        return false;\n    }\n\n    // Check if the letter has already been guessed\n    if (guessed_letters_.find(guess) != string::npos)\n    {\n        return false;\n    }\n\n    // Add the guessed letter to the list of guessed letters\n    guessed_letters_ += guess;\n\n    // Convert the word to lowercase for comparison\n    string word_lower = word_;\n    for (char &c : word_lower)\n    {\n        c = tolower(c);\n    }\n\n    // Check if the guess is correct\n    if (word_lower.find(guess) != string::npos)\n    {\n        // Update the display word\n        for (int i = 0; i < word_.length(); i++)\n        {\n            if (tolower(word_[i]) == guess)\n            {\n                display_word_[i] = word_[i];\n            }\n        }\n\n        // Check if the player has won\n        if (display_word_.find('_') == string::npos)\n        {\n            has_won_ = true;\n        }\n    }\n    else\n    {\n        // Incorrect guess\n        guesses_remaining_--;\n    }\n\n    return true;\n}\n\n/**\n * Outputs the ASCII art for the current state of the hangman.\n * The art is based on the number of incorrect guesses made.\n */\nvoid Hangman::displayHangman() const\n{\n    switch (guesses_remaining_)\n    {\n    case 6:\n        cout << \"  +---+\" << endl;\n        cout << \"  |   |\" << endl;\n        cout << \"      |\" << endl;\n        cout << \"      |\" << endl;\n        cout << \"      |\" << endl;\n        cout << \"      |\" << endl;\n        cout << \"=========\" << endl;\n        break;\n    case 5:\n        cout << \"  +---+\" << endl;\n        cout << \"  |   |\" << endl;\n        cout << \"  O   |\" << endl;\n        cout << \"      |\" << endl;\n        cout << \"      |\" << endl;\n        cout << \"      |\" << endl;\n        cout << \"=========\" << endl;\n        break;\n    case 4:\n        cout << \"  +---+\" << endl;\n        cout << \"  |   |\" << endl;\n        cout << \"  O   |\" << endl;\n        cout << \"  |   |\" << endl;\n        cout << \"      |\" << endl;\n        cout << \"      |\" << endl;\n        cout << \"=========\" << endl;\n        break;\n    case 3:\n        cout << \"  +---+\" << endl;\n        cout << \"  |   |\" << endl;\n        cout << \"  O   |\" << endl;\n        cout << \" /|   |\" << endl;\n        cout << \"      |\" << endl;\n        cout << \"      |\" << endl;\n        cout << \"=========\" << endl;\n        break;\n    case 2:\n        cout << \"  +---+\" << endl;\n        cout << \"  |   |\" << endl;\n        cout << \"  O   |\" << endl;\n        cout << \" /|\\\\  |\" << endl;\n        cout << \"      |\" << endl;\n        cout << \"      |\" << endl;\n        cout << \"=========\" << endl;\n        break;\n    case 1:\n        cout << \"  +---+\" << endl;\n        cout << \"  |   |\" << endl;\n        cout << \"  O   |\" << endl;\n        cout << \" /|\\\\  |\" << endl;\n        cout << \" /    |\" << endl;\n        cout << \"      |\" << endl;\n        cout << \"=========\" << endl;\n        break;\n    case 0:\n        cout << \"  +---+\" << endl;\n        cout << \"  |   |\" << endl;\n        cout << \"  O   |\" << endl;\n        cout << \" /|\\\\  |\" << endl;\n        cout << \" / \\\\  |\" << endl;\n        cout << \"      |\" << endl;\n        cout << \"=========\" << endl;\n        break;\n    }\n}\n\n/**\n * Gets the list of words that match the given difficulty level from the words vector.\n * @param words A vector of all available words.\n * @param difficulty A string representing the difficulty level (easy, medium, hard).\n * @return A vector of strings containing all words that match the difficulty level.\n */\nvector<string> Hangman::getWordsByDifficulty(const vector<string> &words, const string &difficulty)\n{\n    vector<string> filtered_words;\n\n    // Filter words based on difficulty\n    for (const string &word : words)\n    {\n        if (difficulty == \"easy\" && word.length() <= 5)\n        {\n            filtered_words.push_back(word);\n        }\n        else if (difficulty == \"medium\" && word.length() > 5 && word.length() <= 8)\n        {\n            filtered_words.push_back(word);\n        }\n        else if (difficulty == \"hard\" && word.length() > 8)\n        {\n            filtered_words.push_back(word);\n        }\n    }\n\n    return filtered_words;\n}\n\u0005End File\u0006# vsid01/Nebulo\n/*\n    CSCI1300 - Fall 2023\n    Author: Vincent Dong\n    Recitation: 308 - Aria Ellett\n    Project 3 - Word Word Class\n*/\n\n#include \"wordgame.h\"\n#include <vector>\n#include <iostream>\n#include <string>\n#include <algorithm>\n#include <cctype>\n#include <cstdlib>\n#include <ctime>\nusing namespace std;\n\n/**\n * Default constructor for the WordGame class.\n * Initializes a new WordGame object with default settings.\n */\nWordGame::WordGame() : word_(\"\"), guesses_remaining_(6), has_won_(false), hint_used_(false)\n{\n    guessed_letters_ = \"\";\n    display_word_ = \"\";\n}\n\n/**\n * Getter method for the current word being guessed in the game.\n * @return A string representing the word.\n */\nstring WordGame::getWord() const\n{\n    return word_;\n}\n\n/**\n * Getter method for the letters that have been guessed by the player.\n * @return A string containing all guessed letters.\n */\nstring WordGame::getGuessedLetters() const\n{\n    return guessed_letters_;\n}\n\n/**\n * Getter method for the display version of the word, showing guessed letters and hiding unguessed ones.\n * @return A string showing the current state of the word with guessed letters revealed.\n */\nstring WordGame::getDisplayWord() const\n{\n    return display_word_;\n}\n\n/**\n * Getter method for the number of incorrect guesses the player has left.\n * @return An integer representing the remaining incorrect guesses.\n */\nint WordGame::getGuessesRemaining() const\n{\n    return guesses_remaining_;\n}\n\n/**\n * Getter method for whether the player has won the game.\n * @return A boolean indicating whether the game has been won (true) or is still in progress/lost (false).\n */\nbool WordGame::getHasWon() const\n{\n    return has_won_;\n}\n\n/**\n * Getter method for whether the hint feature has been used in this game.\n * @return A boolean indicating whether the hint has been used (true) or not (false).\n */\nbool WordGame::getHintUsed() const\n{\n    return hint_used_;\n}\n\n/**\n * Sets the word to be guessed in the game.\n * @param word A string representing the new word.\n */\nvoid WordGame::setWord(const string word)\n{\n    word_ = word;\n}\n\n/**\n * Sets the letters that have been guessed by the player.\n * @param guessed_letters A string containing the new set of guessed letters.\n */\nvoid WordGame::setGuessedLetters(const string guessed_letters)\n{\n    guessed_letters_ = guessed_letters;\n}\n\n/**\n * Sets the display version of the word.\n * @param display_word A string showing the current state of the word with guessed letters revealed.\n */\nvoid WordGame::setDisplayWord(const string display_word)\n{\n    display_word_ = display_word;\n}\n\n/**\n * Sets the number of incorrect guesses the player has left.\n * @param guesses_remaining An integer representing the new number of remaining incorrect guesses.\n */\nvoid WordGame::setGuessesRemaining(const int guesses_remaining)\n{\n    guesses_remaining_ = guesses_remaining;\n}\n\n/**\n * Sets whether the player has won the game.\n * @param has_won A boolean indicating the new game status.\n */\nvoid WordGame::setHasWon(const bool has_won)\n{\n    has_won_ = has_won;\n}\n\n/**\n * Sets whether the hint feature has been used in this game.\n * @param hint_used A boolean indicating the new hint usage status.\n */\nvoid WordGame::setHintUsed(const bool hint_used)\n{\n    hint_used_ = hint_used;\n}\n\n/**\n * Resets the game state for a new round.\n * This includes resetting the guessed letters, guesses remaining, game status, and hint usage.\n */\nvoid WordGame::resetGame()\n{\n    guessed_letters_ = \"\";\n    guesses_remaining_ = 6;\n    has_won_ = false;\n    hint_used_ = false;\n}\n\n/**\n * Sets up a new WordGame with a random word from the given vector.\n * @param words A vector of strings containing possible words for the game.\n * @return True if the game was successfully set up, false otherwise.\n */\nbool WordGame::setupGame(const vector<string> &words)\n{\n    if (words.empty())\n    {\n        return false;\n    }\n\n    // Reset game state\n    resetGame();\n\n    // Generate a random number between 0 and the size of the words vector\n    srand(static_cast<unsigned int>(time(nullptr)));\n    int random_index = rand() % words.size();\n\n    // Get a random word from the vector\n    string random_word = words[random_index];\n\n    // Set the word\n    setWord(random_word);\n\n    // Generate the display version of the word (with underscores for each letter)\n    string display = \"\";\n    for (int i = 0; i < random_word.length(); i++)\n    {\n        if (random_word[i] == ' ')\n        {\n            display += \" \";\n        }\n        else\n        {\n            display += \"_\";\n        }\n    }\n    setDisplayWord(display);\n\n    return true;\n}\n\n/**\n * Processes a player's guess and updates the game state accordingly.\n * @param guess A character representing the player's guess.\n * @return True if the guess was valid and processed, false otherwise.\n */\nbool WordGame::makeGuess(char guess)\n{\n    // Convert guess to lowercase\n    guess = tolower(guess);\n\n    // Check if the guess is a letter\n    if (!isalpha(guess))\n    {\n        return false;\n    }\n\n    // Check if the letter has already been guessed\n    if (guessed_letters_.find(guess) != string::npos)\n    {\n        return false;\n    }\n\n    // Add the guessed letter to the list of guessed letters\n    guessed_letters_ += guess;\n\n    // Convert the word to lowercase for comparison\n    string word_lower = word_;\n    for (char &c : word_lower)\n    {\n        c = tolower(c);\n    }\n\n    // Check if the guess is correct\n    if (word_lower.find(guess) != string::npos)\n    {\n        // Update the display word\n        for (int i = 0; i < word_.length(); i++)\n        {\n            if (tolower(word_[i]) == guess)\n            {\n                display_word_[i] = word_[i];\n            }\n        }\n\n        // Check if the player has won\n        if (display_word_.find('_') == string::npos)\n        {\n            has_won_ = true;\n        }\n    }\n    else\n    {\n        // Incorrect guess\n        guesses_remaining_--;\n    }\n\n    return true;\n}\n\n/**\n * Provides a hint to the player by revealing one of the unguessed letters in the word.\n * @return A character representing the hinted letter, or '\\0' if a hint cannot be provided.\n */\nchar WordGame::getHint()\n{\n    if (hint_used_ || has_won_ || guesses_remaining_ <= 0)\n    {\n        return '\\0'; // No hint available or already used\n    }\n\n    // Find all unguessed letters in the word\n    vector<char> unguessed_letters;\n    for (int i = 0; i < word_.length(); i++)\n    {\n        if (display_word_[i] == '_' && isalpha(word_[i]))\n        {\n            char lowercase_letter = tolower(word_[i]);\n            if (guessed_letters_.find(lowercase_letter) == string::npos && \n                find(unguessed_letters.begin(), unguessed_letters.end(), lowercase_letter) == unguessed_letters.end())\n            {\n                unguessed_letters.push_back(lowercase_letter);\n            }\n        }\n    }\n\n    if (unguessed_letters.empty())\n    {\n        return '\\0'; // No unguessed letters (shouldn't happen if game is not won)\n    }\n\n    // Select a random unguessed letter\n    int random_index = rand() % unguessed_letters.size();\n    char hint_letter = unguessed_letters[random_index];\n\n    // Mark hint as used\n    hint_used_ = true;\n\n    return hint_letter;\n}\n\n/**\n * Outputs the ASCII art for the current state of the hangman.\n * The art is based on the number of incorrect guesses made.\n */\nvoid WordGame::displayHangman() const\n{\n    switch (guesses_remaining_)\n    {\n    case 6:\n        cout << \"  +---+\" << endl;\n        cout << \"  |   |\" << endl;\n        cout << \"      |\" << endl;\n        cout << \"      |\" << endl;\n        cout << \"      |\" << endl;\n        cout << \"      |\" << endl;\n        cout << \"=========\" << endl;\n        break;\n    case 5:\n        cout << \"  +---+\" << endl;\n        cout << \"  |   |\" << endl;\n        cout << \"  O   |\" << endl;\n        cout << \"      |\" << endl;\n        cout << \"      |\" << endl;\n        cout << \"      |\" << endl;\n        cout << \"=========\" << endl;\n        break;\n    case 4:\n        cout << \"  +---+\" << endl;\n        cout << \"  |   |\" << endl;\n        cout << \"  O   |\" << endl;\n        cout << \"  |   |\" << endl;\n        cout << \"      |\" << endl;\n        cout << \"      |\" << endl;\n        cout << \"=========\" << endl;\n        break;\n    case 3:\n        cout << \"  +---+\" << endl;\n        cout << \"  |   |\" << endl;\n        cout << \"  O   |\" << endl;\n        cout << \" /|   |\" << endl;\n        cout << \"      |\" << endl;\n        cout << \"      |\" << endl;\n        cout << \"=========\" << endl;\n        break;\n    case 2:\n        cout << \"  +---+\" << endl;\n        cout << \"  |   |\" << endl;\n        cout << \"  O   |\" << endl;\n        cout << \" /|\\\\  |\" << endl;\n        cout << \"      |\" << endl;\n        cout << \"      |\" << endl;\n        cout << \"=========\" << endl;\n        break;\n    case 1:\n        cout << \"  +---+\" << endl;\n        cout << \"  |   |\" << endl;\n        cout << \"  O   |\" << endl;\n        cout << \" /|\\\\  |\" << endl;\n        cout << \" /    |\" << endl;\n        cout << \"      |\" << endl;\n        cout << \"=========\" << endl;\n        break;\n    case 0:\n        cout << \"  +---+\" << endl;\n        cout << \"  |   |\" << endl;\n        cout << \"  O   |\" << endl;\n        cout << \" /|\\\\  |\" << endl;\n        cout << \" / \\\\  |\" << endl;\n        cout << \"      |\" << endl;\n        cout << \"=========\" << endl;\n        break;\n    }\n}\n\u0005End File\u0006# vsid01/Nebulo\n# game.cpp\n/*\n    CSCI1300 - Fall 2023\n    Author: Vincent Dong\n    Recitation: 308 - Aria Ellett\n    Project 3 - Game Class\n*/\n\n#include \"game.h\"\n#include <fstream>\n#include <iostream>\n#include <string>\n#include <algorithm>\n#include <cctype>\n#include <vector>\n\nusing namespace std;\n\n/**\n * Default constructor for the Game class.\n * Initializes a new Game object with default settings.\n */\nGame::Game() : score_(0), current_game_mode_(\"\"), wordbank_filename_(\"wordbank.txt\")\n{\n    players_.resize(0);\n    current_player_ = nullptr;\n}\n\n/**\n * Parameterized constructor for the Game class.\n * Initializes a new Game object with the specified wordbank filename.\n * @param wordbank_filename The filename for the wordbank file to be used in the game.\n */\nGame::Game(const string &wordbank_filename) : score_(0), current_game_mode_(\"\"), wordbank_filename_(wordbank_filename)\n{\n    players_.resize(0);\n    current_player_ = nullptr;\n}\n\n/**\n * Getter method for the current score.\n * @return An integer representing the current score.\n */\nint Game::getScore() const\n{\n    return score_;\n}\n\n/**\n * Getter method for the current game mode.\n * @return A string representing the current game mode.\n */\nstring Game::getCurrentGameMode() const\n{\n    return current_game_mode_;\n}\n\n/**\n * Getter method for the wordbank filename.\n * @return A string representing the wordbank filename.\n */\nstring Game::getWordbankFilename() const\n{\n    return wordbank_filename_;\n}\n\n/**\n * Getter method for the vector of players.\n * @return A vector of Player objects.\n */\nvector<Player> Game::getPlayers() const\n{\n    return players_;\n}\n\n/**\n * Getter method for the current player.\n * @return A pointer to the current Player object.\n */\nPlayer *Game::getCurrentPlayer() const\n{\n    return current_player_;\n}\n\n/**\n * Setter method for the score.\n * @param score An integer representing the new score value.\n */\nvoid Game::setScore(const int score)\n{\n    score_ = score;\n}\n\n/**\n * Setter method for the current game mode.\n * @param mode A string representing the new game mode.\n */\nvoid Game::setCurrentGameMode(const string &mode)\n{\n    current_game_mode_ = mode;\n}\n\n/**\n * Setter method for the wordbank filename.\n * @param filename A string representing the new wordbank filename.\n */\nvoid Game::setWordbankFilename(const string &filename)\n{\n    wordbank_filename_ = filename;\n}\n\n/**\n * Setter method for the current player.\n * @param player A pointer to the Player object to set as current.\n */\nvoid Game::setCurrentPlayer(Player *player)\n{\n    current_player_ = player;\n}\n\n/**\n * Increases the score by the specified amount.\n * @param points An integer representing the points to add to the score.\n */\nvoid Game::addScore(const int points)\n{\n    score_ += points;\n}\n\n/**\n * Resets the score to zero.\n */\nvoid Game::resetScore()\n{\n    score_ = 0;\n}\n\n/**\n * Adds a new player to the game.\n * @param player The Player object to add.\n * @return True if the player was successfully added, false otherwise.\n */\nbool Game::addPlayer(const Player &player)\n{\n    // Check if a player with the same username already exists\n    for (const Player &p : players_)\n    {\n        if (p.getUsername() == player.getUsername())\n        {\n            return false; // Player with this username already exists\n        }\n    }\n\n    // Add the new player\n    players_.push_back(player);\n    return true;\n}\n\n/**\n * Removes a player from the game.\n * @param username The username of the player to remove.\n * @return True if the player was successfully removed, false otherwise.\n */\nbool Game::removePlayer(const string &username)\n{\n    for (auto it = players_.begin(); it != players_.end(); ++it)\n    {\n        if (it->getUsername() == username)\n        {\n            // If this is the current player, set current_player_ to nullptr\n            if (current_player_ != nullptr && current_player_->getUsername() == username)\n            {\n                current_player_ = nullptr;\n            }\n\n            players_.erase(it);\n            return true;\n        }\n    }\n    return false; // Player not found\n}\n\n/**\n * Finds a player by username.\n * @param username The username of the player to find.\n * @return A pointer to the Player object if found, nullptr otherwise.\n */\nPlayer *Game::findPlayer(const string &username)\n{\n    for (auto &player : players_)\n    {\n        if (player.getUsername() == username)\n        {\n            return &player;\n        }\n    }\n    return nullptr; // Player not found\n}\n\n/**\n * Sorts the players by their scores in descending order.\n */\nvoid Game::sortPlayersByScore()\n{\n    sort(players_.begin(), players_.end(), [](const Player &a, const Player &b)\n         { return a.getHighScore() > b.getHighScore(); });\n}\n\n/**\n * Displays the leaderboard showing player rankings by score.\n */\nvoid Game::displayLeaderboard() const\n{\n    if (players_.empty())\n    {\n        cout << \"No players in the leaderboard yet.\" << endl;\n        return;\n    }\n\n    cout << \"===== LEADERBOARD =====\" << endl;\n    for (size_t i = 0; i < players_.size(); i++)\n    {\n        cout << (i + 1) << \". \" << players_[i].getUsername() << \" - \" << players_[i].getHighScore() << \" points\" << endl;\n    }\n    cout << \"=======================\" << endl;\n}\n\n/**\n * Loads player data from a file.\n * @param filename The name of the file to load player data from.\n * @return True if the data was successfully loaded, false otherwise.\n */\nbool Game::loadPlayerData(const string &filename)\n{\n    ifstream file(filename);\n    if (!file.is_open())\n    {\n        return false;\n    }\n\n    players_.clear(); // Clear existing players\n    string line;\n    while (getline(file, line))\n    {\n        // Parse the line\n        size_t comma_pos = line.find(',');\n        if (comma_pos == string::npos)\n        {\n            continue; // Skip invalid lines\n        }\n\n        string username = line.substr(0, comma_pos);\n        string score_str = line.substr(comma_pos + 1);\n\n        // Convert score to integer\n        int score;\n        try\n        {\n            score = stoi(score_str);\n        }\n        catch (const exception &e)\n        {\n            continue; // Skip invalid scores\n        }\n\n        // Create and add player\n        Player player(username, score);\n        players_.push_back(player);\n    }\n\n    file.close();\n    return true;\n}\n\n/**\n * Saves player data to a file.\n * @param filename The name of the file to save player data to.\n * @return True if the data was successfully saved, false otherwise.\n */\nbool Game::savePlayerData(const string &filename) const\n{\n    ofstream file(filename);\n    if (!file.is_open())\n    {\n        return false;\n    }\n\n    for (const Player &player : players_)\n    {\n        file << player.getUsername() << \",\" << player.getHighScore() << endl;\n    }\n\n    file.close();\n    return true;\n}\n\n/**\n * Loads a wordbank from a file into a vector of strings.\n * @param filename The name of the file to load the wordbank from.\n * @return A vector of strings containing the words from the wordbank.\n */\nvector<string> Game::loadWordbank(const string &filename) const\n{\n    vector<string> words;\n    ifstream file(filename);\n\n    if (file.is_open())\n    {\n        string word;\n        while (getline(file, word))\n        {\n            // Trim whitespace and skip empty lines\n            word.erase(word.begin(), find_if(word.begin(), word.end(), [](unsigned char ch)\n                                            { return !isspace(ch); }));\n            word.erase(find_if(word.rbegin(), word.rend(), [](unsigned char ch)\n                              { return !isspace(ch); })\n                           .base(),\n                      word.end());\n\n            if (!word.empty())\n            {\n                words.push_back(word);\n            }\n        }\n        file.close();\n    }\n\n    return words;\n}\n\n/**\n * Updates the current player's high score if the current score is higher.\n * @return True if the high score was updated, false otherwise.\n */\nbool Game::updateHighScore()\n{\n    if (current_player_ == nullptr)\n    {\n        return false;\n    }\n\n    if (score_ > current_player_->getHighScore())\n    {\n        current_player_->setHighScore(score_);\n        return true;\n    }\n    return false;\n}\n\n/**\n * Loads words from a file based on a specified category.\n * @param filename The name of the file to load words from.\n * @param category The category of words to filter by.\n * @return A vector of strings containing words from the specified category.\n */\nvector<string> Game::loadWordsByCategory(const string &filename, const string &category) const\n{\n    vector<string> words;\n    ifstream file(filename);\n\n    if (file.is_open())\n    {\n        string line;\n        while (getline(file, line))\n        {\n            // Check if the line starts with the category\n            if (line.substr(0, category.length()) == category && line.length() > category.length() && line[category.length()] == ':')\n            {\n                // Extract the word after the category and colon\n                string word = line.substr(category.length() + 1);\n                // Trim whitespace\n                word.erase(word.begin(), find_if(word.begin(), word.end(), [](unsigned char ch)\n                                                { return !isspace(ch); }));\n                word.erase(find_if(word.rbegin(), word.rend(), [](unsigned char ch)\n                                  { return !isspace(ch); })\n                               .base(),\n                          word.end());\n\n                if (!word.empty())\n                {\n                    words.push_back(word);\n                }\n            }\n        }\n        file.close();\n    }\n\n    return words;\n}\n\n/**\n * Gets a list of all available categories from the wordbank file.\n * @param filename The name of the file to extract categories from.\n * @return A vector of strings containing all available categories.\n */\nvector<string> Game::getCategories(const string &filename) const\n{\n    vector<string> categories;\n    ifstream file(filename);\n\n    if (file.is_open())\n    {\n        string line;\n        while (getline(file, line))\n        {\n            size_t colon_pos = line.find(':');\n            if (colon_pos != string::npos)\n            {\n                string category = line.substr(0, colon_pos);\n                // Check if category is already in the list\n                if (find(categories.begin(), categories.end(), category) == categories.end())\n                {\n                    categories.push_back(category);\n                }\n            }\n        }\n        file.close();\n    }\n\n    return categories;\n}\n\u0005End File\u0006# vsid01/Nebulo\n/*\n    CSCI1300 - Fall 2023\n    Author: Vincent Dong\n    Recitation: 308 - Aria Ellett\n    Project 3 - Word Scramble Class\n*/\n\n#include \"wordscramble.h\"\n#include <vector>\n#include <iostream>\n#include <string>\n#include <algorithm>\n#include <cctype>\n#include <cstdlib>\n#include <ctime>\n#include <random>\nusing namespace std;\n\n/**\n * Default constructor for the WordScramble class.\n * Initializes a new WordScramble object with default settings.\n */\nWordScramble::WordScramble() : original_word_(\"\"), scrambled_word_(\"\"), guesses_remaining_(3), has_won_(false), hint_used_(false)\n{\n}\n\n/**\n * Getter method for the original (unscrambled) word.\n * @return A string representing the original word.\n */\nstring WordScramble::getOriginalWord() const\n{\n    return original_word_;\n}\n\n/**\n * Getter method for the scrambled version of the word.\n * @return A string representing the scrambled word.\n */\nstring WordScramble::getScrambledWord() const\n{\n    return scrambled_word_;\n}\n\n/**\n * Getter method for the number of guesses remaining.\n * @return An integer representing the number of guesses left.\n */\nint WordScramble::getGuessesRemaining() const\n{\n    return guesses_remaining_;\n}\n\n/**\n * Getter method for whether the player has won the game.\n * @return A boolean indicating whether the game has been won (true) or is still in progress/lost (false).\n */\nbool WordScramble::getHasWon() const\n{\n    return has_won_;\n}\n\n/**\n * Getter method for whether the hint feature has been used in this game.\n * @return A boolean indicating whether the hint has been used (true) or not (false).\n */\nbool WordScramble::getHintUsed() const\n{\n    return hint_used_;\n}\n\n/**\n * Sets the original (unscrambled) word.\n * @param word A string representing the new original word.\n */\nvoid WordScramble::setOriginalWord(const string word)\n{\n    original_word_ = word;\n}\n\n/**\n * Sets the scrambled version of the word.\n * @param word A string representing the new scrambled word.\n */\nvoid WordScramble::setScrambledWord(const string word)\n{\n    scrambled_word_ = word;\n}\n\n/**\n * Sets the number of guesses remaining.\n * @param guesses An integer representing the new number of guesses remaining.\n */\nvoid WordScramble::setGuessesRemaining(const int guesses)\n{\n    guesses_remaining_ = guesses;\n}\n\n/**\n * Sets whether the player has won the game.\n * @param has_won A boolean indicating the new game status.\n */\nvoid WordScramble::setHasWon(const bool has_won)\n{\n    has_won_ = has_won;\n}\n\n/**\n * Sets whether the hint feature has been used in this game.\n * @param hint_used A boolean indicating the new hint usage status.\n */\nvoid WordScramble::setHintUsed(const bool hint_used)\n{\n    hint_used_ = hint_used;\n}\n\n/**\n * Resets the game state for a new round.\n * This includes resetting the guesses remaining, game status, and hint usage.\n */\nvoid WordScramble::resetGame()\n{\n    guesses_remaining_ = 3;\n    has_won_ = false;\n    hint_used_ = false;\n}\n\n/**\n * Sets up a new WordScramble game with a random word from the given vector.\n * @param words A vector of strings containing possible words for the game.\n * @return True if the game was successfully set up, false otherwise.\n */\nbool WordScramble::setupGame(const vector<string> &words)\n{\n    if (words.empty())\n    {\n        return false;\n    }\n\n    // Reset game state\n    resetGame();\n\n    // Generate a random number between 0 and the size of the words vector\n    srand(static_cast<unsigned int>(time(nullptr)));\n    int random_index = rand() % words.size();\n\n    // Get a random word from the vector\n    string random_word = words[random_index];\n\n    // Set the original word\n    setOriginalWord(random_word);\n\n    // Generate the scrambled version of the word\n    string scrambled = random_word;\n    // Create a random device and generator for better randomization\n    random_device rd;\n    mt19937 g(rd());\n    // Shuffle the characters in the word\n    shuffle(scrambled.begin(), scrambled.end(), g);\n\n    // Ensure the scrambled word is different from the original\n    while (scrambled == random_word && random_word.length() > 1)\n    {\n        shuffle(scrambled.begin(), scrambled.end(), g);\n    }\n\n    setScrambledWord(scrambled);\n\n    return true;\n}\n\n/**\n * Checks if the player's guess matches the original word.\n * @param guess A string representing the player's guess.\n * @return True if the guess is correct, false otherwise.\n */\nbool WordScramble::checkGuess(const string &guess)\n{\n    if (guesses_remaining_ <= 0 || has_won_)\n    {\n        return false; // Game is already over\n    }\n\n    if (guess == original_word_)\n    {\n        has_won_ = true;\n        return true;\n    }\n    else\n    {\n        guesses_remaining_--;\n        return false;\n    }\n}\n\n/**\n * Provides a hint to the player by revealing the first few letters of the original word.\n * @return A string containing the hint (first few letters of the original word).\n */\nstring WordScramble::getHint()\n{\n    if (hint_used_ || has_won_ || guesses_remaining_ <= 0 || original_word_.length() <= 1)\n    {\n        return \"\"; // No hint available or already used\n    }\n\n    // Reveal the first 1/3 of the word as a hint (at least 1 letter)\n    int hint_length = max(1, static_cast<int>(original_word_.length() / 3));\n    string hint = original_word_.substr(0, hint_length);\n\n    // Mark hint as used\n    hint_used_ = true;\n\n    return hint;\n}\n\u0005End File\u0006# game.h\n/*\n    CSCI1300 - Fall 2023\n    Author: Vincent Dong\n    Recitation: 308 - Aria Ellett\n    Project 3 - Game Class\n*/\n\n#ifndef GAME_H\n#define GAME_H\n\n#include \"player.h\"\n#include <string>\n#include <vector>\n\nusing namespace std;\n\nclass Game\n{\nprivate:\n    int score_;                  // Current game score\n    string current_game_mode_;   // Current game mode (e.g., \"hangman\", \"wordscramble\")\n    string wordbank_filename_;   // Filename for the wordbank\n    vector<Player> players_;     // Vector of Player objects\n    Player *current_player_;     // Pointer to the current player\n\npublic:\n    // Constructors\n    Game();\n    Game(const string &wordbank_filename);\n\n    // Getters\n    int getScore() const;\n    string getCurrentGameMode() const;\n    string getWordbankFilename() const;\n    vector<Player> getPlayers() const;\n    Player *getCurrentPlayer() const;\n\n    // Setters\n    void setScore(const int score);\n    void setCurrentGameMode(const string &mode);\n    void setWordbankFilename(const string &filename);\n    void setCurrentPlayer(Player *player);\n\n    // Score management\n    void addScore(const int points);\n    void resetScore();\n\n    // Player management\n    bool addPlayer(const Player &player);\n    bool removePlayer(const string &username);\n    Player *findPlayer(const string &username);\n    void sortPlayersByScore();\n    void displayLeaderboard() const;\n\n    // Data management\n    bool loadPlayerData(const string &filename);\n    bool savePlayerData(const string &filename) const;\n    vector<string> loadWordbank(const string &filename) const;\n    bool updateHighScore();\n\n    // Category management\n    vector<string> loadWordsByCategory(const string &filename, const string &category) const;\n    vector<string> getCategories(const string &filename) const;\n};\n\n#endif\n\u0005End File\u0006# vsid01/Nebulo\n# hangman.h\n/*\n    CSCI1300 - Fall 2023\n    Author: Vincent Dong\n    Recitation: 308 - Aria Ellett\n    Project 3 - Hangman Class\n*/\n\n#ifndef HANGMAN_H\n#define HANGMAN_H\n\n#include <string>\n#include <vector>\n\nusing namespace std;\n\nclass Hangman\n{\nprivate:\n    string category_;          // Category of the word\n    string word_;              // Word to guess\n    string guessed_letters_;   // Letters that have been guessed\n    string display_word_;      // Word with guessed letters revealed and unguessed letters hidden\n    int guesses_remaining_;    // Number of incorrect guesses remaining\n    bool has_won_;             // Whether the player has won\n\npublic:\n    // Constructor\n    Hangman();\n\n    // Getters\n    string getCategory() const;\n    string getWord() const;\n    string getGuessedLetters() const;\n    string getDisplayWord() const;\n    int getGuessesRemaining() const;\n    bool getHasWon() const;\n\n    // Setters\n    void setCategory(const string category);\n    void setWord(const string word);\n    void setGuessedLetters(const string guessed_letters);\n    void setDisplayWord(const string display_word);\n    void setGuessesRemaining(const int guesses_remaining);\n    void setHasWon(const bool has_won);\n\n    // Game functionality\n    void resetGame();\n    bool setupGame(const vector<string> &words, string category);\n    bool makeGuess(char guess);\n    void displayHangman() const;\n\n    // Difficulty helpers\n    static vector<string> getWordsByDifficulty(const vector<string> &words, const string &difficulty);\n};\n\n#endif\n\u0000/*\n * Jitsi, the OpenSource Java VoIP and Instant Messaging client.\n * \n * Distributable under LGPL license. See terms of license at gnu.org.\n */\npackage org.jitsi.service.contactsource;\n\nimport java.util.*;\n\n/**\n * The <tt>ContactSourceService</tt> interface is meant to be implemented by\n * modules supporting contact sources in Jitsi such as LDAP, Outlook, MacOSX,\n * etc.\n *\n * @author Yana Stamcheva\n */\npublic interface ContactSourceService\n{\n    /**\n     * Type of a default source.\n     */\n    public static final int DEFAULT_TYPE = 0;\n\n    /**\n     * Type of the contact source search which can be stopped.\n     */\n    public static final int STOPPABLE_TYPE = 1;\n\n    /**\n     * Returns the type of this contact source.\n     *\n     * @return the type of this contact source\n     */\n    public int getType();\n\n    /**\n     * Returns a user-friendly string that identifies this contact source.\n     *\n     * @return the display name of this contact source\n     */\n    public String getDisplayName();\n\n    /**\n     * Creates query for the given <tt>searchPattern</tt>.\n     *\n     * @param queryPattern the pattern to search for\n     * @return the created query\n     */\n    public ContactQuery createContactQuery(String queryPattern);\n\n    /**\n     * Creates query for the given <tt>searchPattern</tt>.\n     *\n     * @param queryPattern the pattern to search for\n     * @param count the maximum count of result contacts\n     * @return the created query\n     */\n    public ContactQuery createContactQuery(String queryPattern, int count);\n\n    /**\n     * Returns the index of the contact source in the result list.\n     *\n     * @return the index of the contact source in the result list\n     */\n    public int getIndex();\n\n    /**\n     * Adds a <tt>ContactSourceListener</tt> to this <tt>ContactSourceService</tt>.\n     *\n     * @param l\n     *            the <tt>ContactSourceListener</tt> to add\n     */\n    public void addContactSourceListener(ContactSourceListener l);\n\n    /**\n     * Removes a <tt>ContactSourceListener</tt> from this <tt>ContactSourceService</tt>.\n     *\n     * @param l\n     *            the <tt>ContactSourceListener</tt> to add\n     */\n    public void removeContactSourceListener(ContactSourceListener l);\n\n    /**\n     * Fires a new <tt>ContactSourceEvent</tt> to indicate that an error has occurred.\n     *\n     * @param source\n     *            the source that triggered this event\n     * @param errorCode\n     *            the error code of the occurred error\n     * @param errorReason\n     *            the reason for the error\n     */\n    public void fireContactSourceErrorEvent(Object source,\n                                         int errorCode,\n                                         String errorReason);\n\n    /**\n     * Notifies all registered <tt>ContactSourceListener</tt>s that an error has occurred.\n     *\n     * @param event\n     *            the <tt>ContactSourceEvent</tt> that has occurred\n     */\n    public void fireContactSourceEvent(ContactSourceEvent event);\n\n    /**\n     * Removes a <tt>ContactSourceListener</tt> from the listener list.\n     *\n     * @param l\n     *            the <tt>ContactSourceListener</tt> to be removed\n     */\n    public void removeContactSource(ContactSourceListener l);\n\n    /**\n     * Returns a list of all registered <tt>ContactSourceListener</tt>s.\n     *\n     * @return a list of all registered <tt>ContactSourceListener</tt>s\n     */\n    public List<ContactSourceListener> getContactSourceListeners();\n}\n\u0005End File\u0006# jitsi/jitsi\n# modules/service/contactsource/src/main/java/org/jitsi/service/contactsource/PrefixedContactSourceService.java\n/*\n * Jitsi, the OpenSource Java VoIP and Instant Messaging client.\n *\n * Copyright @ 2015 Atlassian Pty Ltd\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.jitsi.service.contactsource;\n\nimport java.util.*;\n\n/**\n * Adds a prefix to a contact source service.\n */\npublic class PrefixedContactSourceService\n    implements ContactSourceService\n{\n    /**\n     * The contact source service to be prefixed.\n     */\n    private final ContactSourceService contactSourceService;\n\n    /**\n     * The prefix.\n     */\n    private final String prefix;\n\n    /**\n     * Creates an instance of <tt>PrefixedContactSourceService</tt>.\n     *\n     * @param contactSourceService the contact source service to be prefixed\n     * @param prefix the prefix\n     */\n    public PrefixedContactSourceService(\n            ContactSourceService contactSourceService,\n            String prefix)\n    {\n        this.contactSourceService = contactSourceService;\n        this.prefix = prefix;\n    }\n\n    /**\n     * Returns the type of this contact source.\n     *\n     * @return the type of this contact source\n     */\n    public int getType()\n    {\n        return contactSourceService.getType();\n    }\n\n    /**\n     * Returns a user-friendly string that identifies this contact source.\n     *\n     * @return the display name of this contact source\n     */\n    public String getDisplayName()\n    {\n        return prefix + contactSourceService.getDisplayName();\n    }\n\n    /**\n     * Creates query for the given <tt>searchPattern</tt>.\n     *\n     * @param queryPattern the pattern to search for\n     * @return the created query\n     */\n    public ContactQuery createContactQuery(String queryPattern)\n    {\n        return contactSourceService.createContactQuery(queryPattern);\n    }\n\n    /**\n     * Creates query for the given <tt>searchPattern</tt>.\n     *\n     * @param queryPattern the pattern to search for\n     * @param count the maximum count of result contacts\n     * @return the created query\n     */\n    public ContactQuery createContactQuery(String queryPattern, int count)\n    {\n        return contactSourceService.createContactQuery(queryPattern, count);\n    }\n\n    /**\n     * Returns the index of the contact source in the result list.\n     *\n     * @return the index of the contact source in the result list\n     */\n    public int getIndex()\n    {\n        return contactSourceService.getIndex();\n    }\n\n    /**\n     * Adds a <tt>ContactSourceListener</tt> to this <tt>ContactSourceService</tt>.\n     *\n     * @param l the <tt>ContactSourceListener</tt> to add\n     */\n    @Override\n    public void addContactSourceListener(ContactSourceListener l)\n    {\n        contactSourceService.addContactSourceListener(l);\n    }\n\n    /**\n     * Removes a <tt>ContactSourceListener</tt> from this <tt>ContactSourceService</tt>.\n     *\n     * @param l the <tt>ContactSourceListener</tt> to add\n     */\n    @Override\n    public void removeContactSourceListener(ContactSourceListener l)\n    {\n        contactSourceService.removeContactSourceListener(l);\n    }\n\n    /**\n     * Fires a new <tt>ContactSourceEvent</tt> to indicate that an error has occurred.\n     *\n     * @param source the source that triggered this event\n     * @param errorCode the error code of the occurred error\n     * @param errorReason the reason for the error\n     */\n    @Override\n    public void fireContactSourceErrorEvent(Object source,\n                                     int errorCode,\n                                     String errorReason)\n    {\n        contactSourceService.fireContactSourceErrorEvent(\n            source, errorCode, errorReason);\n    }\n\n    /**\n     * Notifies all registered <tt>ContactSourceListener</tt>s that an error has occurred.\n     *\n     * @param event the <tt>ContactSourceEvent</tt> that has occurred\n     */\n    @Override\n    public void fireContactSourceEvent(ContactSourceEvent event)\n    {\n        contactSourceService.fireContactSourceEvent(event);\n    }\n\n    /**\n     * Removes a <tt>ContactSourceListener</tt> from the listener list.\n     *\n     * @param l the <tt>ContactSourceListener</tt> to be removed\n     */\n    @Override\n    public void removeContactSource(ContactSourceListener l)\n    {\n        contactSourceService.removeContactSource(l);\n    }\n\n    /**\n     * Returns a list of all registered <tt>ContactSourceListener</tt>s.\n     *\n     * @return a list of all registered <tt>ContactSourceListener</tt>s\n     */\n    @Override\n    public List<ContactSourceListener> getContactSourceListeners()\n    {\n        return contactSourceService.getContactSourceListeners();\n    }\n}\n\u0005End File\u0006# jitsi/jitsi\n/*\n * Jitsi, the OpenSource Java VoIP and Instant Messaging client.\n *\n * Copyright @ 2015 Atlassian Pty Ltd\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.jitsi.service.contactsource;\n\nimport java.util.*;\n\n/**\n * The <tt>AsyncContactSourceService</tt> enables creating an asynchronous query\n * that runs in a separate thread.\n *\n * @author Yana Stamcheva\n */\npublic interface AsyncContactSourceService\n    extends ContactSourceService\n{\n    /**\n     * Type of a video source.\n     */\n    public static final int VIDEO_TYPE = 3;\n\n    /**\n     * Type of a source that we disable for some reason (e.g. temporarily\n     * disabled external contact sources).\n     */\n    public static final int DISABLED_TYPE = 4;\n\n    /**\n     * Creates a <tt>ContactQuery</tt> which is to perform an asynchronous query\n     * in a separate thread.\n     *\n     * @param queryString the string to search for\n     * @param contactCount the maximum count of result contacts\n     * @return the created <tt>ContactQuery</tt>\n     */\n    public ContactQuery createAsyncContactQuery(\n        String queryString,\n        int contactCount)\n        throws ContactSourceException;\n\n    /**\n     * Creates a <tt>ContactQuery</tt> which is to perform an asynchronous query\n     * in a separate thread.\n     *\n     * @param queryString the string to search for\n     * @return the created <tt>ContactQuery</tt>\n     */\n    public ContactQuery createAsyncContactQuery(String queryString)\n        throws ContactSourceException;\n\n    /**\n     * Adds a <tt>ContactQueryListener</tt> to the list of query listeners.\n     *\n     * @param l the <tt>ContactQueryListener</tt> to add\n     */\n    public void addContactQueryListener(ContactQueryListener l);\n\n    /**\n     * Removes a <tt>ContactQueryListener</tt> from the list of query listeners.\n     *\n     * @param l the <tt>ContactQueryListener</tt> to remove\n     */\n    public void removeContactQueryListener(ContactQueryListener l);\n}\n\u0005End File\u0006# jitsi/jitsi\n/*\n * Jitsi, the OpenSource Java VoIP and Instant Messaging client.\n *\n * Copyright @ 2015 Atlassian Pty Ltd\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.jitsi.service.contactsource;\n\nimport java.util.*;\n\n/**\n * The <tt>ContactDetail</tt> is a detail of a <tt>SourceContact</tt>\n * corresponding to a specific address (phone number, email, identifier, etc.),\n * which defines the different possible types of communication and the preferred\n * <tt>ProtocolProviderService</tt>s to go through.\n *\n * @author Yana Stamcheva\n */\npublic abstract class ContactDetail\n{\n    /**\n     * The category of a <tt>ContactDetail</tt>.\n     */\n    public enum Category\n    {\n        /**\n         * The standard category.\n         */\n        Standard,\n\n        /**\n         * The personal category.\n         */\n        Personal,\n\n        /**\n         * The organization category.\n         */\n        Organization,\n\n        /**\n         * The additional category.\n         */\n        Additional,\n\n        /**\n         * An undefined category.\n         */\n        Other\n    }\n\n    /**\n     * The sub-categories for a standard category.\n     */\n    public enum SubCategory\n    {\n        /**\n         * The name sub-category of a standard category.\n         */\n        Name,\n\n        /**\n         * The display name sub-category of a standard category.\n         */\n        DisplayName,\n\n        /**\n         * The given name sub-category of a standard category.\n         */\n        FirstName,\n\n        /**\n         * The middle name sub-category of a standard category.\n         */\n        MiddleName,\n\n        /**\n         * The surname sub-category of a standard category.\n         */\n        LastName,\n\n        /**\n         * The nickname sub-category of a standard category.\n         */\n        Nickname,\n\n        /**\n         * The postal address sub-category of a standard category.\n         */\n        PostalAddress,\n\n        /**\n         * The phone number sub-category of a standard category.\n         */\n        Phone,\n\n        /**\n         * The email sub-category of a standard category.\n         */\n        Email,\n\n        /**\n         * The web address sub-category of a standard category.\n         */\n        WebPage,\n\n        /**\n         * The description sub-category of a standard category.\n         */\n        Description,\n\n        /**\n         * The avatar sub-category of a standard category.\n         */\n        Avatar,\n\n        /**\n         * The birthday sub-category of a standard category.\n         */\n        Birthday,\n\n        /**\n         * The gender sub-category of a standard category.\n         */\n        Gender,\n\n        /**\n         * The instante messenger sub-category of a standard category.\n         */\n        InstantMessenger,\n\n        /**\n         * The preferred sub-category. This sub-category is used only to store\n         * a list of preferred details.\n         */\n        Preferred,\n\n        /**\n         * The video sub-category.\n         */\n        Video,\n\n        /**\n         * A work phone sub-category of a standard category.\n         */\n        WorkPhone,\n\n        /**\n         * A mobile phone sub-category of a standard category.\n         */\n        MobilePhone,\n\n        /**\n         * A home phone sub-category of a standard category.\n         */\n        HomePhone,\n\n        /**\n         * A fax sub-category of a standard category.\n         */\n        Fax,\n\n        /**\n         * A contact address sub-category of a standard category.\n         */\n        ContactAddress,\n\n        /**\n         * A video sub-category of a standard category.\n         */\n        VideoPrefix,\n\n        /**\n         * An undefined sub-category of a standard category.\n         */\n        Other\n    }\n\n    /**\n     * The address of this detail.\n     */\n    private final String address;\n\n    /**\n     * The category of the detail.\n     */\n    private final Category category;\n\n    /**\n     * The sub-category of the detail.\n     */\n    private final Collection<SubCategory> subCategories;\n\n    /**\n     * A mapping from a contact address to the corresponding contact detail.\n     */\n    private Map<Class<? extends OperationSet>, List<String>>\n        preferredProviders = null;\n\n    /**\n     * A mapping from a contact address to the corresponding contact detail.\n     */\n    private Map<Class<? extends OperationSet>, List<String>>\n        preferredProtocols = null;\n\n    /**\n     * A list of all supported operation sets.\n     */\n    private List<Class<? extends OperationSet>>\n        supportedOpSets = null;\n\n    /**\n     * The persistent data of this detail.\n     */\n    private Object persistentData;\n\n    /**\n     * The display name of this detail.\n     */\n    private String detailDisplayName;\n\n    /**\n     * The label of this detail.\n     */\n    private String detailLabel;\n\n    /**\n     * The map of custom values.\n     */\n    private Map<Object, Object> customValues = null;\n\n    /**\n     * Creates a <tt>ContactDetail</tt> by specifying the contact address,\n     * corresponding to this detail.\n     * @param address the contact address corresponding to this detail\n     */\n    public ContactDetail(String address)\n    {\n        this(address, null, null);\n    }\n\n    /**\n     * Creates a <tt>ContactDetail</tt> by specifying the contact address,\n     * corresponding to this detail.\n     * @param address the contact address corresponding to this detail\n     * @param detailDisplayName the display name of this detail\n     */\n    public ContactDetail(String address, String detailDisplayName)\n    {\n        this(address, Category.Other, null, detailDisplayName);\n    }\n\n    /**\n     * Creates a <tt>ContactDetail</tt> by specifying the contact address,\n     * corresponding to this detail.\n     * @param address the contact address corresponding to this detail\n     * @param category the category of the detail\n     * @param subCategories the sub-categories of the detail\n     */\n    public ContactDetail(String address,\n                         Category category,\n                         Collection<SubCategory> subCategories)\n    {\n        this(address, category, subCategories, null);\n    }\n\n    /**\n     * Creates a <tt>ContactDetail</tt> by specifying the contact address,\n     * corresponding to this detail.\n     * @param address the contact address corresponding to this detail\n     * @param category the category of the detail\n     * @param subCategories the sub-categories of the detail\n     * @param detailDisplayName the display name of this detail\n     */\n    public ContactDetail(String address,\n                         Category category,\n                         Collection<SubCategory> subCategories,\n                         String detailDisplayName)\n    {\n        this.address = address;\n        this.category = category;\n        this.subCategories = subCategories;\n        this.detailDisplayName = detailDisplayName;\n    }\n\n    /**\n     * Sets a custom value for the given key.\n     *\n     * @param key the key of the value\n     * @param value the value to set\n     */\n    public void setCustomValue(Object key, Object value)\n    {\n        if (customValues == null)\n            customValues = new HashMap<>();\n\n        customValues.put(key, value);\n    }\n\n    /**\n     * Gets the custom value for the given key.\n     *\n     * @param key the key of the value\n     * @return the value to set\n     */\n    public Object getCustomValue(Object key)\n    {\n        if (customValues == null)\n            return null;\n\n        return customValues.get(key);\n    }\n\n    /**\n     * Returns the persistent data of this detail.\n     *\n     * @return the persistent data of this detail\n     */\n    public Object getPersistentData()\n    {\n        return persistentData;\n    }\n\n    /**\n     * Sets the persistent data of this detail.\n     *\n     * @param persistentData the persistent data of this detail\n     */\n    public void setPersistentData(Object persistentData)\n    {\n        this.persistentData = persistentData;\n    }\n\n    /**\n     * Returns the display name of this detail. For example this could be \"Home\n     * phone\", \"Work phone\", etc.\n     *\n     * @return the display name of this detail\n     */\n    public String getDetailDisplayName()\n    {\n        return detailDisplayName;\n    }\n\n    /**\n     * Sets the display name of this detail.\n     *\n     * @param detailDisplayName the display name of this detail\n     */\n    public void setDetailDisplayName(String detailDisplayName)\n    {\n        this.detailDisplayName = detailDisplayName;\n    }\n\n    /**\n     * Returns the detail label. The detail label identifies this detail in the\n     * associated source contact. For example, if one wants to have two different\n     * detail values associated to the same detail type (category and\n     * sub-category), a different label for each one of them could be specified\n     * to differentiate them.\n     *\n     * @return the detail label identifying this detail in the containing\n     * source contact\n     */\n    public String getDetailLabel()\n    {\n        return detailLabel;\n    }\n\n    /**\n     * Sets the detail label.\n     *\n     * @param detailLabel the detail label to set\n     */\n    public void setDetailLabel(String detailLabel)\n    {\n        this.detailLabel = detailLabel;\n    }\n\n    /**\n     * Returns the contact address corresponding to this detail.\n     * @return the contact address corresponding to this detail\n     */\n    public String getDetail()\n    {\n        return address;\n    }\n\n    /**\n     * Returns the category of this detail.\n     *\n     * @return the category of this detail\n     */\n    public Category getCategory()\n    {\n        return category;\n    }\n\n    /**\n     * Returns the sub categories of this detail.\n     *\n     * @return the sub categories of this detail\n     */\n    public Collection<SubCategory> getSubCategories()\n    {\n        return subCategories;\n    }\n\n    /**\n     * Returns a list of all supported <tt>OperationSet</tt> classes, which\n     * could be used when communicating with this <tt>ContactDetail</tt>.\n     * @return a list of all supported <tt>OperationSet</tt> classes\n     */\n    public List<Class<? extends OperationSet>> getSupportedOperationSets()\n    {\n        return supportedOpSets;\n    }\n\n    /**\n     * Sets the list of all supported <tt>OperationSet</tt> classes, which could\n     * be used when communicating with this <tt>ContactDetail</tt>.\n     * @param supportedOpSets the list of supported operation sets to set\n     */\n    public void setSupportedOperationSets(\n        List<Class<? extends OperationSet>> supportedOpSets)\n    {\n        this.supportedOpSets = supportedOpSets;\n    }\n\n    /**\n     * Returns a list of preferred providers for a given <tt>OperationSet</tt>\n     * class. The list is ordered by provider preference.\n     * @param opSetClass the <tt>OperationSet</tt> class, which preferred\n     * providers we're looking for\n     * @return a list of preferred providers for a given <tt>OperationSet</tt>\n     * class\n     */\n    public List<String> getPreferredProviders(\n        Class<? extends OperationSet> opSetClass)\n    {\n        if (preferredProviders != null)\n            return preferredProviders.get(opSetClass);\n        return null;\n    }\n\n    /**\n     * Sets a list of preferred providers for a given <tt>OperationSet</tt>\n     * class.\n     * @param opSetClass the <tt>OperationSet</tt> class, which preferred\n     * providers we're setting\n     * @param providers list of preferred providers\n     */\n    public void setPreferredProviders(\n        Class<? extends OperationSet> opSetClass,\n        List<String> providers)\n    {\n        if (preferredProviders == null)\n            preferredProviders\n                = new HashMap<Class<? extends OperationSet>, List<String>>();\n\n        preferredProviders.put(opSetClass, providers);\n    }\n\n    /**\n     * Returns a list of all providers, which are not preferred for a given\n     * <tt>OperationSet</tt> class. The list is ordered by provider preference.\n     * @param opSetClass the <tt>OperationSet</tt> class, which non-preferred\n     * providers we're looking for\n     * @return a list of all providers, which are not preferred for a given\n     * <tt>OperationSet</tt> class\n     */\n    public List<String> getPreferredProtocols(\n        Class<? extends OperationSet> opSetClass)\n    {\n        if (preferredProtocols != null)\n            return preferredProtocols.get(opSetClass);\n        return null;\n    }\n\n    /**\n     * Sets a list of preferred protocols for a given <tt>OperationSet</tt>\n     * class.\n     * @param opSetClass the <tt>OperationSet</tt> class, which preferred\n     * protocols we're setting\n     * @param protocols list of preferred protocols\n     */\n    public void setPreferredProtocols(\n        Class<? extends OperationSet> opSetClass,\n        List<String> protocols)\n    {\n        if (preferredProtocols == null)\n            preferredProtocols\n                = new HashMap<Class<? extends OperationSet>, List<String>>();\n\n        preferredProtocols.put(opSetClass, protocols);\n    }\n\n    /**\n     * Checks if this detail has a sub-category.\n     *\n     * @param subCategory the sub-category to search for\n     * @return <tt>true</tt> if this detail has the specified sub-category,\n     * <tt>false</tt> - otherwise\n     */\n    public boolean containsSubCategory(SubCategory subCategory)\n    {\n        return subCategories != null && subCategories.contains(subCategory);\n    }\n\n    /**\n     * Creates a string representation of this <tt>ContactDetail</tt>.\n     * @return the string representation of this <tt>ContactDetail</tt>.\n     */\n    @Override\n    public String toString()\n    {\n        return address;\n    }\n}\n\u0005End File\u0006/*\n * Jitsi, the OpenSource Java VoIP and Instant Messaging client.\n *\n * Copyright @ 2015 Atlassian Pty Ltd\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.jitsi.service.contactsource;\n\nimport java.awt.image.*;\nimport java.util.*;\n\n/**\n * The <tt>SourceContact</tt> is the result contact of a query to the\n * <tt>ContactSourceService</tt>.\n *\n * @author Yana Stamcheva\n */\npublic abstract class SourceContact\n{\n    /**\n     * The image returned by this source contact.\n     */\n    protected BufferedImage image;\n\n    /**\n     * A list of <tt>ContactDetail</tt>s belonging to this source contact.\n     */\n    protected List<ContactDetail> contactDetails;\n\n    /**\n     * The parent <tt>ContactQuery</tt> containing this result contact.\n     */\n    protected ContactQuery parentQuery;\n\n    /**\n     * The display name of this contact.\n     */\n    protected String displayName;\n\n    /**\n     * The display details of this contact.\n     */\n    protected String displayDetails;\n\n    /**\n     * A list of all source contact properties.\n     */\n    protected Map<Class<?>, Object> contactProperties\n        = new Hashtable<Class<?>, Object>();\n\n    /**\n     * Contact source service.\n     */\n    protected ContactSourceService contactSource;\n\n    /**\n     * Creates an instance of <tt>SourceContact</tt> by specifying the parent\n     * <tt>query</tt>, the <tt>contactDetails</tt> list and the\n     * <tt>displayName</tt>.\n     *\n     * @param query the parent query\n     * @param displayName the display name of the contact\n     * @param contactDetails the list of contact details\n     */\n    public SourceContact(ContactQuery query,\n                        String displayName,\n                        List<ContactDetail> contactDetails)\n    {\n        this.parentQuery = query;\n        this.displayName = displayName;\n        this.contactDetails = contactDetails;\n    }\n\n    /**\n     * Returns the display name of this search contact.\n     *\n     * @return the display name of this search contact\n     */\n    public String getDisplayName()\n    {\n        return displayName;\n    }\n\n    /**\n     * Returns the display details of this search contact. This could be any\n     * important information that should be shown to the user.\n     *\n     * @return the display details of this search contact\n     */\n    public String getDisplayDetails()\n    {\n        return displayDetails;\n    }\n\n    /**\n     * Sets the display details of this search contact.\n     *\n     * @param displayDetails the display details to set\n     */\n    public void setDisplayDetails(String displayDetails)\n    {\n        this.displayDetails = displayDetails;\n    }\n\n    /**\n     * Returns the parent <tt>ContactQuery</tt> containing this result contact.\n     *\n     * @return the parent <tt>ContactQuery</tt> containing this result contact\n     */\n    public ContactQuery getContactQuery()\n    {\n        return parentQuery;\n    }\n\n    /**\n     * Returns the image associated with this contact.\n     *\n     * @return the image associated with this contact\n     */\n    public BufferedImage getImage()\n    {\n        return image;\n    }\n\n    /**\n     * Returns a list containing all <tt>ContactDetail</tt>-s for this contact.\n     * @return a list containing all <tt>ContactDetail</tt>-s for this contact\n     */\n    public List<ContactDetail> getContactDetails()\n    {\n        return new LinkedList<ContactDetail>(contactDetails);\n    }\n\n    /**\n     * Returns a list containing all <tt>ContactDetail</tt>-s corresponding to\n     * the given category.\n     * @param category the <tt>OperationSet</tt> class we're looking for\n     * @return a list of <tt>ContactDetail</tt>-s corresponding to the given\n     * category\n     */\n    public List<ContactDetail> getContactDetails(\n        Class<? extends OperationSet> category)\n    {\n        List<ContactDetail> details = new LinkedList<ContactDetail>();\n\n        for(ContactDetail detail : contactDetails)\n        {\n            if(detail.getSupportedOperationSets().contains(category))\n            {\n                details.add(detail);\n            }\n        }\n        return details;\n    }\n\n    /**\n     * Returns a list containing all <tt>ContactDetail</tt>-s corresponding to\n     * the given category and subcategory.\n     * @param category the <tt>OperationSet</tt> class we're looking for\n     * @param subCategory the <tt>ContactDetail.SubCategory</tt> we're looking\n     * for\n     * @return a list of <tt>ContactDetail</tt>-s corresponding to the given\n     * category and subcategory\n     */\n    public List<ContactDetail> getContactDetails(\n        Class<? extends OperationSet> category,\n        ContactDetail.SubCategory subCategory)\n    {\n        List<ContactDetail> details = new LinkedList<ContactDetail>();\n\n        for(ContactDetail detail : getContactDetails(category))\n        {\n            if(detail.getSubCategories() != null\n                && detail.getSubCategories().contains(subCategory))\n            {\n                details.add(detail);\n            }\n        }\n        return details;\n    }\n\n    /**\n     * Returns the preferred <tt>ContactDetail</tt> for a given\n     * <tt>OperationSet</tt> class.\n     * @param operationSet the <tt>OperationSet</tt> class, for which we would\n     * like to obtain a <tt>ContactDetail</tt>\n     * @return the preferred <tt>ContactDetail</tt> for a given\n     * <tt>OperationSet</tt> class\n     */\n    public ContactDetail getPreferredContactDetail(\n        Class<? extends OperationSet> operationSet)\n    {\n        List<ContactDetail> details = getContactDetails(operationSet);\n\n        if (details != null && !details.isEmpty())\n            return details.get(0);\n        return null;\n    }\n\n    /**\n     * Sets a property to this source contact.\n     *\n     * @param property the property class to set\n     * @param value the value of the property\n     */\n    public void setData(Class<?> property, Object value)\n    {\n        contactProperties.put(property, value);\n    }\n\n    /**\n     * Returns the value of the property.\n     *\n     * @param property the property, which value we're looking for\n     * @return the value of the property\n     */\n    public Object getData(Class<?> property)\n    {\n        return contactProperties.get(property);\n    }\n\n    /**\n     * Returns the source contact instance that this contact is created of.\n     *\n     * @return the source contact instance\n     */\n    public Object getSourceContact()\n    {\n        return this;\n    }\n\n    /**\n     * Returns the contact source service, this contact belongs to.\n     *\n     * @return the contact source service, this contact belongs to\n     */\n    public ContactSourceService getContactSource()\n    {\n        return contactSource;\n    }\n\n    /**\n     * Sets the contact source service, this contact belongs to.\n     *\n     * @param contactSource the contact source service to set\n     */\n    public void setContactSource(ContactSourceService contactSource)\n    {\n        this.contactSource = contactSource;\n    }\n\n    /**\n     * Returns the index of this source contact in its parent group.\n     *\n     * @return the index of this contact in its parent\n     */\n    public int getIndex()\n    {\n        return -1;\n    }\n}\n\u0005End File\u0006# jitsi/jitsi\n# modules/service/contactsource/src/main/java/org/jitsi/service/contactsource/ExtendedContactSourceService.java\n/*\n * Jitsi, the OpenSource Java VoIP and Instant Messaging client.\n *\n * Copyright @ 2015 Atlassian Pty Ltd\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.jitsi.service.contactsource;\n\n/**\n * The <tt>ExtendedContactSourceService</tt> as its name states it, extends the\n * <tt>ContactSourceService</tt> in order to provide the possibility to query\n * a contact source by specifying a pattern.\n *\n * @author Yana Stamcheva\n */\npublic interface ExtendedContactSourceService\n    extends ContactSourceService\n{\n    /**\n     * Type of a contact source that can be added or removed.\n     */\n    public static final int REMOVABLE_TYPE = 2;\n\n    /**\n     * Type of a contact source that can be enabled or disabled\n     */\n    public static final int ENABLE_DISABLE_TYPE = 10;\n\n    /**\n     * Creates query for the given <tt>queryPattern</tt>.\n     *\n     * @param queryPattern the pattern to search for\n     * @param count the maximum count of result contacts\n     * @return the created query\n     */\n    public ContactQuery createContactQuery(Pattern queryPattern, int count);\n\n    /**\n     * Creates query for the given <tt>queryPattern</tt>.\n     *\n     * @param queryPattern the pattern to search for\n     * @return the created query\n     */\n    public ContactQuery createContactQuery(Pattern queryPattern);\n\n    /**\n     * Removes the given query from this contact source.\n     * @param query the query to remove.\n     */\n    public void removeQuery(ContactQuery query);\n\n    /**\n     * Queries this contact source for the source contact corresponding to the\n     * given <tt>SourceContact</tt>.\n     *\n     * @param sourceContact the source contact we're looking for\n     * @return the source contact found\n     */\n    public SourceContact findSourceContact(SourceContact sourceContact);\n}\n\u0005End File\u0006# jitsi/jitsi\n# modules/service/contactsource/src/main/java/org/jitsi/service/contactsource/ContactSourceActivator.java\n/*\n * Jitsi, the OpenSource Java VoIP and Instant Messaging client.\n *\n * Copyright @ 2015 Atlassian Pty Ltd\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.jitsi.service.contactsource;\n\nimport java.util.*;\nimport org.osgi.framework.*;\nimport org.jitsi.service.configuration.*;\nimport org.jitsi.util.*;\n\n/**\n * The <tt>ContactSourceActivator</tt> is the activator of the contact source\n * bundle.\n * @author Yana Stamcheva\n */\npublic class ContactSourceActivator\n    implements BundleActivator\n{\n    /**\n     * The <tt>Logger</tt> used by the <tt>ContactSourceActivator</tt> class\n     * for logging output.\n     */\n    private static final Logger logger\n        = Logger.getLogger(ContactSourceActivator.class);\n\n    /**\n     * The bundle context.\n     */\n    private static BundleContext bundleContext;\n\n    /**\n     * The configuration service.\n     */\n    private static ConfigurationService configService;\n\n    /**\n     * Indicates if the contact source service is disabled.\n     */\n    private static boolean disabled;\n\n    /**\n     * The contact source service registration.\n     */\n    private ServiceRegistration contactSourceServiceReg;\n\n    /**\n     * Initialize and start contact source service\n     *\n     * @param bc the <tt>BundleContext</tt>\n     * @throws Exception if initializing and starting contact source service\n     * fails\n     */\n    public void start(BundleContext bc) throws Exception\n    {\n        bundleContext = bc;\n\n        // Get the configuration service\n        ServiceReference configReference = bundleContext\n            .getServiceReference(ConfigurationService.class.getName());\n\n        configService = (ConfigurationService) bundleContext\n            .getService(configReference);\n\n        // Check if the contact source is disabled.\n        disabled = configService.getBoolean(\n            \"net.java.sip.communicator.SERVICE_DISABLED\",\n            false);\n\n        Dictionary<String, String> properties = new Hashtable<String, String>();\n\n        properties.put(ContactSourceService.CONTACT_SOURCE_TYPE,\n            ContactSourceService.CONTACT_SOURCE_TYPE_SYSTEM);\n\n        if (!disabled)\n        {\n            contactSourceServiceReg\n                = bundleContext.registerService(\n                    ContactSourceService.class.getName(),\n                    getContactSourceService(),\n                    properties);\n\n            logger.info(\"Contact source implementation ...[Started]\");\n        }\n    }\n\n    /**\n     * Returns the contact source service implementation.\n     *\n     * @return the contact source service implementation\n     */\n    protected ContactSourceService getContactSourceService()\n    {\n        return null;\n    }\n\n    /**\n     * Stops this bundle.\n     *\n     * @param bc the <tt>BundleContext</tt>\n     * @throws Exception if the stop operation goes wrong\n     */\n    public void stop(BundleContext bc) throws Exception\n    {\n        if (contactSourceServiceReg != null)\n        {\n            contactSourceServiceReg.unregister();\n        }\n    }\n\n    /**\n     * Returns a reference to a ConfigurationService implementation currently\n     * registered in the bundle context or null if no such implementation was\n     * found.\n     *\n     * @return a currently valid implementation of the ConfigurationService.\n     */\n    public static ConfigurationService getConfigService()\n    {\n        return configService;\n    }\n\n    /**\n     * Returns the <tt>BundleContext</tt> of the contact source bundle.\n     *\n     * @return the <tt>BundleContext</tt> of the contact source bundle\n     */\n    public static BundleContext getBundleContext()\n    {\n        return bundleContext;\n    }\n\n    /**\n     * Returns the service corresponding to the <tt>serviceClass</tt> or null\n     * if no such service is available.\n     *\n     * @param serviceClass the service class for which we're looking for an\n     * implementation\n     * @return the service corresponding to the <tt>serviceClass</tt> or null\n     * if no such service is available\n     */\n    public static Object getService(Class<?> serviceClass)\n    {\n        ServiceReference<?> serviceReference\n            = bundleContext.getServiceReference(serviceClass.getName());\n\n        if (serviceReference == null)\n            return null;\n\n        return bundleContext.getService(serviceReference);\n    }\n\n    /**\n     * Indicates if the contact source service is disabled.\n     *\n     * @return <tt>true</tt> if the contact source service is disabled,\n     * otherwise returns <tt>false</tt>\n     */\n    public static boolean isContactSourceServiceDisabled()\n    {\n        return disabled;\n    }\n}\n\u0005End File\u0006# modules/service/contactsource/src/main/java/org/jitsi/service/contactsource/GeneralContactSourceService.java\n/*\n * Jitsi, the OpenSource Java VoIP and Instant Messaging client.\n *\n * Copyright @ 2015 Atlassian Pty Ltd\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.jitsi.service.contactsource;\n\nimport java.util.*;\n\n/**\n * Provides an abstract base implementation of the <tt>ContactSourceService</tt>\n * to ease the implementation of the interface.\n *\n * @author Lyubomir Marinov\n */\npublic abstract class GeneralContactSourceService\n    implements ContactSourceService\n{\n    /**\n     * A list to store listeners registered for this service.\n     */\n    private final List<ContactSourceListener> contactSourceListeners\n        = new ArrayList<ContactSourceListener>();\n\n    /**\n     * Returns the <tt>ContactSourceService</tt> type of this service.\n     * @return the <tt>ContactSourceService</tt> type of this service\n     */\n    public int getType()\n    {\n        return ContactSourceService.DEFAULT_TYPE;\n    }\n\n    /**\n     * Creates query for the given <tt>searchPattern</tt>.\n     * @param queryPattern the pattern to search for\n     * @param count the maximum count of the result contacts\n     * @return the created query\n     */\n    public ContactQuery createContactQuery(String queryPattern, int count)\n    {\n        return createContactQuery(queryPattern);\n    }\n\n    /**\n     * Returns the index of the contact source in the result list.\n     *\n     * @return the index of the contact source in the result list\n     */\n    public int getIndex()\n    {\n        return 0;\n    }\n\n    /**\n     * Adds a <tt>ContactSourceListener</tt> to this <tt>ContactSourceService</tt>.\n     *\n     * @param l the <tt>ContactSourceListener</tt> to add\n     */\n    public void addContactSourceListener(ContactSourceListener l)\n    {\n        synchronized (contactSourceListeners)\n        {\n            if (!contactSourceListeners.contains(l))\n                contactSourceListeners.add(l);\n        }\n    }\n\n    /**\n     * Removes a <tt>ContactSourceListener</tt> from this <tt>ContactSourceService</tt>.\n     *\n     * @param l the <tt>ContactSourceListener</tt> to add\n     */\n    public void removeContactSourceListener(ContactSourceListener l)\n    {\n        synchronized (contactSourceListeners)\n        {\n            contactSourceListeners.remove(l);\n        }\n    }\n\n    /**\n     * Fires a new <tt>ContactSourceEvent</tt> to indicate that an error has occurred.\n     *\n     * @param source the source that triggered this event\n     * @param errorCode the error code of the occurred error\n     * @param errorReason the reason for the error\n     */\n    public void fireContactSourceErrorEvent(Object source,\n                                     int errorCode,\n                                     String errorReason)\n    {\n        ContactSourceEvent evt\n            = new ContactSourceEvent(source, errorCode, errorReason);\n\n        fireContactSourceEvent(evt);\n    }\n\n    /**\n     * Notifies all registered <tt>ContactSourceListener</tt>s that an error has occurred.\n     *\n     * @param event the <tt>ContactSourceEvent</tt> that has occurred\n     */\n    public void fireContactSourceEvent(ContactSourceEvent event)\n    {\n        List<ContactSourceListener> listeners;\n        synchronized (contactSourceListeners)\n        {\n            listeners\n                = new ArrayList<ContactSourceListener>(contactSourceListeners);\n        }\n\n        for (ContactSourceListener listener : listeners)\n            listener.error(event);\n    }\n\n    /**\n     * Removes a <tt>ContactSourceListener</tt> from the listener list.\n     *\n     * @param l the <tt>ContactSourceListener</tt> to be removed\n     */\n    public void removeContactSource(ContactSourceListener l)\n    {\n        if (contactSourceListeners != null)\n        {\n            synchronized (contactSourceListeners)\n            {\n                contactSourceListeners.remove(l);\n            }\n        }\n    }\n\n    /**\n     * Returns a list of all registered <tt>ContactSourceListener</tt>s.\n     *\n     * @return a list of all registered <tt>ContactSourceListener</tt>s\n     */\n    public List<ContactSourceListener> getContactSourceListeners()\n    {\n        if (contactSourceListeners != null)\n        {\n            synchronized (contactSourceListeners)\n            {\n                return\n                    new ArrayList<ContactSourceListener>(contactSourceListeners);\n            }\n        }\n        return new ArrayList<ContactSourceListener>();\n    }\n}\n\u0005End File\u0006# jitsi/jitsi\n# modules/service/contactsource/src/main/java/org/jitsi/service/contactsource/Pattern.java\n/*\n * Jitsi, the OpenSource Java VoIP and Instant Messaging client.\n *\n * Copyright @ 2015 Atlassian Pty Ltd\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.jitsi.service.contactsource;\n\n/**\n * The <tt>Pattern</tt> interface defines the behavior of a string pattern. The\n * <tt>Pattern</tt> class is a representation of a pattern. The supported types\n * of patterns at the moment are string and an extended string. The string\n * pattern corresponds to the java <tt>String</tt> and the extended string\n * pattern corresponds to the java <tt>StringBuilder</tt>.\n *\n * @author Yana Stamcheva\n */\npublic interface Pattern\n{\n    /**\n     * Returns the length of this pattern.\n     *\n     * @return the length of this pattern\n     */\n    public int length();\n\n    /**\n     * Indicates if this pattern is empty.\n     *\n     * @return <tt>true</tt> to indicate that this pattern is empty,\n     * <tt>false</tt> - otherwise\n     */\n    public boolean isEmpty();\n\n    /**\n     * Returns the string representation of this pattern.\n     *\n     * @return the string representation of this pattern\n     */\n    public String toString();\n\n    /**\n     * Adds the given <tt>string</tt> to this pattern.\n     *\n     * @param string the <tt>String</tt> to add\n     * @return the new string pattern\n     */\n    public Pattern append(String string);\n\n    /**\n     * Removes the last character of this pattern.\n     *\n     * @return the last character\n     */\n    public Pattern removeLastChar();\n}\n\u0005End File\u0006# jitsi/jitsi\n/*\n * Jitsi, the OpenSource Java VoIP and Instant Messaging client.\n *\n * Copyright @ 2015 Atlassian Pty Ltd\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.jitsi.service.contactsource;\n\nimport java.util.*;\n\n/**\n * The <tt>ContactQueryListener</tt> notifies interested parties when a contact\n * has been received as a result of a query.\n *\n * @author Yana Stamcheva\n */\npublic interface ContactQueryListener\n    extends EventListener\n{\n    /**\n     * Indicates that a new contact has been received for a search.\n     * @param event the <tt>ContactReceivedEvent</tt> that notified us\n     */\n    public void contactReceived(ContactReceivedEvent event);\n\n    /**\n     * Indicates that the status of a search has been changed.\n     * @param event the <tt>ContactQueryStatusEvent</tt> that notified us\n     */\n    public void queryStatusChanged(ContactQueryStatusEvent event);\n\n    /**\n     * Indicates that a contact has been removed after a search.\n     * @param event the <tt>ContactRemovedEvent</tt> that notified us\n     */\n    public void contactRemoved(ContactRemovedEvent event);\n\n    /**\n     * Indicates that a contact has been updated after a search.\n     * @param event the <tt>ContactUpdatedEvent</tt> that notified us\n     */\n    public void contactChanged(ContactChangedEvent event);\n}\n\u0005End File\u0006# jitsi/jitsi\n/*\n * Jitsi, the OpenSource Java VoIP and Instant Messaging client.\n *\n * Copyright @ 2015 Atlassian Pty Ltd\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.jitsi.service.contactsource;\n\n/**\n * The <tt>ContactQuery</tt> corresponds to a particular query made through the\n * <tt>ContactSourceService</tt>. Each query once started could be canceled.\n * One could also register a listener in order to be notified for changes in the\n * query results.\n *\n * @author Yana Stamcheva\n */\npublic interface ContactQuery\n{\n    /**\n     * Cancels this query.\n     */\n    public void cancel();\n\n    /**\n     * Returns the <tt>ContactSourceService</tt>, where this query was first\n     * initiated.\n     * @return the <tt>ContactSourceService</tt>, where this query was first\n     * initiated\n     */\n    public ContactSourceService getContactSource();\n\n    /**\n     * Returns the query string, this query was created for.\n     * @return the query string, this query was created for\n     */\n    public String getQueryString();\n\n    /**\n     * Returns the list of <tt>SourceContact</tt>s returned by this query.\n     * @return the list of <tt>SourceContact</tt>s returned by this query\n     */\n    public java.util.List<SourceContact> getQueryResults();\n\n    /**\n     * Adds the given <tt>ContactQueryListener</tt> to the list of registered\n     * listeners.\n     * @param l the <tt>ContactQueryListener</tt> to add\n     */\n    public void addContactQueryListener(ContactQueryListener l);\n\n    /**\n     * Removes the given <tt>ContactQueryListener</tt> from the list of\n     * registered listeners.\n     * @param l the <tt>ContactQueryListener</tt> to remove\n     */\n    public void removeContactQueryListener(ContactQueryListener l);\n\n    /**\n     * Returns the status of this query. One of the static constants defined in\n     * this class.\n     * @return the status of this query\n     */\n    public int getStatus();\n\n    /**\n     * Indicates that this query has been completed.\n     */\n    public int QUERY_COMPLETED = 0;\n\n    /**\n     * Indicates that this query is in progress.\n     */\n    public int QUERY_IN_PROGRESS = 1;\n\n    /**\n     * Indicates that this query has been canceled.\n     */\n    public int QUERY_CANCELED = 2;\n\n    /**\n     * Indicates that this query has been stopped because of an error.\n     */\n    public int QUERY_ERROR = 3;\n}\n\u0005End File\u0006# jitsi/jitsi\n/*\n * Jitsi, the OpenSource Java VoIP and Instant Messaging client.\n *\n * Copyright @ 2015 Atlassian Pty Ltd\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.jitsi.service.fileaccess;\n\nimport java.io.*;\n\n/**\n * A service used to provide the basic functionality required to access the\n * underlying file system.\n *\n * Note: Never store unencrypted sensitive information, such as passwords,\n * personal data, credit card numbers, etc..\n *\n * @author Alexander Pelov\n * @author Eng Chong Meng\n */\npublic interface FileAccessService\n{\n    /**\n     * Returns a reference to a file with a name specified by <tt>fileName</tt>\n     * placed in the location where Jitsi is storing cached data.\n     *\n     * @param fileName The name of the file to create.\n     * @return The file specified by <tt>fileName</tt>.\n     * @throws IOException If the file does not exist and cannot be created.\n     * @throws SecurityException If the caller does not have access to the file\n     *             specified by <tt>fileName</tt>.\n     * @throws IllegalArgumentException If <tt>fileName</tt> contains\n     *             characters that are not permitted by the underlying file\n     *             system.\n     */\n    File getCachingDirectory(String fileName) throws IOException,\n        SecurityException, IllegalArgumentException;\n\n    /**\n     * Returns a reference to the directory where Jitsi is storing cached data.\n     *\n     * @return The directory where Jitsi is storing cached data.\n     * @throws IOException If the application data directory cannot be created.\n     * @throws SecurityException If the caller does not have sufficient rights to\n     *             read from or create the application data directory.\n     */\n    File getCachingDirectory() throws IOException, SecurityException;\n\n    /**\n     * Returns a reference to a file with a name specified by <tt>fileName</tt>\n     * located in the Log directory. If the file does not exist this method must\n     * create it.\n     *\n     * @param fileName The name of the file to create.\n     * @return The file specified by <tt>fileName</tt>.\n     * @throws IOException If the file does not exist and cannot be created.\n     * @throws SecurityException If the caller does not have access to the file\n     *             specified by <tt>fileName</tt>.\n     * @throws IllegalArgumentException If <tt>fileName</tt> contains\n     *             characters that are not permitted by the underlying file\n     *             system.\n     */\n    File getLogDir(String fileName) throws IOException, SecurityException,\n        IllegalArgumentException;\n\n    /**\n     * Returns a reference to the directory where log files can be stored.\n     *\n     * @return The logging directory.\n     * @throws IOException If the log directory cannot be created.\n     * @throws SecurityException If the caller does not have sufficient rights to\n     *             read from or create the loging directory.\n     */\n    File getLogDir() throws IOException, SecurityException;\n\n    /**\n     * Returns a reference to the temporary directory.\n     * @return a reference to the temporary directory.\n     * @throws IOException\n     * @throws SecurityException\n     */\n    File getTempDir() throws IOException, SecurityException;\n\n    /**\n     * Returns a reference to a file with a name specified by <tt>fileName</tt>\n     * placed in a temporary directory. The file must exist.\n     *\n     * @param fileName The name of the file to create.\n     * @return The file specified by <tt>fileName</tt>.\n     * @throws IOException If the file does not exist and cannot be created.\n     * @throws SecurityException If the caller does not have access to the file\n     *             specified by <tt>fileName</tt>.\n     * @throws IllegalArgumentException If <tt>fileName</tt> contains\n     *             characters that are not permitted by the underlying file\n     *             system.\n     */\n    File getTempDir(String fileName) throws IOException, SecurityException,\n        IllegalArgumentException;\n\n    /**\n     * Returns a reference to a file with a name specified by <tt>fileName</tt>\n     * placed in the location where Jitsi is storing XML configuration files.\n     * If the file does not exist this method must create it.\n     *\n     * @param fileName The name of the file to create.\n     * @return The file specified by <tt>fileName</tt>.\n     * @throws IOException If the file does not exist and cannot be created.\n     * @throws SecurityException If the caller does not have access to the file\n     *             specified by <tt>fileName</tt>.\n     * @throws IllegalArgumentException If <tt>fileName</tt> contains\n     *             characters that are not permitted by the underlying file\n     *             system.\n     */\n    File getConfigurationFile(String fileName) throws IOException,\n        SecurityException, IllegalArgumentException;\n\n    /**\n     * Returns a reference to a file with a name specified by <tt>fileName</tt>\n     * located in user's profile directory.\n     *\n     * @param fileName The name of the file to create.\n     * @return The file specified by <tt>fileName</tt>.\n     * @throws IOException If the file does not exist and cannot be created.\n     * @throws SecurityException If the caller does not have access to the file\n     *             specified by <tt>fileName</tt>.\n     * @throws IllegalArgumentException If <tt>fileName</tt> contains\n     *             characters that are not permitted by the underlying file\n     *             system.\n     */\n    File getPrivilegedConfigurationFile(String fileName) throws IOException,\n        SecurityException, IllegalArgumentException;\n\n    /**\n     * Creates a failsafe transaction which can be used to safely store\n     * informations into a file.\n     *\n     * @param file The file concerned by the transaction, null if file is null.\n     *\n     * @return A new failsafe transaction related to the given file.\n     */\n    FailSafeTransaction createFailSafeTransaction(File file);\n\n    /**\n     * Returns the default downloads directory depending on the operating system.\n     *\n     * @return the default downloads directory depending on the operating system.\n     */\n    File getDefaultDownloadDirectory();\n\n    /**\n     * Ensure that directory file exists and if not make the complete path.\n     *\n     * @param filePath The path will be checked/create\n     * @return True when the directory exists or created successfully\n     */\n    boolean ensureDirExists(String filePath);\n\n    /**\n     * Get the file stored in the configuration directory, e.g. \"/mnt/sdcard/Jitsi\"\n     *\n     * @param fileName the file name\n     * @return the file\n     */\n    File getPrivatePersistentFile(String fileName);\n\n    /**\n     * Creates a reference to the configuration directory.\n     *\n     * @return The configuration directory created.\n     * @throws IOException not enough rights to create or access the directory\n     */\n    File getPrivatePersistentDirectory() throws IOException;\n\n    /**\n     * Creates a reference to a new file in the private persistent directory.\n     *\n     * @param dirName the directory name for this application\n     * @return the created file\n     * @throws IOException if the file cannot be created\n     */\n    File getPrivatePersistentDirectory(String dirName) throws IOException;\n\n    /**\n     * Creates a reference to a new file.\n     *\n     * @param directory the file (directory) to create\n     * @return the created file\n     * @throws IOException if the file cannot be created\n     */\n    File createDirectory(File directory) throws IOException;\n\n    /**\n     * Initializes and connects if needed the file service\n     */\n    void start();\n\n    /**\n     * Destroy the file service (removing temporary files).\n     */\n    void stop();\n\n    /**\n     * Creates a new temporary file with a filename constructed to be unique, located\n     * in the directory used for cache data.\n     *\n     * @param prefix The prefix string to be used in generating the file's name; must be at least three characters long\n     * @param suffix The suffix string to be used in generating the file's name; may be null, in which case the suffix \".tmp\" will be used\n     * @return An abstract pathname denoting a newly-created empty file\n     * @throws IOException\n     */\n    File createCacheTempFile(String prefix, String suffix)\n        throws IOException;\n\n    /**\n     * Load the application resource data file.\n     *\n     * @param fileName the file name\n     * @return The file specified by <tt>fileName</tt>.\n     * @throws IOException If the file does not exist and cannot be created.\n     */\n    InputStream getResourceAsStream(String fileName) throws IOException;\n}\n\u0005End File\u0006# modules/service/fileaccess/src/main/java/org/jitsi/service/fileaccess/FailSafeTransaction.java\n/*\n * Jitsi, the OpenSource Java VoIP and Instant Messaging client.\n *\n * Copyright @ 2015 Atlassian Pty Ltd\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.jitsi.service.fileaccess;\n\nimport java.io.*;\n\n/**\n * Failsafe transaction interface. By failsafe we mean here that the file\n * concerned always stays in a coherent state.\n *\n * @author Benoit Pradelle\n */\npublic interface FailSafeTransaction\n{\n    /**\n     * Ensure that the file accessed is in a coherent state. This function is\n     * useful when the last program execution was terminated before the\n     * transaction got committed.\n     *\n     * @throws IllegalStateException if the transaction has already been started\n     * @throws IOException if an IOException occurs during the file restoration\n     */\n    void restoreFile() throws IllegalStateException, IOException;\n\n    /**\n     * Begins a failsafe transaction. This method needs to be called before\n     * any read/write operation is performed on the file.\n     *\n     * @throws IllegalStateException if the transaction has already been started\n     * or the file doesn't exist anymore\n     * @throws IOException if an IOException occurs during the transaction\n     * creation\n     */\n    void beginTransaction() throws IllegalStateException, IOException;\n\n    /**\n     * Returns the file name of the temporary file used during the transaction.\n     * This temporary file is the one that should be updated.\n     *\n     * @return the file name of the temporary file\n     * @throws IllegalStateException if the transaction has not been started\n     */\n    String getTransactionFilename() throws IllegalStateException;\n\n    /**\n     * Commits the failsafe transaction. This method needs to be called when all\n     * the modifications have been performed on the file.\n     * After this operation, all the changes are effective and the new state\n     * of the file becomes persistent.\n     *\n     * @throws IllegalStateException if the transaction has not been started\n     * @throws IOException if an IOException occurs during the transaction\n     * creation\n     */\n    void commit() throws IllegalStateException, IOException;\n\n    /**\n     * Cancels a failsafe transaction. This method needs to be called if an\n     * error occurs during the transaction.\n     * After this operation, all the changes are discarded.\n     *\n     * @throws IllegalStateException if the transaction has not been started\n     * @throws IOException if an IOException occurs during the operation\n     */\n    void cancel() throws IllegalStateException, IOException;\n}\n\u0005End File\u0006# jitsi/jitsi\n# modules/service/calendar/src/main/java/net/java/sip/communicator/service/calendar/MeetingImpl.java\n/*\n * Jitsi, the OpenSource Java VoIP and Instant Messaging client.\n *\n * Copyright @ 2015 Atlassian Pty Ltd\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage net.java.sip.communicator.service.calendar;\n\nimport java.util.*;\n\n/**\n * The meeting implementation.\n *\n * @author Symphorien Wanko\n * @author Hristo Terezov\n */\npublic class MeetingImpl implements Meeting\n{\n    /**\n     * The <tt>Date</tt> on which this <tt>Meeting</tt> is scheduled to start.\n     */\n    private Date startDate;\n\n    /**\n     * The <tt>Date</tt> on which this <tt>Meeting</tt> is scheduled to end.\n     */\n    private Date endDate;\n\n    /**\n     * The title of this <tt>Meeting</tt> instance.\n     */\n    private String title;\n\n    /**\n     * The description of this <tt>Meeting</tt> instance.\n     */\n    private String description;\n\n    /**\n     * The unique identifier of this <tt>Meeting</tt> instance.\n     */\n    private String uid;\n\n    /**\n     * The unique identifier of the calendar entry of this <tt>Meeting</tt>\n     * instance.\n     */\n    private String calUID;\n\n    /**\n     * The calendar this meeting belongs to.\n     */\n    private String calendar;\n\n    /**\n     * The location where this <tt>Meeting</tt> is scheduled to take place.\n     */\n    private String location;\n\n    /**\n     * The list of attendees of this meeting.\n     */\n    private ArrayList<String> attendees = new ArrayList<String>();\n\n    /**\n     * Returns the date and time at which this <tt>Meeting</tt> is scheduled to\n     * end.\n     *\n     * @return the <tt>Date</tt> at which this <tt>Meeting</tt> is scheduled to\n     * end\n     */\n    public Date getEndDate()\n    {\n        return endDate;\n    }\n\n    /**\n     * Returns the date and time at which this <tt>Meeting</tt> is scheduled to\n     * start.\n     *\n     * @return the <tt>Date</tt> at which this <tt>Meeting</tt> is scheduled to\n     * start\n     */\n    public Date getStartDate()\n    {\n        return startDate;\n    }\n\n    /**\n     * Returns a String locating the place where the meeting will take place.\n     *\n     * @return a String telling the location of this meeting\n     */\n    public String getLocation()\n    {\n        return location;\n    }\n\n    /**\n     * Returns the title/name/subject of this meeting\n     *\n     * @return a String with the title of this meeting\n     */\n    public String getTitle()\n    {\n        return title;\n    }\n\n    /**\n     * Returns the description of this meeting.\n     *\n     * @return a String describing this meeting\n     */\n    public String getDescription()\n    {\n        return description;\n    }\n\n    /**\n     * Returns a unique identifier for this meeting. Well, we should say\n     * \"unique enough\" : the ID is built on the base of the times the meeting\n     * occurs and this meeting's title.\n     *\n     * @return a unique identifier for this meeting\n     */\n    public String getUniqueId()\n    {\n        return uid;\n    }\n\n    /**\n     * Sets a unique identifier for this meeting\n     *\n     * @param newUid the identifier for this meeting\n     */\n    public void setUniqueId(String newUid)\n    {\n        uid = newUid;\n    }\n\n    /**\n     * Sets the description of this meeting.\n     *\n     * @param newDescription the new description\n     */\n    public void setDescription(String newDescription)\n    {\n        description = newDescription;\n    }\n\n    /**\n     * Sets the title of this meeting.\n     *\n     * @param newTitle the new title\n     */\n    public void setTitle(String newTitle)\n    {\n        title = newTitle;\n    }\n\n    /**\n     * Sets the location of this meeting.\n     *\n     * @param newLocation the new location of this meeting\n     */\n    public void setLocation(String newLocation)\n    {\n        location = newLocation;\n    }\n\n    /**\n     * Sets the time this meeting should end.\n     *\n     * @param newEndDate time this meeting should end\n     */\n    public void setEndDate(Date newEndDate)\n    {\n        endDate = newEndDate;\n    }\n\n    /**\n     * Sets the time this meeting should start.\n     *\n     * @param newStartDate time this meeting should start\n     */\n    public void setStartDate(Date newStartDate)\n    {\n        startDate = newStartDate;\n    }\n\n    /**\n     * Returns the calendar this meeting belongs to.\n     *\n     * @return a String identifying the calendar this meeting belongs to\n     */\n    public String getCalendar()\n    {\n        return calendar;\n    }\n\n    /**\n     * Sets the calendar this meeting belongs to.\n     *\n     * @param calendar the calendar this meeting belongs to\n     */\n    public void setCalendar(String calendar)\n    {\n        this.calendar = calendar;\n    }\n\n    /**\n     * Returns a list of the attendees of this meeting.\n     *\n     * @return a list of the attendees of this meeting\n     */\n    public List<String> getAttendees()\n    {\n        return attendees;\n    }\n\n    /**\n     * Adds a person to the list of the attendees of this meeting.\n     *\n     * @param attendee the person to add to the list of the attendees of this\n     * meeting\n     */\n    public void addAttendee(String attendee)\n    {\n        if(attendee != null)\n            attendees.add(attendee);\n    }\n\n    /**\n     * Returns the unique identifier of the calendar entry of this\n     * <tt>Meeting</tt> instance.\n     *\n     * @return the unique identifier of the calendar entry of this\n     * <tt>Meeting</tt> instance.\n     */\n    public String getCalUID()\n    {\n        return calUID;\n    }\n\n    /**\n     * Sets the unique identifier of the calendar entry of this\n     * <tt>Meeting</tt> instance.\n     *\n     * @param calUID the calendar unique identifier.\n     */\n    public void setCalUID(String calUID)\n    {\n        this.calUID = calUID;\n    }\n}\n\u0005End File\u0006# jitsi/jitsi\n# modules/service/calendar/src/main/java/net/java/sip/communicator/service/calendar/CalendarService.java\n/*\n * Jitsi, the OpenSource Java VoIP and Instant Messaging client.\n *\n * Copyright @ 2015 Atlassian Pty Ltd\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage net.java.sip.communicator.service.calendar;\n\nimport java.util.*;\n\n/**\n * Provides a way to handle user's personal calendar and suggesting meetings,\n * creating conference calls, etc.\n *\n * @author Symphorien Wanko\n * @author Hristo Terezov\n */\npublic interface CalendarService\n{\n    /**\n     * If somebody wants to be notified for incoming events he should register\n     * a <tt>CalendarQueryListener</tt> using this method.\n     *\n     * @param l the <tt>CalendarQueryListener</tt> to register\n     */\n    public void addQueryListener(CalendarQueryListener l);\n\n    /**\n     * Removes a previously registered <tt>CalendarQueryListener</tt>.\n     *\n     * @param l the <tt>CalendarQueryListener</tt> to remove\n     */\n    public void removeQueryListener(CalendarQueryListener l);\n\n    /**\n     * Returns a list of all <tt>CalendarAccount</tt> used by the calendar\n     * service which may include Google calendar accounts, Outlook calendar,\n     * etc.\n     *\n     * @return a list of all <tt>CalendarAccount</tt> used by the calendar\n     * service\n     */\n    public List<CalendarAccount> getCalendarAccounts();\n\n    /**\n     * Returns a list of calendars in the specified\n     * <tt>CalendarAccount</tt>.\n     *\n     * @param calendar the calendar to search through\n     * @return a list of calendars in the specified <tt>CalendarAccount</tt>\n     */\n    public List<String> getCalendarList(CalendarAccount calendar);\n\n    /**\n     * Returns a list of upcoming events.\n     *\n     * @param cal calendar account from which the list of upcoming events will be\n     * get.\n     * @return a list of upcoming events.\n     */\n    public List<String> getUpcomingEvents(CalendarAccount cal);\n\n    /**\n     * Searches for events matching the given string.\n     *\n     * @param cal the calendar account.\n     * @param query the string to which the events should match.\n     * @return a list of events matching the query.\n     */\n    public List<String> searchEvents(CalendarAccount cal, String query);\n\n    /**\n     * Returns a reference to a <tt>CalendarAccount</tt> with the specified\n     * name.\n     *\n     * @param accountName the name of the account we're looking for\n     * @return a reference to a <tt>CalendarAccount</tt> with the specified\n     * name\n     */\n    public CalendarAccount getCalendarAccount(String accountName);\n\n    /**\n     * Saves a <tt>Meeting</tt> to the specified <tt>CalendarAccount</tt>.\n     *\n     * @param meeting the <tt>Meeting</tt> to save\n     * @param acc the <tt>CalendarAccount</tt> where to save\n     * @param calendarName the name of the calendar in which the meeting will be\n     * saved.\n     * @return <tt>true</tt> on success and <tt>false</tt> on failure\n     */\n    public boolean saveMeeting(\n            Meeting meeting,\n            CalendarAccount acc,\n            String calendarName);\n}\n\u0005End File\u0006# jitsi/jitsi\n# modules/service/calendar/src/main/java/net/java/sip/communicator/service/calendar/Meeting.java\n/*\n * Jitsi, the OpenSource Java VoIP and Instant Messaging client.\n *\n * Copyright @ 2015 Atlassian Pty Ltd\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage net.java.sip.communicator.service.calendar;\n\nimport java.util.*;\n\n/**\n * This interface represents a meeting or event in a calendar.\n *\n * @author Symphorien Wanko\n */\npublic interface Meeting\n{\n    /**\n     * Returns the date and time at which this <tt>Meeting</tt> is scheduled to\n     * end.\n     *\n     * @return the <tt>Date</tt> at which this <tt>Meeting</tt> is scheduled to\n     * end\n     */\n    public Date getEndDate();\n\n    /**\n     * Returns the date and time at which this <tt>Meeting</tt> is scheduled to\n     * start.\n     *\n     * @return the <tt>Date</tt> at which this <tt>Meeting</tt> is scheduled to\n     * start\n     */\n    public Date getStartDate();\n\n    /**\n     * Returns a String locating the place where the meeting will take place.\n     *\n     * @return a String telling the location of this meeting\n     */\n    public String getLocation();\n\n    /**\n     * Returns the title/name/subject of this meeting\n     *\n     * @return a String with the title of this meeting\n     */\n    public String getTitle();\n\n    /**\n     * Returns the description of this meeting.\n     *\n     * @return a String describing this meeting\n     */\n    public String getDescription();\n\n    /**\n     * Returns a unique identifier for this meeting.\n     *\n     * @return a unique identifier for this meeting\n     */\n    public String getUniqueId();\n\n    /**\n     * Returns the calendar this meeting belongs to.\n     *\n     * @return a String identifying the calendar this meeting belongs to\n     */\n    public String getCalendar();\n\n    /**\n     * Returns a list of the attendees of this meeting.\n     *\n     * @return a list of the attendees of this meeting\n     */\n    public List<String> getAttendees();\n\n    /**\n     * Sets a unique identifier for this meeting\n     *\n     * @param newUid the identifier for this meeting\n     */\n    public void setUniqueId(String newUid);\n\n    /**\n     * Sets the description of this meeting.\n     *\n     * @param newDescription the new description\n     */\n    public void setDescription(String newDescription);\n\n    /**\n     * Sets the title of this meeting.\n     *\n     * @param newTitle the new title\n     */\n    public void setTitle(String newTitle);\n\n    /**\n     * Sets the location of this meeting.\n     *\n     * @param newLocation the new location of this meeting\n     */\n    public void setLocation(String newLocation);\n\n    /**\n     * Sets the time this meeting should end.\n     *\n     * @param newEndDate time this meeting should end\n     */\n    public void setEndDate(Date newEndDate);\n\n    /**\n     * Sets the time this meeting should start.\n     *\n     * @param newStartDate time this meeting should start\n     */\n    public void setStartDate(Date newStartDate);\n\n    /**\n     * Adds a person to the list of the attendees of this meeting.\n     *\n     * @param attendee the person to add to the list of the attendees of this\n     * meeting\n     */\n    public void addAttendee(String attendee);\n\n    /**\n     * Sets the calendar this meeting belongs to.\n     *\n     * @param calendar the calendar this meeting belongs to\n     */\n    public void setCalendar(String calendar);\n\n    /**\n     * Returns the unique identifier of the calendar entry of this\n     * <tt>Meeting</tt> instance.\n     *\n     * @return the unique identifier of the calendar entry of this\n     * <tt>Meeting</tt> instance.\n     */\n    public String getCalUID();\n\n    /**\n     * Sets the unique identifier of the calendar entry of this\n     * <tt>Meeting</tt> instance.\n     *\n     * @param calUID the calendar unique identifier.\n     */\n    public void setCalUID(String calUID);\n}\n\u0005End File\u0006# jitsi/jitsi\n# modules/service/calendar/src/main/java/net/java/sip/communicator/service/calendar/CalendarItemImpl.java\n/*\n * Jitsi, the OpenSource Java VoIP and Instant Messaging client.\n *\n * Copyright @ 2015 Atlassian Pty Ltd\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage net.java.sip.communicator.service.calendar;\n\n/**\n * Simple implementation of calendar item interface.\n *\n * @author Damian Minkov\n */\npublic class CalendarItemImpl\n    implements CalendarItem\n{\n    /**\n     * The calendar service this item belongs to.\n     */\n    private final CalendarService calendarService;\n\n    /**\n     * The calendar account this item belongs to.\n     */\n    private final CalendarAccount account;\n\n    /**\n     * The meeting/event\n     */\n    private final Meeting meeting;\n\n    /**\n     * Constructs new calendar item.\n     * @param calendarService the service.\n     * @param account the calendar account.\n     * @param meeting the meeting/event in the calendar.\n     */\n    public CalendarItemImpl(CalendarService calendarService,\n                          CalendarAccount account,\n                          Meeting meeting)\n    {\n        this.calendarService = calendarService;\n        this.account = account;\n        this.meeting = meeting;\n    }\n\n    /**\n     * Returns the calendar service this item belongs to.\n     *\n     * @return the calendar service this item belongs to.\n     */\n    @Override\n    public CalendarService getCalendarService()\n    {\n        return calendarService;\n    }\n\n    /**\n     * Returns the calendar account this item belongs to.\n     *\n     * @return the calendar account this item belongs to.\n     */\n    @Override\n    public CalendarAccount getCalendarAccount()\n    {\n        return account;\n    }\n\n    /**\n     * Returns the meeting/event.\n     *\n     * @return the meeting/event.\n     */\n    @Override\n    public Meeting getMeeting()\n    {\n        return meeting;\n    }\n}\n\u0005End File\u0006/*\n * Jitsi, the OpenSource Java VoIP and Instant Messaging client.\n *\n * Copyright @ 2015 Atlassian Pty Ltd\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage net.java.sip.communicator.service.calendar;\n\n/**\n * A <tt>CalendarItem</tt> represents an instance of a Meeting stored in\n * a personal calendar.\n *\n * @author Damian Minkov\n */\npublic interface CalendarItem\n{\n    /**\n     * Returns the calendar service this item belongs to.\n     *\n     * @return the calendar service this item belongs to.\n     */\n    public CalendarService getCalendarService();\n\n    /**\n     * Returns the calendar account this item belongs to.\n     *\n     * @return the calendar account this item belongs to.\n     */\n    public CalendarAccount getCalendarAccount();\n\n    /**\n     * Returns the meeting/event.\n     *\n     * @return the meeting/event.\n     */\n    public Meeting getMeeting();\n}\n\u0005End File\u0006# jitsi/jitsi\n/*\n * Jitsi, the OpenSource Java VoIP and Instant Messaging client.\n *\n * Copyright @ 2015 Atlassian Pty Ltd\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage net.java.sip.communicator.service.calendar;\n\n/**\n * An account that should be provided by an implementation of the calendar\n * service. For now (2 Aug. 2013) only Google calendar and Outlook are\n * supported.\n *\n * @author Hristo Terezov\n */\npublic interface CalendarAccount\n{\n    /**\n     * Returns the calendar user id (currently email for both Google calendar and\n     * Outlook calendar).\n     *\n     * @return the calendar user id.\n     */\n    public String getId();\n\n    /**\n     * Returns the account name.\n     *\n     * @return the account name\n     */\n    public String getAccountName();\n\n    /**\n     * Returns the resource path of the icon of this account.\n     *\n     * @return the resource path of the icon.\n     */\n    public String getIcon();\n\n    /**\n     * Returns the account type (currently Google or Outlook)\n     *\n     * @return the account type\n     */\n    public String getType();\n\n}\n\u0005End File\u0006# jitsi/jitsi\n/*\n * Jitsi, the OpenSource Java VoIP and Instant Messaging client.\n *\n * Copyright @ 2015 Atlassian Pty Ltd\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage net.java.sip.communicator.service.calendar;\n\n/**\n * A basic implementation of <tt>CalendarAccount</tt>\n *\n * @author Hristo Terezov\n */\npublic class CalendarAccountImpl implements CalendarAccount\n{\n    /**\n     * The calendar user id (currently email for both Google calendar and\n     * Outlook calendar).\n     */\n    private String id;\n\n    /**\n     * The resource path of the icon of this account.\n     */\n    private String icon;\n\n    /**\n     * The account name.\n     */\n    private String accountName;\n\n    /**\n     * The account type (Google or Outlook)\n     */\n    private String accountType;\n\n    /**\n     * Creates instance of <tt>CalendarAccountImpl</tt>\n     * @param accountName account name\n     * @param icon icon resource path\n     * @param id calendar user id\n     * @param accountType account type.\n     */\n    public CalendarAccountImpl(String accountName, String icon, String id,\n        String accountType)\n    {\n        this.accountName = accountName;\n        this.icon = icon;\n        this.id = id;\n        this.accountType = accountType;\n    }\n\n    /**\n     * Returns the calendar user id.\n     *\n     * @return the calendar user id.\n     */\n    @Override\n    public String getId()\n    {\n        return id;\n    }\n\n    /**\n     * Returns the account name.\n     *\n     * @return the account name\n     */\n    @Override\n    public String getAccountName()\n    {\n        return accountName;\n    }\n\n    /**\n     * Returns the resource path of the icon of this account.\n     *\n     * @return the resource path of the icon.\n     */\n    @Override\n    public String getIcon()\n    {\n        return icon;\n    }\n\n    /**\n     * Returns the account type (currently Google or Outlook)\n     *\n     * @return the account type\n     */\n    @Override\n    public String getType()\n    {\n        return accountType;\n    }\n}\n\u0005End File\u0006/*\n * Jitsi, the OpenSource Java VoIP and Instant Messaging client.\n *\n * Copyright @ 2015 Atlassian Pty Ltd\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage net.java.sip.communicator.service.calendar;\n\nimport net.java.sip.communicator.service.protocol.*;\n\n/**\n * A listener interface for receiving CalendarQueryEvent. The class that is\n * interested in processing a CalendarQueryEvent registers with an object\n * implementing CalendarService interface.\n *\n * @author Symphorien Wanko\n */\npublic interface CalendarQueryListener\n{\n    /**\n     * Called when interested in meeting found during a calendar query.\n     *\n     * @param event a CalendarQueryEvent\n     *\n     * @return <tt>CONTINUE_QUERY</tt> or <tt>CANCEL_QUERY</tt> to continue\n     * or stop the current query.\n     */\n    public int onQuery(CalendarQueryEvent event);\n\n    /**\n     * Called when a calendar query is complete.\n     *\n     * @param event a CalendarQueryEvent\n     */\n    public void onQueryComplete(CalendarQueryEvent event);\n\n    /**\n     * Called when a calendar query has been canceled.\n     *\n     * @param event a CalendarQueryEvent\n     */\n    public void onQueryCanceled(CalendarQueryEvent event);\n\n    /**\n     * Convenience constant to continue a query\n     */\n    public static int CONTINUE_QUERY = 0;\n\n    /**\n     * Convenience constant to stop a query\n     */\n    public static int CANCEL_QUERY = 1;\n\n    /**\n     * Checks if the ProtocolProviderService is an implemented instance from\n     * <tt>OperationSetTelephonyConferencing</tt>.\n     *\n     * @param protocolProvider ProtocolProviderService to check\n     * @return true if the ProtocolProviderService is an implemented instance\n     * from <tt>OperationSetTelephonyConferencing</tt>, false - otherwise\n     */\n    public boolean isTelephonyConferencingCheck(\n        ProtocolProviderService protocolProvider);\n}\n\u0005End File\u0006# modules/service/callhistory/src/main/java/net/java/sip/communicator/service/callhistory/CallRecord.java\n/*\n * Jitsi, the OpenSource Java VoIP and Instant Messaging client.\n *\n * Copyright @ 2015 Atlassian Pty Ltd\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage net.java.sip.communicator.service.callhistory;\n\nimport java.util.*;\n\nimport net.java.sip.communicator.service.protocol.*;\n\n/**\n * Structure used for encapsulating data when writing or reading\n * Call History Data. Also these records are used for returning data\n * from the Call History Service\n *\n * @author Damian Minkov\n * @author Hristo Terezov\n */\npublic class CallRecord\n{\n    /**\n     * The outgoing call direction.\n     */\n    public final static String OUT = \"out\";\n\n    /**\n     * The incoming call direction.\n     */\n    public final static String IN = \"in\";\n\n    /**\n     * The start date of the call.\n     */\n    private Date startTime;\n\n    /**\n     * The end date of the call.\n     */\n    private Date endTime;\n\n    /**\n     * A list of the peers in the call.\n     */\n    private List<CallPeerRecord> peerRecords;\n\n    /**\n     * The direction of the call.\n     */\n    private String direction;\n\n    /**\n     * Creates CallRecord.\n     *\n     * @param startTime the start date and time of the record\n     * @param endTime the end date and time of the record\n     * @param peerRecords the list of peers\n     * @param direction the direction of the call\n     */\n    public CallRecord(Date startTime, Date endTime,\n            List<CallPeerRecord> peerRecords, String direction)\n    {\n        this.startTime = startTime;\n        this.endTime = endTime;\n        this.peerRecords = peerRecords;\n        this.direction = direction;\n    }\n\n    /**\n     * Returns the start time of the record.\n     * @return the start time of the record.\n     */\n    public Date getStartTime()\n    {\n        return startTime;\n    }\n\n    /**\n     * Returns the end time of the record.\n     * @return the end time of the record.\n     */\n    public Date getEndTime()\n    {\n        return endTime;\n    }\n\n    /**\n     * Returns the direction of the record.\n     * @return the direction of the record.\n     */\n    public String getDirection()\n    {\n        return direction;\n    }\n\n    /**\n     * Implements the toString method.\n     * @return String\n     */\n    @Override\n    public String toString()\n    {\n        return \"Call Record : startTime=\" + startTime\n                + \" endTime=\" + endTime\n                + \" peerRecords=\" + peerRecords\n                + \" direction=\" + direction;\n    }\n\n    /**\n     * Returns the list of peer records.\n     * @return the list of peer records.\n     */\n    public List<CallPeerRecord> getPeerRecords()\n    {\n        return peerRecords;\n    }\n\n    /**\n     * Sets the list of peer records.\n     * @param peerRecords the list of peer records to set.\n     */\n    public void setPeerRecords(List<CallPeerRecord> peerRecords)\n    {\n        this.peerRecords = peerRecords;\n    }\n\n    /**\n     * Sets the start time.\n     *\n     * @param startTime the start time to set\n     */\n    public void setStartTime(Date startTime)\n    {\n        this.startTime = startTime;\n    }\n\n    /**\n     * Sets the end time.\n     *\n     * @param endTime the end time to set\n     */\n    public void setEndTime(Date endTime)\n    {\n        this.endTime = endTime;\n    }\n\n    /**\n     * Sets the direction.\n     *\n     * @param direction the direction to set\n     */\n    public void setDirection(String direction)\n    {\n        this.direction = direction;\n    }\n\n    /**\n     * Finds a peer record with the supplied address.\n     * @param address the address to search for.\n     * @return the found <tt>CallPeerRecord</tt> or null if no record is found.\n     */\n    public CallPeerRecord findPeerRecord(String address)\n    {\n        for(CallPeerRecord record : peerRecords)\n        {\n            if(record.getPeerAddress().equals(address))\n                return record;\n        }\n        return null;\n    }\n\n    /**\n     * Finds a peer record with the supplied <tt>peer</tt>.\n     * @param peer the <tt>CallPeer</tt> to search for.\n     * @return the found <tt>CallPeerRecord</tt> or null if no record is found.\n     */\n    public CallPeerRecord findPeerRecord(CallPeer peer)\n    {\n        for(CallPeerRecord record : peerRecords)\n        {\n            if(record.getPeerAddress().equals(peer.getAddress()))\n                return record;\n        }\n        return null;\n    }\n\n    /**\n     * Adds a peer record to the peer record list.\n     * @param record the <tt>CallPeerRecord</tt> to add\n     */\n    public void addPeerRecord(CallPeerRecord record)\n    {\n        peerRecords.add(record);\n    }\n\n    /**\n     * Calculates the duration of the call. Subtracts endTime and startTime\n     * @return the duration in milliseconds.\n     */\n    public long getDuration()\n    {\n        return getEndTime().getTime() - getStartTime().getTime();\n    }\n}\n\u0005End File\u0006# jitsi/jitsi\n# modules/service/callhistory/src/main/java/net/java/sip/communicator/service/callhistory/CallHistoryQuery.java\n/*\n * Jitsi, the OpenSource Java VoIP and Instant Messaging client.\n *\n * Copyright @ 2015 Atlassian Pty Ltd\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage net.java.sip.communicator.service.callhistory;\n\nimport java.util.*;\n\n/**\n * The <tt>CallHistoryQuery</tt> gives an application the possibility to\n * query for Call History records more precisely.\n *\n * @author Yana Stamcheva\n */\npublic interface CallHistoryQuery\n{\n    /**\n     * Indicates that this query has been canceled.\n     */\n    public static final int QUERY_CANCELED = 0;\n\n    /**\n     * Indicates that this query has been completed.\n     */\n    public static final int QUERY_COMPLETED = 1;\n\n    /**\n     * The <tt>STATUS_CHANGED</tt> property name.\n     */\n    public static final String STATUS_CHANGED = \"QueryStatusChanged\";\n\n    /**\n     * Adds the given <tt>CallHistoryQueryListener</tt> to the list of\n     * listeners interested in query result changes.\n     * @param l the <tt>CallHistoryQueryListener</tt> to add\n     */\n    public void addQueryListener(CallHistoryQueryListener l);\n\n    /**\n     * Removes the given <tt>CallHistoryQueryListener</tt> from the list of\n     * listeners interested in query result changes.\n     * @param l the <tt>CallHistoryQueryListener</tt> to remove\n     */\n    public void removeQueryListener(CallHistoryQueryListener l);\n\n    /**\n     * Cancels this query.\n     */\n    public void cancel();\n\n    /**\n     * Returns the query status.\n     *\n     * @return the query status\n     */\n    public int getStatus();\n\n    /**\n     * Returns a collection of the records matched by this query.\n     *\n     * @return a collection of the records matched by this query\n     */\n    public Collection<CallRecord> getCallRecords();\n\n    /**\n     * Returns a collection of the records matched by this query.\n     *\n     * @param count the maximum number of records to return\n     * @return a collection of the records matched by this query\n     */\n    public Collection<CallRecord> getCallRecords(int count);\n}\n\u0005End File\u0006# jitsi/jitsi\n/*\n * Jitsi, the OpenSource Java VoIP and Instant Messaging client.\n *\n * Copyright @ 2015 Atlassian Pty Ltd\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage net.java.sip.communicator.service.callhistory;\n\nimport java.util.*;\n\nimport net.java.sip.communicator.service.protocol.*;\n\n/**\n * The Call History Service stores info about calls made from various protocols\n *\n * @author Alexander Pelov\n * @author Damian Minkov\n * @author Hristo Terezov\n */\npublic interface CallHistoryService\n{\n    /**\n     * Adds a call to the call history.\n     * @param peerAddress String\n     * @param direction String\n     * @param startTime Date\n     * @param endTime Date\n     */\n    public void addCallRecord(\n            String peerAddress,\n            String direction,\n            Date startTime,\n            Date endTime);\n\n    /**\n     * Adds a call to the call history.\n     * @param peerRecords the peers associated with the call\n     * @param direction String\n     * @param startTime Date\n     * @param endTime Date\n     */\n    public void addCallRecord(\n            List<CallPeerRecord> peerRecords,\n            String direction,\n            Date startTime,\n            Date endTime);\n\n    /**\n     * Adding a record for a call\n     * @param record CallRecord\n     */\n    public void addCallRecord(CallRecord record);\n\n    /**\n     * This method is meant to be used by the implementation to make\n     * periodically flush to disk. If the service has no cache\n     * (is using a DB for example) it would do nothing.\n     */\n    public void flush();\n\n    /**\n     * Returns an iterator over the calls made by all the contacts\n     * in the supplied <tt>contact</tt> after the given date\n     *\n     * @param contact MetaContact which contacts participate in\n     *      the returned calls\n     * @param startDate Date the start date of the calls\n     * @return Collection of CallRecords with CallPeerRecord\n     * @throws RuntimeException\n     */\n    public Collection<CallRecord> findByStartDate(\n            MetaContact contact, Date startDate)\n        throws RuntimeException;\n\n    /**\n     * Returns an iterator over the calls made by all the contacts\n     * in the supplied <tt>contact</tt> before the given date\n     *\n     * @param contact MetaContact which contacts participate in\n     *      the returned calls\n     * @param endDate Date the end date of the calls\n     * @return Collection of CallRecords with CallPeerRecord\n     * @throws RuntimeException\n     */\n    public Collection<CallRecord> findByEndDate(\n            MetaContact contact, Date endDate)\n        throws RuntimeException;\n\n    /**\n     * Returns an iterator over the calls made by all the contacts\n     * in the supplied <tt>contact</tt> between the given dates\n     *\n     * @param contact MetaContact which contacts participate in\n     *      the returned calls\n     * @param startDate Date the start date of the calls\n     * @param endDate Date the end date of the calls\n     * @return Collection of CallRecords with CallPeerRecord\n     * @throws RuntimeException\n     */\n    public Collection<CallRecord> findByPeriod(\n            MetaContact contact, Date startDate, Date endDate)\n        throws RuntimeException;\n\n    /**\n     * Returns an iterator over the calls made after the given date\n     *\n     * @param startDate Date the start date of the calls\n     * @return Collection of CallRecords with CallPeerRecord\n     * @throws RuntimeException\n     */\n    public Collection<CallRecord> findByStartDate(Date startDate)\n        throws RuntimeException;\n\n    /**\n     * Returns an iterator over the calls made before the given date\n     *\n     * @param endDate Date the end date of the calls\n     * @return Collection of CallRecords with CallPeerRecord\n     * @throws RuntimeException\n     */\n    public Collection<CallRecord> findByEndDate(Date endDate)\n        throws RuntimeException;\n\n    /**\n     * Returns an iterator over the calls made between the given dates\n     *\n     * @param startDate Date the start date of the calls\n     * @param endDate Date the end date of the calls\n     * @return Collection of CallRecords with CallPeerRecord\n     * @throws RuntimeException\n     */\n    public Collection<CallRecord> findByPeriod(Date startDate, Date endDate)\n        throws RuntimeException;\n\n    /**\n     * Returns the supplied number of recent calls made by all the contacts\n     * in the supplied <tt>contact</tt>\n     *\n     * @param contact MetaContact which contacts participate in\n     *      the returned calls\n     * @param count calls count\n     * @return Collection of CallRecords with CallPeerRecord\n     * @throws RuntimeException\n     */\n    public Collection<CallRecord> findLast(MetaContact contact, int count)\n        throws RuntimeException;\n\n    /**\n     * Returns the supplied number of recent calls.\n     *\n     * @param count calls count\n     * @return Collection of CallRecords with CallPeerRecord\n     * @throws RuntimeException\n     */\n    public Collection<CallRecord> findLast(int count)\n        throws RuntimeException;\n\n    /**\n     * Find the calls made by the supplied peer address\n     * @param address String the address of the peer\n     * @param recordCount the number of records to return\n     * @return Collection of CallRecords with CallPeerRecord\n     * @throws RuntimeException\n     */\n    public Collection<CallRecord> findByPeer(String address, int recordCount)\n        throws RuntimeException;\n\n    /**\n     * Adding progress listener for monitoring progress of search process\n     *\n     * @param listener HistorySearchProgressListener\n     */\n    public void addSearchProgressListener(\n        CallHistorySearchProgressListener listener);\n\n   /**\n    * Removing progress listener\n    *\n    * @param listener HistorySearchProgressListener\n    */\n    public void removeSearchProgressListener(\n        CallHistorySearchProgressListener listener);\n\n    /**\n     * Updates the secondary address field of call record.\n     * @param date the start date of the record which will be updated.\n     * @param peerAddress the peer address of the record which will be updated.\n     * @param address the value of the secondary address .\n     */\n    public void updateCallRecordPeerSecondaryAddress(\n        Date date, String peerAddress, String address);\n\n    /**\n     * Creates a query for the history service. This method needs to be\n     * implemented by the implementing service, in order that it would be\n     * possible to query the history.\n     *\n     * @param queryString the query string\n     * @return a <tt>CallHistoryQuery</tt> object.\n     */\n    public CallHistoryQuery queryHistory(String queryString);\n\n    /**\n     * Creates a query for the history service. This method needs to be\n     * implemented by the implementing service, in order that it would be\n     * possible to query the history.\n     *\n     * @param queryString the query string\n     * @param contactList the list of addresses which should contain the result.\n     * @return a <tt>CallHistoryQuery</tt> object.\n     */\n    public CallHistoryQuery queryHistory(String queryString,\n        Collection<String> contactList);\n}\n\u0005End File\u0006# jitsi/jitsi\n/*\n * Jitsi, the OpenSource Java VoIP and Instant Messaging client.\n *\n * Copyright @ 2015 Atlassian Pty Ltd\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage net.java.sip.communicator.service.callhistory;\n\nimport java.util.*;\n\n/**\n * Structure used to handle peer information.\n *\n * @author Damian Minkov\n * @author Hristo Terezov\n */\npublic class CallPeerRecord\n{\n    /**\n     * The peer address.\n     */\n    private String peerAddress = null;\n\n    /**\n     * The display name.\n     */\n    private String displayName = null;\n\n    /**\n     * The start time of the record.\n     */\n    private Date startTime = null;\n\n    /**\n     * The end time of the record.\n     */\n    private Date endTime = null;\n\n    /**\n     * The secondary address of the peer.\n     */\n    private String peerSecondaryAddress = null;\n\n    /**\n     * The state of the peer at the end of the call.\n     */\n    private String state = null;\n\n    /**\n     * Creates CallPeerRecord.\n     *\n     * @param peerAddress the peer address.\n     * @param startTime the start time.\n     * @param endTime the end time.\n     */\n    public CallPeerRecord(\n            String peerAddress,\n            Date startTime,\n            Date endTime)\n    {\n        this.peerAddress = peerAddress;\n        this.startTime = startTime;\n        this.endTime = endTime;\n    }\n\n    /**\n     * Creates a peer record.\n     *\n     * @param peerAddress the peer address.\n     * @param displayName the display name.\n     * @param startTime the start time.\n     * @param endTime the end time.\n     */\n    public CallPeerRecord(\n            String peerAddress,\n            String displayName,\n            Date startTime,\n            Date endTime)\n    {\n        this.peerAddress = peerAddress;\n        this.displayName = displayName;\n        this.startTime = startTime;\n        this.endTime = endTime;\n    }\n\n    /**\n     * Creates a peer record.\n     *\n     * @param peerAddress the peer address.\n     * @param displayName the display name.\n     * @param startTime the start time.\n     * @param endTime the end time.\n     * @param state the end state of the peer.\n     */\n    public CallPeerRecord(\n            String peerAddress,\n            String displayName,\n            Date startTime,\n            Date endTime,\n            String state)\n    {\n        this.peerAddress = peerAddress;\n        this.displayName = displayName;\n        this.startTime = startTime;\n        this.endTime = endTime;\n        this.state = state;\n    }\n\n\n    /**\n     * The address of the peer. <p>\n     * @return peer address\n     */\n    public String getPeerAddress()\n    {\n        return peerAddress;\n    }\n\n    /**\n     * The secondary address of the peer. <p>\n     * @return the secondary address of the peer.\n     */\n    public String getSecondaryPeerAddress()\n    {\n        return peerSecondaryAddress;\n    }\n\n    /**\n     * Sets the secondary address of the peer.\n     *\n     * @param peerAddress the secondary address of the peer.\n     */\n    public void setSecondaryPeerAddress(String peerAddress)\n    {\n        this.peerSecondaryAddress = peerAddress;\n    }\n\n    /**\n     * The display name of the peer. <p>\n     * @return peer display name\n     */\n    public String getDisplayName()\n    {\n        return displayName;\n    }\n\n    /**\n     * Time when peer connected to the call. <p>\n     * @return start time\n     */\n    public Date getStartTime()\n    {\n        return startTime;\n    }\n\n    /**\n     * Time when peer leaves the call. <p>\n     * @return end time\n     */\n    public Date getEndTime()\n    {\n        return endTime;\n    }\n\n    /**\n     * Implements toString.\n     * @return String\n     */\n    @Override\n    public String toString()\n    {\n        return \"Call Peer Record : \" + getPeerAddress();\n    }\n\n    /**\n     * Sets the start time.\n     *\n     * @param startTime the start time.\n     */\n    public void setStartTime(Date startTime)\n    {\n        this.startTime = startTime;\n    }\n\n    /**\n     * Sets the end time.\n     *\n     * @param endTime the end time.\n     */\n    public void setEndTime(Date endTime)\n    {\n        this.endTime = endTime;\n    }\n\n    /**\n     * Returns the state of the peer at the end of the call.\n     *\n     * @return the state of the peer at the end of the call.\n     */\n    public String getState()\n    {\n        return state;\n    }\n}\n\u0005End File\u0006# modules/service/desktoputil/src/main/java/net/java/sip/communicator/util/ExtendedTooltip.java\n/*\n * Jitsi, the OpenSource Java VoIP and Instant Messaging client.\n *\n * Copyright @ 2015 Atlassian Pty Ltd\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage net.java.sip.communicator.util;\n\nimport java.awt.*;\nimport java.awt.image.*;\n\nimport javax.swing.*;\nimport javax.swing.plaf.metal.*;\n\nimport org.jitsi.service.resources.*;\nimport org.jitsi.util.*;\n\n/**\n * The <tt>ExtendedTooltip</tt> is a custom tooltip that can be used anywhere\n * in the application to show a customized tooltip.\n *\n * @author Yana Stamcheva\n */\npublic class ExtendedTooltip\n    extends JToolTip\n{\n    /**\n     * Serial version UID.\n     */\n    private static final long serialVersionUID = 0L;\n\n    /**\n     * The intent between the lines.\n     */\n    private static final int LINE_INTENT = 10;\n\n    /**\n     * The intent between the image and the text.\n     */\n    private static final int IMAGE_INTENT = 5;\n\n    /**\n     * The intent between the component and its border.\n     */\n    private static final int BORDER_INTENT = 5;\n\n    /**\n     * The color of the border.\n     */\n    private static final Color BORDER_COLOR\n        = new Color(OSUtils.IS_MAC ? 0xB8B6B0 : 0x8A8A83);\n\n    /**\n     * The image shown on the left of the tooltip.\n     */\n    private Image image;\n\n    /**\n     * The title of the tooltip.\n     */\n    private String title;\n\n    /**\n     * The line1 of the tooltip.\n     */\n    private String line1;\n\n    /**\n     * The line2 of the tooltip.\n     */\n    private String line2;\n\n    /**\n     * The line3 of the tooltip.\n     */\n    private String line3;\n\n    /**\n     * The string showing the status of the tooltip.\n     */\n    private String statusString;\n\n    /**\n     * The icon corresponding to the status.\n     */\n    private Icon statusIcon;\n\n    /**\n     * The icon to be displayed on the right of the tooltip.\n     */\n    private Icon rightIcon;\n\n    /**\n     * The label containing the tooltip image.\n     */\n    private final JLabel imageLabel = new JLabel();\n\n    /**\n     * The label containing the tooltip title.\n     */\n    private final JLabel titleLabel = new JLabel();\n\n    /**\n     * The label containing the tooltip line1.\n     */\n    private final JLabel line1Label = new JLabel();\n\n    /**\n     * The label containing the tooltip line2.\n     */\n    private final JLabel line2Label = new JLabel();\n\n    /**\n     * The label containing the tooltip line3.\n     */\n    private final JLabel line3Label = new JLabel();\n\n    /**\n     * The label containing the tooltip status.\n     */\n    private final JLabel statusLabel = new JLabel();\n\n    /**\n     * The label containing the tooltip right icon.\n     */\n    private final JLabel rightIconLabel = new JLabel();\n\n    /**\n     * Indicates if the tooltip contains text. If the tooltip contains only an\n     * image and no text we should use a custom panel instead of the default\n     * tooltip UI.\n     */\n    private boolean isTextSet = false;\n\n    /**\n     * The preferred tooltip width.\n     */\n    private int prefWidth = -1;\n\n    /**\n     * The preferred tooltip height.\n     */\n    private int prefHeight = -1;\n\n    /**\n     * The name of the icon showing in this tooltip.\n     */\n    private String imageIconName;\n\n    /**\n     * The maximum width of the tooltip.\n     */\n    private static final int MAX_WIDTH = 300;\n\n    /**\n     * The horizontal gap between columns of the tooltip.\n     */\n    private static final int H_GAP = 5;\n\n    /**\n     * The vertical gap between lines of the tooltip.\n     */\n    private static final int V_GAP = 5;\n\n    /**\n     * Creates an <tt>ExtendedTooltip</tt>.\n     */\n    public ExtendedTooltip()\n    {\n        super();\n\n        this.setUI(new ExtendedTooltipUI());\n    }\n\n    /**\n     * Creates an <tt>ExtendedTooltip</tt> by specifying the component, for\n     * which the tooltip is created.\n     *\n     * @param component the component, for which the tooltip is created\n     */\n    public ExtendedTooltip(JComponent component)\n    {\n        setComponent(component);\n\n        this.setUI(new ExtendedTooltipUI());\n    }\n\n    /**\n     * Sets the title of the tooltip.\n     *\n     * @param title the title of the tooltip\n     */\n    public void setTitle(String title)\n    {\n        this.title = title;\n        isTextSet = true;\n    }\n\n    /**\n     * Sets the first line of the tooltip.\n     *\n     * @param line1 the first line of the tooltip\n     */\n    public void setLine1(String line1)\n    {\n        this.line1 = line1;\n        isTextSet = true;\n    }\n\n    /**\n     * Sets the second line of the tooltip.\n     *\n     * @param line2 the second line of the tooltip\n     */\n    public void setLine2(String line2)\n    {\n        this.line2 = line2;\n        isTextSet = true;\n    }\n\n    /**\n     * Sets the third line of the tooltip.\n     *\n     * @param line3 the third line of the tooltip\n     */\n    public void setLine3(String line3)\n    {\n        this.line3 = line3;\n        isTextSet = true;\n    }\n\n    /**\n     * Sets the image of the tooltip.\n     *\n     * @param imageIcon the image icon to show on the left of the tooltip\n     */\n    public void setImage(ImageIcon imageIcon)\n    {\n        if (imageIcon != null)\n            this.image = imageIcon.getImage();\n    }\n\n    /**\n     * Sets the name of the image of the tooltip.\n     *\n     * @param imageIconName the name of the image of the tooltip\n     */\n    public void setImageIconName(String imageIconName)\n    {\n        this.imageIconName = imageIconName;\n    }\n\n    /**\n     * Returns the name of the image of the tooltip.\n     *\n     * @return the name of the image of the tooltip\n     */\n    public String getImageIconName()\n    {\n        return imageIconName;\n    }\n\n    /**\n     * Sets the status string of this tooltip.\n     *\n     * @param statusString the status string shown on the bottom of the tooltip\n     */\n    public void setStatusString(String statusString)\n    {\n        this.statusString = statusString;\n        isTextSet = true;\n    }\n\n    /**\n     * Sets the icon corresponding to the status of the tooltip.\n     *\n     * @param statusIcon the icon corresponding to the status of the tooltip\n     */\n    public void setStatusIcon(Icon statusIcon)\n    {\n        this.statusIcon = statusIcon;\n    }\n\n    /**\n     * Sets the icon to be displayed on the right of the tooltip.\n     *\n     * @param icon the icon to be displayed on the right of the tooltip\n     */\n    public void setRightIcon(Icon icon)\n    {\n        this.rightIcon = icon;\n    }\n\n    /**\n     * Returns the tooltip title.\n     *\n     * @return the tooltip title\n     */\n    public String getTitle()\n    {\n        return title;\n    }\n\n    /**\n     * Returns the tooltip line1.\n     *\n     * @return the tooltip line1\n     */\n    public String getLine1()\n    {\n        return line1;\n    }\n\n    /**\n     * Returns the tooltip line2.\n     *\n     * @return the tooltip line2\n     */\n    public String getLine2()\n    {\n        return line2;\n    }\n\n    /**\n     * Returns the tooltip line3.\n     *\n     * @return the tooltip line3\n     */\n    public String getLine3()\n    {\n        return line3;\n    }\n\n    /**\n     * Returns the tooltip image.\n     *\n     * @return the tooltip image\n     */\n    public Image getImage()\n    {\n        return image;\n    }\n\n    /**\n     * Returns the status icon.\n     *\n     * @return the status icon\n     */\n    public Icon getStatusIcon()\n    {\n        return statusIcon;\n    }\n\n    /**\n     * Returns the status string.\n     *\n     * @return the status string\n     */\n    public String getStatusString()\n    {\n        return statusString;\n    }\n\n    /**\n     * Returns the right icon.\n     *\n     * @return the right icon\n     */\n    public Icon getRightIcon()\n    {\n        return rightIcon;\n    }\n\n    /**\n     * Returns the preferred size of this tooltip.\n     *\n     * @return the preferred size of this tooltip\n     */\n    @Override\n    public Dimension getPreferredSize()\n    {\n        // If no text is set we're returning null to indicate that we don't want\n        // to have a custom tooltip, but a simple one.\n        if (!isTextSet)\n            return null;\n\n        if (prefWidth > 0 && prefHeight > 0)\n            return new Dimension(prefWidth, prefHeight);\n\n        this.setBorder(BorderFactory.createCompoundBorder(\n                BorderFactory.createLineBorder(BORDER_COLOR),\n                BorderFactory.createEmptyBorder(  BORDER_INTENT,\n                                                BORDER_INTENT,\n                                                BORDER_INTENT,\n                                                BORDER_INTENT)));\n\n        // Construct the title label.\n        if (title != null && title.length() > 0)\n        {\n            Font font = titleLabel.getFont();\n            font = font.deriveFont(Font.BOLD, font.getSize2D() + 2);\n            titleLabel.setFont(font);\n            titleLabel.setText(title);\n        }\n\n        // Construct the line1 label.\n        if (line1 != null && line1.length() > 0)\n        {\n            // Re-initialize the label if needed.\n            line1Label.setText(line1);\n        }\n\n        // Construct the line2 label.\n        if (line2 != null && line2.length() > 0)\n        {\n            // Re-initialize the label if needed.\n            line2Label.setText(line2);\n        }\n\n        // Construct the line3 label.\n        if (line3 != null && line3.length() > 0)\n        {\n            // Re-initialize the label if needed.\n            line3Label.setText(line3);\n        }\n\n        // Construct the status label.\n        if (statusString != null && statusString.length() > 0)\n        {\n            // Re-initialize the label if needed.\n            statusLabel.setText(statusString);\n        }\n\n        if (statusIcon != null)\n        {\n            // Re-initialize the label if needed.\n            statusLabel.setIcon(statusIcon);\n        }\n\n        // Construct the image label.\n        if (image != null)\n        {\n            // Re-initialize the label if needed.\n            imageLabel.setIcon(new ImageIcon(image));\n        }\n\n        // Construct the image label.\n        if (rightIcon != null)\n        {\n            // Re-initialize the label if needed.\n            rightIconLabel.setIcon(rightIcon);\n        }\n\n        int imageWidth = 0;\n        if (image != null)\n            imageWidth = image.getWidth(this)\n                + IMAGE_INTENT\n                + LINE_INTENT;\n\n        int rightImageWidth = 0;\n        if (rightIcon != null)\n            rightImageWidth = rightIcon.getIconWidth()\n                + IMAGE_INTENT;\n\n        int textWidth\n            = (titleLabel.getPreferredSize().width > 0)\n                ? titleLabel.getPreferredSize().width : 0;\n\n        if (line1Label.getPreferredSize().width > 0\n            && line1Label.getPreferredSize().width > textWidth)\n            textWidth = line1Label.getPreferredSize().width;\n\n        if (line2Label.getPreferredSize().width > 0\n            && line2Label.getPreferredSize().width > textWidth)\n            textWidth = line2Label.getPreferredSize().width;\n\n        if (line3Label.getPreferredSize().width > 0\n            && line3Label.getPreferredSize().width > textWidth)\n            textWidth = line3Label.getPreferredSize().width;\n\n        if (statusLabel.getPreferredSize().width > 0\n            && statusLabel.getPreferredSize().width > textWidth)\n            textWidth = statusLabel.getPreferredSize().width;\n\n        int preferredWidth\n            = imageWidth + textWidth + rightImageWidth + 2*BORDER_INTENT;\n\n        if (preferredWidth > MAX_WIDTH)\n            preferredWidth = MAX_WIDTH;\n\n        this.prefWidth = preferredWidth;\n\n        int textHeight = 0;\n        if (titleLabel.getPreferredSize().height > 0)\n            textHeight += titleLabel.getPreferredSize().height + V_GAP;\n\n        if (line1Label.getPreferredSize().height > 0)\n            textHeight += line1Label.getPreferredSize().height + V_GAP;\n\n        if (line2Label.getPreferredSize().height > 0)\n            textHeight += line2Label.getPreferredSize().height + V_GAP;\n\n        if (line3Label.getPreferredSize().height > 0)\n            textHeight += line3Label.getPreferredSize().height + V_GAP;\n\n        if (statusLabel.getPreferredSize().height > 0)\n            textHeight += statusLabel.getPreferredSize().height;\n\n        int imageHeight = 0;\n        if (image != null)\n            imageHeight = image.getHeight(this);\n\n        int rightImageHeight = 0;\n        if (rightIcon != null)\n            rightImageHeight = rightIcon.getIconHeight();\n\n        int preferredHeight = 2*BORDER_INTENT;\n\n        if (textHeight > imageHeight && textHeight > rightImageHeight)\n            preferredHeight += textHeight;\n        else if (imageHeight > textHeight && imageHeight > rightImageHeight)\n            preferredHeight += imageHeight;\n        else\n            preferredHeight += rightImageHeight;\n\n        this.prefHeight = preferredHeight;\n\n        return new Dimension(prefWidth, prefHeight);\n    }\n\n    /**\n     * Resets the tooltip to its default state.\n     */\n    public void resetTooltip()\n    {\n        this.image = null;\n        this.imageIconName = null;\n        this.statusIcon = null;\n        this.statusString = null;\n        this.title = null;\n        this.line1 = null;\n        this.line2 = null;\n        this.line3 = null;\n        this.rightIcon = null;\n        this.isTextSet = false;\n        this.prefWidth = -1;\n        this.prefHeight = -1;\n    }\n\n    /**\n     * A custom UI implementation for the extended tooltip.\n     */\n    private class ExtendedTooltipUI extends MetalToolTipUI\n    {\n        /**\n         * Returns the extended tooltip UI.\n         *\n         * @param g the <tt>Graphics</tt> object used to paint\n         * @return this extended tooltip if text is set, null - otherwise. If\n         * null is returned this means that we don't want to have a custom\n         * tooltip, but a simple one.\n         */\n        @Override\n        public void paint(Graphics g, JComponent c)\n        {\n            if (!isTextSet)\n                return;\n\n            int width = c.getWidth();\n            int height = c.getHeight();\n\n            g = g.create();\n            try\n            {\n                AntialiasingManager.activateAntialiasing(g);\n\n                // Paint background.\n                g.setColor(UIManager.getColor(\"ToolTip.background\"));\n                g.fillRect(0, 0, width, height);\n\n                // Paint border.\n                g.setColor(BORDER_COLOR);\n                g.drawRect(0, 0, width - 1, height - 1);\n\n                Font font = c.getFont();\n                FontMetrics metrics = c.getFontMetrics(font);\n                g.setFont(font);\n\n                int titleY = BORDER_INTENT;\n                int imageX = BORDER_INTENT;\n                int textX = 2*BORDER_INTENT;\n\n                if (image != null)\n                {\n                    g.drawImage(\n                        image,\n                        imageX,\n                        BORDER_INTENT\n                            + (height - 2*BORDER_INTENT - image.getHeight(c))/2,\n                        c);\n\n                    textX = imageX + image.getWidth(c) + IMAGE_INTENT;\n                }\n\n                int textWidth = width;\n\n                if (rightIcon != null)\n                    textWidth = width - rightIcon.getIconWidth() - IMAGE_INTENT\n                        - BORDER_INTENT;\n\n                if (rightIcon != null)\n                {\n                    rightIcon.paintIcon(\n                        c,\n                        g,\n                        width - rightIcon.getIconWidth() - BORDER_INTENT,\n                        (height - rightIcon.getIconHeight())/2);\n                }\n\n                g.setColor(UIManager.getColor(\"ToolTip.foreground\"));\n\n                if (title != null && title.length() > 0)\n                {\n                    Font oldFont = g.getFont();\n                    g.setFont(g.getFont().deriveFont(Font.BOLD, oldFont.getSize2D() + 2));\n\n                    titleY = BORDER_INTENT + metrics.getAscent();\n\n                    drawString(g, title, textX, titleY, textWidth - textX);\n\n                    g.setFont(oldFont);\n                }\n\n                int textY = titleY;\n\n                if (line1 != null && line1.length() > 0)\n                {\n                    if (title != null && title.length() > 0)\n                        textY += V_GAP;\n\n                    textY = textY + metrics.getHeight();\n\n                    drawString(g, line1, textX, textY, textWidth - textX);\n                }\n\n                if (line2 != null && line2.length() > 0)\n                {\n                    textY = textY + V_GAP + metrics.getHeight();\n\n                    drawString(g, line2, textX, textY, textWidth - textX);\n                }\n\n                if (line3 != null && line3.length() > 0)\n                {\n                    textY = textY + V_GAP + metrics.getHeight();\n\n                    drawString(g, line3, textX, textY, textWidth - textX);\n                }\n\n                if (statusString != null && statusString.length() > 0)\n                {\n                    textY = textY + V_GAP + metrics.getHeight();\n\n                    if (statusIcon != null)\n                    {\n                        statusIcon.paintIcon(c, g, textX, textY\n                            - statusIcon.getIconHeight() + metrics.getDescent());\n\n                        drawString(g, statusString, textX\n                            + statusIcon.getIconWidth() + H_GAP, textY,\n                            textWidth - textX);\n                    }\n                    else\n                        drawString(g, statusString, textX, textY,\n                            textWidth - textX);\n                }\n            }\n            finally\n            {\n                g.dispose();\n            }\n        }\n\n        /**\n         * Returns the preferred size of this tooltip.\n         *\n         * @return the preferred size of this tooltip\n         */\n        @Override\n        public Dimension getPreferredSize(JComponent c)\n        {\n            return getPreferredSize();\n        }\n\n        /**\n         * Draws the given string.\n         *\n         * @param g the <tt>Graphics</tt> object used for painting\n         * @param text the text to draw\n         * @param x the X position\n         * @param y the Y position\n         * @param width the width of the text\n         */\n        private void drawString(Graphics g, String text, int x, int y, int width)\n        {\n            FontMetrics metrics = g.getFontMetrics();\n\n            if (metrics.stringWidth(text) < width)\n            {\n                g.drawString(text, x, y);\n                return;\n            }\n\n            ResourceManagementService resources = GuiActivator.getResources();\n            String dots = resources.getI18NString(\"service.gui.THREE_DOTS\");\n\n            StringBuilder buff = new StringBuilder();\n            int dotsWidth = metrics.stringWidth(dots);\n            int i = 0;\n            for (i = 0; i < text.length(); i++)\n            {\n                if (metrics.stringWidth(buff.toString() + text.charAt(i)\n                    + dots) > width)\n                    break;\n\n                buff.append(text.charAt(i));\n            }\n\n            g.drawString(buff.toString() + dots, x, y);\n        }\n    }\n}\n\u0005End File\u0006# jitsi/jitsi\n/*\n * Jitsi, the OpenSource Java VoIP and Instant Messaging client.\n *\n * Copyright @ 2015 Atlassian Pty Ltd\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage net.java.sip.communicator.util;\n\nimport java.io.*;\nimport java.util.*;\n\nimport javax.swing.*;\nimport javax.swing.text.*;\nimport javax.swing.text.html.*;\n\n/**\n * A default implementation of the <tt>HTMLTextReplacer</tt> interface.\n *\n * @author Yana Stamcheva\n */\npublic class DefaultHTMLTextReplacer\n    implements HTMLTextReplacer\n{\n    /**\n     * The list of all occurrences.\n     */\n    private final LinkedList<Occurrence> occurrences\n        = new LinkedList<Occurrence>();\n\n    /**\n     * The <tt>JTextPane</tt> to which this replacer is set.\n     */\n    private final JTextPane textPane;\n\n    /**\n     * The container document of this text pane.\n     */\n    private final HTMLDocument document;\n\n    /**\n     * Creates an instance of <tt>DefaultHTMLTextReplacer</tt>.\n     *\n     * @param textPane the text pane to which this replacer is set\n     */\n    public DefaultHTMLTextReplacer(JTextPane textPane)\n    {\n        this.textPane = textPane;\n\n        document = (HTMLDocument) textPane.getDocument();\n    }\n\n    /**\n     * Adds the given replace occurrence.\n     *\n     * @param startIndex the start index\n     * @param endIndex the end index\n     * @param replacement the replacement\n     */\n    public void addOccurrence(int startIndex, int endIndex, String replacement)\n    {\n        Occurrence occurrence = new Occurrence(startIndex, endIndex, replacement);\n\n        occurrences.add(occurrence);\n    }\n\n    /**\n     * Replaces all registered occurrences.\n     */\n    public void replace()\n    {\n        Collections.sort(occurrences);\n\n        Iterator<Occurrence> i = occurrences.iterator();\n\n        while (i.hasNext())\n        {\n            Occurrence o = i.next();\n\n            try\n            {\n                HTMLEditorKit kit = (HTMLEditorKit) textPane.getEditorKit();\n\n                String replacement = o.replacement;\n\n                // If replacement string contains new lines we need to convert\n                // them to <br/> tags.\n                replacement = replacement.replaceAll(\"\\n\", \"<br/>\");\n\n                document.remove(o.startIndex, o.endIndex - o.startIndex);\n                kit.insertHTML(document, o.startIndex, replacement, 0, 0, null);\n            }\n            catch (BadLocationException e)\n            {\n                // This should not happen, but if at one point it happens we\n                // don't want to crash the interface.\n                if (e.getMessage() != null)\n                {\n                    System.err.println(e.getMessage());\n                }\n                else\n                {\n                    e.printStackTrace();\n                }\n            }\n            catch (IOException e)\n            {\n                // This should not happen, but if at one point it happens we\n                // don't want to crash the interface.\n                if (e.getMessage() != null)\n                {\n                    System.err.println(e.getMessage());\n                }\n                else\n                {\n                    e.printStackTrace();\n                }\n            }\n        }\n    }\n\n    /**\n     * Occurrence structure used in this replacer.\n     */\n    private static class Occurrence\n        implements Comparable<Occurrence>\n    {\n        /**\n         * The start index.\n         */\n        int startIndex;\n\n        /**\n         * The end index.\n         */\n        int endIndex;\n\n        /**\n         * The replacement.\n         */\n        String replacement;\n\n        /**\n         * Creates an <tt>Occurrence</tt> by specifying the start index, the end\n         * index and the replacement.\n         *\n         * @param startIndex the start index\n         * @param endIndex the end index\n         * @param replacement the replacement\n         */\n        public Occurrence(int startIndex, int endIndex, String replacement)\n        {\n            this.startIndex = startIndex;\n            this.endIndex = endIndex;\n            this.replacement = replacement;\n        }\n\n        /**\n         * Compares the indexes of this and the given occurrence in order to\n         * order them.\n         *\n         * @param o the occurrence to compare with\n         * @return -1 if this occurrence should be before the given one, 1 if\n         * this occurrence should be after the given one\n         */\n        public int compareTo(Occurrence o)\n        {\n            // The bigger the start index, the further we are in the string\n            // The further we are in the string, the later we should do the\n            // replacement (that's why the minus is here).\n            int res = -(this.startIndex - o.startIndex);\n\n            // We need to impose an ordering, otherwise equals() and\n            // compareTo() are inconsistent\n            if (res == 0)\n            {\n                res = o.hashCode() - this.hashCode();\n            }\n            return res;\n        }\n    }\n}\n\u0005End File\u0006# jitsi/jitsi\n/*\n * Jitsi, the OpenSource Java VoIP and Instant Messaging client.\n *\n * Copyright @ 2015 Atlassian Pty Ltd\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage net.java.sip.communicator.service.gui;\n\nimport java.util.*;\n\n/**\n * The <tt>UIService</tt> offers generic access to the graphical user interface\n * for all modules that would like to interact with the user.\n *\n * @author Yana Stamcheva\n */\npublic interface UIService\n{\n    /**\n     * Returns TRUE if the application is visible and FALSE otherwise. This\n     * method is meant to be used by the systray service in order to detect the\n     * visibility of the application.\n     *\n     * @return <code>true</code> if the application is visible and\n     * <code>false</code> otherwise.\n     *\n     * @see #setVisible(boolean)\n     */\n    public boolean isVisible();\n\n    /**\n     * Shows or hides the main application window depending on the value of\n     * parameter <code>visible</code>. Meant to be used by the systray when it\n     * needs to show or hide the application.\n     *\n     * @param visible if <code>true</code>, shows the main application window;\n     * otherwise, hides the main application window.\n     *\n     * @see #isVisible()\n     */\n    public void setVisible(boolean visible);\n\n    /**\n     * Returns the current location of the main application window. The returned\n     * point is the top left corner of the window.\n     *\n     * @return The top left corner coordinates of the main application window.\n     */\n    public java.awt.Point getLocation();\n\n    /**\n     * Locates the main application window to the new x and y coordinates.\n     *\n     * @param windowLocation the new coordinates for the main application window.\n     */\n    public void setLocation(java.awt.Point windowLocation);\n\n    /**\n     * Returns the size of the main application window.\n     *\n     * @return the size of the main application window.\n     */\n    public java.awt.Dimension getSize();\n\n    /**\n     * Sets the size of the main application window.\n     *\n     * @param windowSize the new size for the main application window.\n     */\n    public void setSize(java.awt.Dimension windowSize);\n\n    /**\n     * Minimizes the main application window.\n     */\n    public void minimize();\n\n    /**\n     * Maximizes the main application window.\n     */\n    public void maximize();\n\n    /**\n     * Restores the main application window.\n     */\n    public void restore();\n\n    /**\n     * Resize the main application window with the given width and height.\n     *\n     * @param width The new width.\n     * @param height The new height.\n     */\n    public void resize(int width, int height);\n\n    /**\n     * Moves the main application window to the given coordinates.\n     *\n     * @param x The x coordinate.\n     * @param y The y coordinate.\n     */\n    public void move(int x, int y);\n\n    /**\n     * Brings the focus to the main application window.\n     */\n    public void bringToFront();\n\n    /**\n     * Registers a <tt>WindowListener</tt> with the main application window.\n     * @param l the <tt>WindowListener</tt> to register\n     */\n    public void addWindowListener(java.awt.event.WindowListener l);\n\n    /**\n     * Removes a <tt>WindowListener</tt> from the main application window.\n     * @param l the <tt>WindowListener</tt> to remove\n     */\n    public void removeWindowListener(java.awt.event.WindowListener l);\n\n    /**\n     * Returns an array of all available chat containers.\n     *\n     * @return an array of all available chat containers\n     */\n    public Collection <ChatPanel> getAllChatPanels();\n\n    /**\n     * Returns the selected chat panel.\n     *\n     * @return the selected chat panel\n     */\n    public ChatPanel getSelectedChatPanel();\n\n    /**\n     * Implements the <code>SystrayService.setSystrayIcon</code> method.\n     * Indicates that the Systray icon should be created.\n     *\n     * @param trayIcon the icon to be showed\n     */\n    public void setSystrayIcon(SystrayService.SysTrayIcon trayIcon);\n\n    /**\n     * Get the corresponding <tt>PopupDialog</tt> implementation.\n     *\n     * @return the <tt>PopupDialog</tt> implementation\n     */\n    public PopupDialog getPopupDialog();\n\n    /**\n     * Get the corresponding <tt>ConfigurationContainer</tt> implementation.\n     *\n     * @return the <tt>ConfigurationContainer</tt> implementation\n     */\n    public ConfigurationContainer getConfigurationContainer();\n\n    /**\n     * Gets the <tt>LoginManager</tt> through which the user logs in and out.\n     *\n     * @return the <tt>LoginManager</tt> through which the user logs in and out\n     */\n    public LoginManager getLoginManager();\n\n    /**\n     * Returns the <tt>AccountRegistrationWizardContainer</tt>.\n     *\n     * @return the <tt>AccountRegistrationWizardContainer</tt>\n     */\n    public AccountRegistrationWizardContainer getAccountRegWizardContainer();\n\n    /**\n     * Adds the specified UI component to this <tt>UIService</tt>. The method is\n     * meant to be used by plugins to register their own UI components into the\n     * application.\n     *\n     * @param component the <tt>UIComponent</tt> to add\n     */\n    public void addComponent(UIComponent component);\n\n    /**\n     * Removes the specified UI component from this <tt>UIService</tt>. The\n     * method is meant to be used by plugins to unregister their own UI\n     * components from the application.\n     *\n     * @param component the <tt>UIComponent</tt> to remove\n     */\n    public void removeComponent(UIComponent component);\n\n    /**\n     * Returns the <tt>UIComponent</tt> corresponding to the given\n     * <tt>containerName</tt> and <tt>key</tt>.\n     *\n     * @param containerID the id of the container, where the component is located\n     * @param key the key under which the component is stored\n     * @return the <tt>UIComponent</tt> corresponding to the given\n     * <tt>containerName</tt> and <tt>key</tt>\n     */\n    public UIComponent getComponent(Container containerID, Object key);\n\n    /**\n     * Returns all the <tt>UIComponent</tt>s for the given <tt>containerID</tt>.\n     *\n     * @param containerID the id of the container, where the components are\n     * located\n     * @return all the <tt>UIComponent</tt>s for the given <tt>containerID</tt>\n     */\n    public Collection<UIComponent> getComponentsForContainer(\n        Container containerID);\n\n    /**\n     * Returns an enumeration of the available containers in the UI.\n     *\n     * @return an enumeration of the available containers\n     */\n    public Collection<Container> getContainers();\n\n    /**\n     * Returns the current chat window.\n     *\n     * @return the current chat window\n     */\n    public ChatWindow getCurrentChat();\n\n    /**\n     * Returns the chat window for the contact corresponding to the given\n     * <tt>Contact</tt> and creates it if it doesn't exist.\n     *\n     * @param contact the <tt>Contact</tt> to search for chat window\n     * @return the chat window for the contact corresponding to the given\n     * <tt>Contact</tt> and creates it if it doesn't exist\n     */\n    public ChatPanel getChatPanel(Object contact);\n\n    /**\n     * Returns the contact list object.\n     *\n     * @return the contact list object\n     */\n    public ContactList getContactList();\n\n    /**\n     * Returns the conference call history table of the UI.\n     *\n     * @return the conference call history table of the UI\n     */\n    public Collection<Call> getConferenceCallHistory();\n\n    /**\n     * Returns the call history table of the UI.\n     *\n     * @return the call history table of the UI\n     */\n    public Collection<Call> getCallHistory();\n\n    /**\n     * Hides all messages in the contact list area.\n     */\n    public void hideAllContactListMessages();\n\n    /**\n     * Adds the given <tt>PluginComponent</tt> to the container given by\n     * <tt>containerID</tt>.\n     *\n     * @param containerID the id of the container, where the component should be\n     * added.\n     * @param component the <tt>PluginComponent</tt> to add\n     * @return the added component.\n     */\n    public Object addPluginComponent(Container containerID, PluginComponent component);\n\n    /**\n     * Removes the given <tt>PluginComponent</tt> from the container given by\n     * <tt>containerID</tt>.\n     *\n     * @param containerID the id of the container, where the component should be\n     * removed from.\n     * @param component the <tt>PluginComponent</tt> to remove\n     */\n    public void removePluginComponent(Container containerID, PluginComponent component);\n\n    /**\n     * Returns a collection of all registered plug-in components.\n     *\n     * @return a collection of all registered plug-in components\n     */\n    public Collection<PluginComponent> getAllPluginComponents();\n\n    /**\n     * Returns all components registered by a given plug-in.\n     *\n     * @param pluginName the name of the plug-in.\n     * @return a collection of all components registered by the given plug-in.\n     */\n    public Collection<PluginComponent>\n        getPluginComponentsForPlugin(String pluginName);\n\n    /**\n     * Adds the given <tt>ExportedWindow</tt> in order to be shown in the\n     * <tt>Help</tt> menu.\n     *\n     * @param window the <tt>ExportedWindow</tt> to be added into the\n     * <tt>Help</tt> menu.\n     */\n    public void addExportedWindow(ExportedWindow window);\n\n    /**\n     * Removes the given <tt>ExportedWindow</tt> from the list of windows shown\n     * in the <tt>Help</tt> menu.\n     *\n     * @param window the <tt>ExportedWindow</tt> to be removed from the\n     * <tt>Help</tt> menu.\n     */\n    public void removeExportedWindow(ExportedWindow window);\n\n    /**\n     * Shows a <tt>ChatRoomAuthenticationWindow</tt> for the given\n     * <tt>room</tt> and hides it when one of the buttons is clicked.\n     *\n     * @param chatRoomResolver The chat room authentication resolver instance\n     * that will be able to resolve the password for the chat room.\n     * @param reason the reason for the authentication.\n     */\n    public void beginChatRoomAuthentication(\n        ChatRoomAuthenticationWindowListener chatRoomResolver, String reason);\n\n    /**\n     * Adds a customized authentication window that handles authentication with\n     * a certificate.\n     *\n     * @param window the window to add\n     */\n    public void addCertificateVerificationWindow(\n        CertificateVerificationWindow window);\n\n    /**\n     * Removes a customized authentication window that handles authentication\n     * with a certificate.\n     *\n     * @param window the window to remove\n     */\n    public void removeCertificateVerificationWindow(\n        CertificateVerificationWindow window);\n\n    /**\n     * Creates a <tt>ChatWindow</tt> for the given <tt>ChatRoom</tt>.\n     *\n     * @param room the <tt>ChatRoom</tt> for which to create a\n     * <tt>ChatWindow</tt>\n     * @return a <tt>ChatWindow</tt> for the given <tt>ChatRoom</tt>\n     */\n    public ChatRoomWrapper createChatRoomWindow(ChatRoom room);\n\n    /**\n     * Returns a <tt>ChatPanel</tt> for the given <tt>ChatRoom</tt> and creates\n     * it if it doesn't exist.\n     *\n     * @param room the <tt>ChatRoom</tt> for which the chat panel is created\n     * @return a <tt>ChatPanel</tt> for the given <tt>ChatRoom</tt>, which\n     * could be newly created\n     */\n    public ChatPanel getChatPanel(ChatRoom room);\n\n    /**\n     * Returns an Iterator over a set of windowID-s of open ChatWindows\n     *\n     * @return Iterator\n     */\n    public Iterator<String> getChatWindowsIterator();\n\n    /**\n     * Returns the <tt>ChatWindowManager</tt> handling chat windows in the UI.\n     *\n     * @return the <tt>ChatWindowManager</tt>\n     */\n    public ChatWindowManager getChatWindowManager();\n\n    /**\n     * Returns a list of all contact details available for the given contact id\n     * and <tt>OperationSet</tt>. For example this would include all possible\n     * phones(home, work, mobile, ...).\n     *\n     * @param detailsList the list of contact details, to which the new detail(s)\n     * obtained for <tt>opSet</tt> will be added\n     * @param contact the <tt>Contact</tt> for which the details are wanted\n     * @param opSet the <tt>OperationSet</tt> for which the detail is wanted\n     */\n    public void getContactDetails(\n            List<UIContactDetail> detailsList,\n            Contact contact,\n            Class<? extends OperationSet> opSet);\n\n    /**\n     * Returns a list of all contact details available for the given contact id\n     * and <tt>OperationSet</tt>. For example this would include all possible\n     * phones(home, work, mobile, ...).\n     *\n     * @param detailsList the list of contact details, to which the new detail(s)\n     * obtained for <tt>opSet</tt> will be added\n     * @param contact the <tt>Contact</tt> for which the details are wanted\n     * @param opSet the <tt>OperationSet</tt> for which the detail is wanted\n     * @param preferredDetails a list of preferred details\n     */\n    public void getContactDetails(\n            List<UIContactDetail> detailsList,\n            Contact contact,\n            Class<? extends OperationSet> opSet,\n            List<Class<? extends OperationSet>> preferredDetails);\n\n    /**\n     * Returns a list of all contact details available for the given chat room\n     * and <tt>OperationSet</tt>.\n     *\n     * @param chatRoomWrapper the <tt>ChatRoomWrapper</tt> for which the details\n     * are wanted\n     * @param opSet the <tt>OperationSet</tt> for which the detail is wanted\n     * @return a list of all contact details available for the given chat room\n     * and <tt>OperationSet</tt>\n     */\n    public List<UIContactDetail> getChatRoomContactDetails(\n            ChatRoomWrapper chatRoomWrapper,\n            Class<? extends OperationSet> opSet);\n\n    /**\n     * Creates a <tt>ContactInfoDetailsPanel</tt> with details for the given\n     * <tt>SourceContact</tt>.\n     *\n     * @param contact the <tt>SourceContact</tt> for which to add the details\n     * @return the created <tt>ContactInfoDetailsPanel</tt>\n     */\n    public Object createSourceContactDetailsPanel(SourceContact contact);\n\n    /**\n     * Returns a list of all currently registered external source\n     * <tt>ContactSourceService</tt>-s.\n     *\n     * @return a list of all currently registered external source\n     * <tt>ContactSourceService</tt>-s\n     */\n    public Collection<ContactSourceService> getContactSources();\n\n    /**\n     * Returns a list of <tt>ContactInfoDetailsPanel</tt>-s for the given\n     * <tt>ChatRoomMember</tt>.\n     *\n     * @param chatRoom the chat room to which the member belongs\n     * @param member the <tt>ChatRoomMember</tt> for which to add the details\n     * @return a list of <tt>ContactInfoDetailsPanel</tt>-s for the given\n     * <tt>ChatRoomMember</tt>\n     */\n    public Object createChatRoomMemberDetailsPanel(ChatRoom chatRoom,\n                                                   ChatRoomMember member);\n\n    /**\n     * Shows dialog with the credentials for an account with the given\n     * protocolProvider and returns the credentials from the user.\n     *\n     * @param protocolProvider the protocol provider for the account\n     * @return the credentials or null if the user has canceled the dialog.\n     */\n    public UserCredentials getCredentials(\n        ProtocolProviderService protocolProvider);\n\n    /**\n     * Shows dialog with the credentials for an account with the given\n     * protocolProvider, message and returns the credentials from the user.\n     *\n     * @param protocolProvider the protocol provider for the account\n     * @param message the message to be displayed to the user\n     * @return the credentials or null if the user has canceled the dialog.\n     */\n    public UserCredentials getCredentials(\n        ProtocolProviderService protocolProvider, String message);\n\n    /**\n     * Shows dialog with the credentials for an account with the given\n     * protocolProvider and returns the credentials from the user.\n     *\n     * @param protocolProvider the protocol provider for the account\n     * @param message the message to be displayed to the user\n     * @param defaultValues the default values to display\n     * @param isUserNameEditable if the user name can be edited or not\n     * @param errorMessage an error message to show to the user on the dialog,\n     * or null\n     * @return the credentials or null if the user has canceled the dialog.\n     */\n    public UserCredentials getCredentials(\n        ProtocolProviderService protocolProvider,\n        String message,\n        UserCredentials defaultValues,\n        boolean isUserNameEditable,\n        String errorMessage);\n\n    /**\n     * Opens the community web page.\n     */\n    public void openCommunityWebPage();\n\n    /**\n     * Updates Jitsi and restart if asked and needed.\n     */\n    public void checkForUpdates(boolean isManual);\n\n    /**\n     * Shows error message with a exception and stack trace.\n     *\n     * @param title the title of the message.\n     * @param e the exception.\n     */\n    public void showExceptionMessageDetail(String title, Throwable e);\n\n    /**\n     * Returns the <tt>SecurityAuthority</tt> implementation related to this\n     * <tt>UIService</tt>.\n     *\n     * @return the <tt>SecurityAuthority</tt> implementation related to this\n     * <tt>UIService</tt>\n     */\n    public SecurityAuthority getDefaultSecurityAuthority();\n\n    /**\n     * Updates the status of a contact in contact list.\n     * @param protocolContact the <tt>Contact</tt> to update\n     */\n    public void updateContactStatus(Contact protocolContact);\n\n    /**\n     * Closes the window given by its name.\n     * @param windowName the name of the window to close\n     */\n    public void closeExportedWindow(WindowID windowName);\n\n    /**\n     * Provides all currently instantiated <tt>Chats</tt>.\n     * @return all active <tt>Chats</tt>.\n     */\n    public Collection <Chat> getAllChats();\n\n    /**\n     * Returns the <tt>Chat</tt> with the contact with ID contactID.\n     * @param contactID the ID of the contact.\n     * @return the <tt>Chat</tt> with the contact with ID contactID.\n     */\n    public Chat getChat(String contactID);\n\n    /**\n     * Returns default contact details for the given chat room wrapper.\n     *\n     * @param chatRoomWrapper the chat room wrapper, for which the contact details\n     * would be obtained\n     * @return default contact details for the given chat room wrapper\n     */\n    public UIContactDetail getChatRoomDefaultContactDetail(\n            ChatRoomWrapper chatRoomWrapper);\n\n    /**\n     * Adds all contacts to the contact list.\n     *\n     * @param accounts the accounts to add to the contact list. These would be\n     * both MetaContacts and groups.\n     */\n    public void addAllToContactList(Collection<SourceContact> accounts);\n\n    /**\n     * Adds a protocol contact to the contact list.\n     *\n     * @param protocolContact the protocol contact to add\n     * @param parent the group to add the contact to\n     */\n    public void addProtocolContactToContactList(\n            Contact protocolContact,\n            ContactGroup parent);\n\n    /**\n     * Adds protocol contacts to the contact list.\n     *\n     * @param protocolContacts the protocol contacts to add\n     * @param parent the group to add the contacts to\n     */\n    public void addProtocolContactsToContactList(\n            Collection<Contact> protocolContacts,\n            ContactGroup parent);\n\n    /**\n     * Shows a custom dialog.\n     *\n     * @param dialog The Dialog to display.\n     */\n    public void showDialog(Object dialog);\n\n    /**\n     * Shows a custom dialog.\n     *\n     * @param dialog The Dialog to display.\n     * @param modal specifies if the dialog should be modal or not.\n     */\n    public void showDialog(Object dialog, boolean modal);\n\n    /**\n     * Creates a new contact group.\n     *\n     * @param groupUID The unique identifier of the new group.\n     * @param parentUID The unique identifier of the parent group.\n     * @param protocolProvider The protocol provider to which the group\n     * corresponds.\n     * @return The newly created contact group.\n     */\n    public MetaContactGroup createMetaContactGroup(\n            String groupUID,\n            String parentUID,\n            ProtocolProviderService protocolProvider);\n\n    /**\n     * Handles user input.\n     *\n     * @param commandLine The commands line to parse\n     */\n    public void handleCommandLine(String commandLine);\n\n    /**\n     * Returns history window.\n     *\n     * @return history window instance\n     */\n    public Object getHistoryWindowInstance();\n\n    /**\n     * A wrapper for <tt>JDialog</tt> instantiation.\n     *\n     * @param uiFrame the parent of the dialog\n     * @param title the title of the dialog\n     * @param modal indicate if the dialog is modal\n     * @return a (hopefully) OS-native dialog instance\n     */\n    public Dialog createDialog(String title, boolean modal);\n\n    /**\n     * Show the desktop settings.\n     */\n    public void showDesktopSettings();\n\n    /**\n     * Create or join a call to the given callees.\n     * Create a call if no call exists yet, or join it otherwise.\n     * @param callees The list of addresses that we are calling\n     * @return The resulting call object\n     */\n    public Call createCall(String[] callees);\n\n    /**\n     * Create or join a video bridge conference.\n     * Create a conference if no conference exists yet, or join it otherwise.\n     * @param callees The list of addresses that we are calling\n     * @return The resulting call object\n     */\n    public Call createConferenceCall(String[] callees);\n\n    /**\n     * Prepare the video call.\n     */\n    public void showPreCallDialog(Call call);\n\n    /**\n     * A wrapper to show the call dialog once the call has been started.\n     * @param callID The ID of the call to show\n     * @return <tt>true</tt> if the call has been successfully shown\n     */\n    public boolean showCallDialog(String callID);\n\n    /**\n     * Opens a chat window for a contact or conference for a given protocol\n     * <tt>Contact</tt>.\n     * <p>\n     * <b>Note</b>: Conference with parameter <tt>protocolContact</tt>\n     * may be created.\n     * </p>\n     *\n     * @param protocolContact the protocol <tt>Contact</tt> for which to open\n     * a chat window\n     */\n    public void startChat(Contact protocolContact);\n\n    /**\n     * Opens a chat window for a contact or conference for a given protocol\n     * <tt>Contact</tt>.\n     * <p>\n     * <b>Note</b>: Conference with parameter <tt>protocolContact</tt>\n     * may be created.\n     * </p>\n     *\n     * @param protocolContact the protocol <tt>Contact</tt> for which to open\n     * a chat window\n     * @param messageText a message text to send to the contact once the\n     * chat window is created.\n     */\n    public void startChat(Contact protocolContact, String messageText);\n\n    /**\n     * Opens a private chat with the given <tt>chatRoomMember</tt>.\n     *\n     * @param chatRoomMember the <tt>chatRoomMember</tt> to whom we should\n     * send the message\n     * @param contactResource the <tt>ChatRoomMemberRole</tt> role of the member\n     * we're sending a message to\n     * @param messageText the message to send\n     */\n    public void startChat(ChatRoomMember chatRoomMember,\n                          String contactResource,\n                          String messageText);\n\n    /**\n     * Opens a chat window for a contact for a given <tt>String</tt>.\n     *\n     * @param protocolProvider the protocol provider to which the contact should\n     * belong to\n     * @param contactID the ID of the contact for which to open a chat window\n     */\n    public void startChat(ProtocolProviderService protocolProvider,\n                          String contactID);\n\n    /**\n     * Indicates if there's an active chat with the given handle.\n     *\n     * @param protocolProvider the protocol provider to which the contact should\n     * belong to\n     * @param contactID the ID of the contact for which to check an active chat\n     * @return <tt>true</tt> if there's an active chat with the given contact,\n     * <tt>false</tt> - otherwise\n     */\n    public boolean hasChat(ProtocolProviderService protocolProvider,\n                          String contactID);\n\n    /**\n     * Indicates if there's an active chat with the given contact.\n     *\n     * @param protocolContact the contact for which to check an active chat\n     * @return <tt>true</tt> if there's an active chat with the given contact,\n     * <tt>false</tt> - otherwise\n     */\n    public boolean hasChat(Contact protocolContact);\n\n    /**\n     * Opens a chat window for a contact for a given <tt>String</tt> and a\n     * specific message.\n     *\n     * @param protocolProvider the protocol provider to which the contact should\n     * belong to\n     * @param contactID the ID of the contact for which to open a chat window\n     * @param messageText the message to send\n     */\n    public void startChat(ProtocolProviderService protocolProvider,\n                          String contactID,\n                          String messageText);\n\n    /**\n     * Opens a chat conference.\n     *\n     * @param contacts the contacts for which to open a chat conference\n     */\n    public void startChat(List<Contact> contacts);\n\n    /**\n     * Returns the <tt>AuthenticationWindowService</tt> implementation,\n     * that manages the display of the authentication window.\n     *\n     * @return the <tt>AuthenticationWindowService</tt> implementation,\n     * that manages the display of the authentication window\n     */\n    public AuthenticationWindowService\n        getAuthenticationWindowService();\n\n    /**\n     * Returns the <tt>ExportedWindow</tt> corresponding to the given\n     * <tt>windowID</tt>.\n     *\n     * @param windowID the id of the wanted <tt>ExportedWindow</tt>\n     * @return the <tt>ExportedWindow</tt> corresponding to the given\n     * <tt>windowID</tt>\n     * @throws WindowNotFoundException if the window couldn't be found\n     */\n    public ExportedWindow getExportedWindow(WindowID windowID)\n        throws WindowNotFoundException;\n\n    /**\n     * Shows an add contact confirmation dialog. The dialog should ask the user\n     * for permission before adding a contact to their contact list.\n     *\n     * @param uiSourceContactDescriptor the source contact descriptor which will\n     * be used to show information for the contact\n     * @return <tt>true</tt> if the user has accepted the contact,\n     * <tt>false</tt> otherwise\n     */\n    public boolean showAddContactConfirmationDialog(\n            SourceContactDescriptor uiSourceContactDescriptor);\n\n    /**\n     * Shows an add group dialog.\n     *\n     * @return <tt>true</tt> if the user has chosen to create the group,\n     * <tt>false</tt> otherwise\n     */\n    public boolean showAddGroupDialog();\n\n    /**\n     * Shows a rename group dialog.\n     *\n     * @param group the <tt>UIGroupImpl</tt> to rename\n     * @return <tt>true</tt> if the user has chosen to rename the group,\n     * <tt>false</tt> otherwise\n     */\n    public boolean showRenameGroupDialog(Object group);\n\n    /**\n     * Shows a rename contact dialog.\n     *\n     * @param uiContact the <tt>UIContactImpl</tt> to rename\n     * @return <tt>true</tt> if the user has chosen to rename the contact,\n     * <tt>false</tt> otherwise\n     */\n    public boolean showRenameContactDialog(Object uiContact);\n\n    /**\n     * Shows a remove contact dialog.\n     *\n     * @param uiContact the <tt>UIContactImpl</tt> to remove\n     * @return <tt>true</tt> if the user has chosen to remove the contact,\n     * <tt>false</tt> otherwise\n     */\n    public boolean showRemoveContactConfirmationDialog(Object uiContact);\n\n    /**\n     * Shows a remove contact from group dialog.\n     *\n     * @param uiContact the <tt>UIContactImpl</tt> to remove from group\n     * @param group the <tt>UIGroupImpl</tt> to remove from\n     * @return <tt>true</tt> if the user has chosen to remove the contact from\n     * the group, <tt>false</tt> otherwise\n     */\n    public boolean showRemoveContactFromGroupConfirmationDialog(\n        Object uiContact, Object group);\n\n    /**\n     * Shows a remove group dialog.\n     *\n     * @param group the <tt>UIGroupImpl</tt> to remove\n     * @return <tt>true</tt> if the user has chosen to remove the group,\n     * <tt>false</tt> otherwise\n     */\n    public boolean showRemoveGroupConfirmationDialog(Object group);\n\n    /**\n     * Shows a select group dialog.\n     *\n     * @param uiContact the <tt>UIContactImpl</tt> to move\n     * @return the selected group or null if the operation has been canceled\n     */\n    public Object showSelectGroupDialog(Object uiContact);\n\n    /**\n     * Shows a move to group dialog.\n     *\n     * @param uiContact the <tt>UIContactImpl</tt> to move\n     * @param group the <tt>UIGroupImpl</tt> to move to\n     * @return <tt>true</tt> if the user has chosen to move the contact from\n     * the group, <tt>false</tt> otherwise\n     */\n    public boolean showMoveToGroupConfirmationDialog(\n        Object uiContact, Object group);\n\n    /**\n     * Shows a move to group dialog.\n     *\n     * @param uiContact the <tt>UIContactImpl</tt> to move\n     * @param group the <tt>UIGroupImpl</tt> to move to\n     * @return <tt>true</tt> if the user has chosen to move the contact from\n     * the group, <tt>false</tt> otherwise\n     */\n    public boolean showAddContactToGroupConfirmationDialog(\n        Object uiContact, Object group);\n\n    /**\n     * Shows the add search contact dialog.\n     *\n     * @param uiContact the contact to add\n     * @return <tt>true</tt> if the user has chosen to add the contact,\n     * <tt>false</tt> otherwise\n     */\n    public boolean showAddSearchContactDialog(Object uiContact);\n\n    /**\n     * Shows a create group dialog.\n     *\n     * @return the created group name\n     */\n    public String showCreateGroupDialog();\n\n    /**\n     * Show a dialog with informations about the specified <tt>protocolProvider</tt>\n     * @param protocolProvider The protocol provider for which we'd like information\n     */\n    public void showProviderInfoDialog(ProtocolProviderService protocolProvider);\n\n    /**\n     * Show a dialog with information about all registered accounts.\n     * @param protocolProviders the set of <tt>ProtocolProviderService</tt>s to use\n     * to show accounts information.\n     */\n    public void showAllAccountsDialog(Collection<ProtocolProviderService> protocolProviders);\n\n    /**\n     * Show a dialog with information about the account corresponding to the\n     * <tt>protocolProvider</tt>.\n     * @param protocolProvider The protocol provider for which we'd like information\n     */\n    public void showIncomingCallDialog(ProtocolProviderService protocolProvider,\n                                      String caller);\n\n    /**\n     * Selects or unselects the given <tt>contact</tt> in the contact list.\n     * @param contact the contact to select\n     * @param selected indicates if the contact should be selected or not\n     */\n    public void setContactSelected(Contact contact, boolean selected);\n\n    /**\n     * Shows a notification message for the given <tt>eventType</tt>.\n     *\n     * @param eventType the event type for which we show the notification\n     * @param title the title of the notification\n     * @param message the message to show\n     * @param icon the icon to show\n     */\n    public void showNotificationForEvent(\n            String eventType, String title, String message, byte[] icon);\n\n    /**\n     * Shows a notification message for the given <tt>eventType</tt>.\n     *\n     * @param eventType the event type for which we show the notification\n     * @param title the title of the notification\n     * @param message the message to show\n     * @param imageIconPath path to an image icon to show, can be null\n     */\n    public void showNotificationForEvent(\n            String eventType, String title, String message, String imageIconPath);\n\n    /**\n     * Shows a notification message for the given <tt>eventType</tt>.\n     *\n     * @param eventType the event type for which we show the notification\n     * @param title the title of the notification\n     * @param message the message to show\n     */\n    public void showNotificationForEvent(\n            String eventType, String title, String message);\n\n    /**\n     * Shows a notification for a <tt>ChatRoomNotificationEvent</tt>.\n     *\n     * @param event the <tt>ChatRoomNotificationEvent</tt> to show\n     */\n    public void showChatRoomNotification(ChatRoomNotificationEvent event);\n\n    /**\n     * Shows a notification message for the given <tt>eventType</tt> and shows\n     * the given window in the notification.\n     *\n     * @param eventType the event type for which we show the notification\n     * @param title the title of the notification\n     * @param message the message to show\n     * @param window the window to show\n     */\n    public void showNotificationForEvent(\n            String eventType, String title, String message, Object window);\n\n    /**\n     * Shows a notification message for the given <tt>eventType</tt> and handles\n     * clicking on the shown notification for the given actionType.\n     *\n     * @param eventType the event type for which we show the notification\n     * @param title the title of the notification\n     * @param message the message to show\n     * @param actionType the action type which would be handled when user clicks\n     * on the notification\n     * @param actionSource the source of the action\n     */\n    public void showNotificationForEvent(\n            String eventType,\n            String title,\n            String message,\n            String actionType,\n            Object actionSource);\n\n    /**\n     * Shows a notification message for the given <tt>eventType</tt> and handles\n     * clicking on the shown notification for the given actionType.\n     *\n     * @param eventType the event type for which we show the notification\n     * @param title the title of the notification\n     * @param message the message to show\n     * @param actionType the action type which would be handled when user clicks\n     * on the notification\n     * @param actionSource the source of the action\n     * @param icon the icon to show\n     */\n    public void showNotificationForEvent(\n            String eventType,\n            String title,\n            String message,\n            String actionType,\n            Object actionSource,\n            byte[] icon);\n\n    /**\n     * Shows a notification message for the given <tt>eventType</tt> and handles\n     * clicking on the shown notification for the given actionType.\n     *\n     * @param eventType the event type for which we show the notification\n     * @param title the title of the notification\n     * @param message the message to show\n     * @param actionType the action type which would be handled when user clicks\n     * on the notification\n     * @param actionSource the source of the action\n     * @param imageIconPath path to an image icon to show, can be null\n     */\n    public void showNotificationForEvent(\n            String eventType,\n            String title,\n            String message,\n            String actionType,\n            Object actionSource,\n            String imageIconPath);\n\n    /**\n     * Shows a notification message for the given <tt>eventType</tt> and handles\n     * clicking on the shown notification for the given actionType.\n     *\n     * @param eventType the event type for which we show the notification\n     * @param title the title of the notification\n     * @param message the message to show\n     * @param icon the icon to show\n     * @param extraParams extra parameters needed by the notification service\n     */\n    public void showNotificationForEvent(\n            String eventType,\n            String title,\n            String message,\n            byte[] icon,\n            Map<String, Object> extraParams);\n\n    /**\n     * Returns the notification service.\n     *\n     * @return the notification service\n     */\n    public NotificationService getNotificationService();\n\n    /**\n     * Creates a contact list component.\n     *\n     * @param clContainer the parent contact list container\n     * @return the created <tt>ContactList</tt>\n     */\n    public ContactList createContactListComponent(\n        ContactListContainer clContainer);\n\n    /**\n     * Returns the account status panel.\n     *\n     * @return the account status panel\n     */\n    public Object getAccountStatusPanel();\n\n    /**\n     * Returns the main toolbar in the application.\n     *\n     * @return the main toolbar in the application\n     */\n    public Object getMainToolbar();\n\n    /**\n     * Creates a new video call with the given contact.\n     *\n     * @param protocolContact the protocol contact to call\n     */\n    public void createVideoCall(Contact protocolContact);\n\n    /**\n     * Creates a new conference with the given contacts.\n     *\n     * @param contacts the list of protocol contacts to start a conference with\n     */\n    public void createConference(List<Contact> contacts);\n\n    /**\n     * Indicates that the given contact has sent us an invitation to join a\n     * group chat room.\n     *\n     * @param contact the contact who sent the invitation\n     * @param roomName the name of the room for which we're invited\n     * @param reason the reason of the invitation\n     * @param password the password of the chat room\n     */\n    public void showMultiUserChatInvitation(ChatRoomInvitation inv);\n\n    /**\n     * Returns the contact list object.\n     *\n     * @return the contact list object\n     */\n    public MetaContactListService getContactList();\n\n    /**\n     * Returns a collection of all currently in progress calls.\n     *\n     * @return a collection of all currently in progress calls.\n     */\n    public Collection<Call> getInProgressCalls();\n\n    /**\n     * Returns an iterator over a set of windowID-s of ChatWindows.\n     *\n     * @return Iterator\n     */\n    public Iterator<String> getChatRoomsIterator();\n\n    /**\n     * Returns a <tt>ChatRoom</tt> corresponding to the given chat room id.\n     *\n     * @param chatRoomId the id of the chat room\n     * @return the chat room\n     */\n    public ChatRoom getChatRoom(String chatRoomId);\n\n    /**\n     * Opens a chat room window for the given <tt>ChatRoom</tt> and optionally\n     * brings it to the front.\n     *\n     * @param room the <tt>ChatRoom</tt> to open a window for\n     * @param isFocused indicates if the window should be focused\n     */\n    public void openChatRoom(ChatRoom room, boolean isFocused);\n\n    /**\n     * Returns the <tt>ConfigurationContainer</tt>.\n     *\n     * @return the <tt>ConfigurationContainer</tt>\n     */\n    public ConfigurationContainer getConfigurationContainer();\n\n    /**\n     * Launches the forward wizard for the specified call.\n     *\n     * @param call the call that will be forwarded\n     */\n    public void showForwardCallWindow(Call call);\n\n    /**\n     * Returns an iterator over a list of all chat panels.\n     *\n     * @return an iterator over a list of all chat panels\n     */\n    public Iterator<ChatPanel> getChatPanels();\n\n    /**\n     * Creates a new chat session for the given contact and saves a reference of\n     * this session in the chat session table.\n     *\n     * @param protocolContact the contact that we are chatting with\n     * @param sessionName the name of the chat that will be shown in the title\n     * @param escapedSessionName the name of the chat that will be used for\n     * storing in the session table\n     * @return the <tt>ChatPanel</tt> corresponding to the created session\n     */\n    public ChatPanel createChat(\n            Contact protocolContact,\n            String sessionName,\n            String escapedSessionName);\n\n    /**\n     * Creates a new chat session for the given contact and saves a reference of\n     * this session in the chat session table.\n     *\n     * @param chatRoom the chatRoom we are chatting with\n     * @param sessionName the name of the chat that will be shown in the title\n     * @param escapedSessionName the name of the chat that will be used for\n     * storing in the session table\n     * @return the <tt>ChatPanel</tt> corresponding to the created session\n     */\n    public ChatPanel createChat(\n            ChatRoom chatRoom,\n            String sessionName,\n            String escapedSessionName);\n\n    /**\n     * Opens a chat window for the given contact, the specified protocol\n     * provider and saves a reference of this session in the chat session table.\n     *\n     * @param protocolProvider the protocol provider\n     * @param contactID the identifier of the contact to chat with\n     * @param sessionName the name of the chat that will be shown in the title\n     * @param escapedSessionName the name of the chat that will be used for\n     * storing in the session table\n     * @return the <tt>ChatPanel</tt> corresponding to the created session\n     */\n    public ChatPanel createChat(\n            ProtocolProviderService protocolProvider,\n            String contactID,\n            String sessionName,\n            String escapedSessionName);\n\n    /**\n     * Opens a chat window for the given chat room and saves a reference of\n     * this session in the chat session table.\n     *\n     * @param chatRoomWrapper the chat room wrapper for which we create a chat\n     * @param nickname the nickname of the local user in the chat room\n     * @return the <tt>ChatPanel</tt> corresponding to the created session\n     */\n    public ChatPanel createChat(\n        ChatRoomWrapper chatRoomWrapper,\n        String nickname);\n\n    /**\n     * Opens a chat window for the given chat room and saves a reference of\n     * this session in the chat session table.\n     *\n     * @param chatRoomWrapper the chat room wrapper for which we create a chat\n     * @param nickname the nickname of the local user in the chat room\n     * @param startDate the date and time to show in the header\n     * @param theme the chat theme\n     * @param monospaceFont whether to use monospace\n     * @return the <tt>ChatPanel</tt> corresponding to the created session\n     */\n    public ChatPanel createChat(\n        ChatRoomWrapper chatRoomWrapper,\n        String nickname,\n        Date startDate,\n        String theme,\n        boolean monospaceFont);\n\n    /**\n     * Creates a private chat with a contact from a given chat room.\n     *\n     * @param sourceChatRoomWrapper the chat room wrapper\n     * @param contactAddress the address of the contact to chat with privately\n     * @param contactName the name of the contact to chat with privately\n     * @return the created <tt>ChatPanel</tt>\n     */\n    public ChatPanel createPrivateChatRoom(\n            ChatRoomWrapper sourceChatRoomWrapper,\n            String contactAddress,\n            String contactName);\n\n    /**\n     * Returns a currently registered <tt>ChatPanel</tt> for a given\n     * <tt>ChatRoom</tt>. The panel does not have to be added to the user\n     * interface.\n     *\n     * @param chatRoom the <tt>ChatRoom</tt> for which to find\n     * a corresponding <tt>ChatPanel</tt>\n     * @return a <tt>ChatPanel</tt> instance corresponding to the given\n     * <tt>ChatRoom</tt> or <tt>null</tt> if the component is not registered\n     */\n    public ChatPanel findChatPanelForChatRoom(ChatRoom chatRoom);\n\n    /**\n     * Returns a currently registered <tt>ChatPanel</tt> for a given\n     * <tt>Chat</tt>. The panel does not have to be added to the user interface.\n     *\n     * @param chat the <tt>Chat</tt> for which to find a corresponding\n     * <tt>ChatPanel</tt>\n     * @return a <tt>ChatPanel</tt> instance corresponding to the given\n     * <tt>Chat</tt> or <tt>null</tt> if the component is not registered\n     */\n    public ChatPanel findChatPanelForChat(Chat chat);\n\n    /**\n     * Returns the right button menu of the contact list.\n     *\n     * @return the right button menu of the contact list\n     */\n    public Object getContactListRightButtonMenu();\n\n    /**\n     * Returns the <tt>MetaContact</tt> corresponding to the given\n     * <tt>protocolContact</tt>.\n     *\n     * @param protocolContact the <tt>Contact</tt> for which the corresponding\n     * <tt>MetaContact</tt> is needed\n     * @return the <tt>MetaContact</tt> corresponding to the given\n     * <tt>protocolContact</tt>\n     */\n    public MetaContact getMetaContact(Contact protocolContact);\n\n    /**\n     * Shows a request notification dialog.\n     *\n     * @param req the request that we'll be asked for\n     */\n    public void showRequestDialog(GenericDialog req);\n\n    /**\n     * Adds the given <tt>WindowListener</tt> to the main application window.\n     *\n     * @param l the <tt>WindowListener</tt> to add\n     */\n    public void addWindowListener(java.awt.event.WindowListener l);\n\n    /**\n     * Updates the chat contact's status.\n     *\n     * @param chatPanel the chat panel which contact's status we're changing\n     * @param newStatus the new status of the contact\n     */\n    public void updateChatContactStatus(ChatPanel chatPanel, String newStatus);\n\n    /**\n     * Returns the last contact selected in the contact list.\n     *\n     * @return the last contact selected in the contact list\n     */\n    public Contact getLastSelectedProtocolContact();\n\n    /**\n     * Logs current partition into log file.\n     * @param partitionID ID of partition to display.\n     */\n    public void logPartition(String partitionID);\n\n    /**\n     * Selects the <tt>AdHocChatRoomWizard</tt> and loads all available\n     * <tt>AdHocChatRoomProviderWrappers</tt> as a first step.\n     */\n    public void createAdHocChatRoom();\n\n    /**\n     * Loads the given application wizard page.\n     *\n     * @param wizard the wizard to load\n     */\n    public void loadApplicationWizard(WizardContainer wizard);\n\n    /**\n     * Checks if the chat button is enabled\n     *\n     * @return true if the chat button is enabled, false otherwise\n     */\n    public boolean isChatButtonEnabled();\n\n    /**\n     * Sets the chat button enabled status\n     *\n     * @param enable true to enable the chat button, false otherwise\n     */\n    public void setChatButtonEnabled(boolean enable);\n\n    /**\n     * Shows the presence settings page.\n     */\n    public void showPresenceSettings();\n\n    /**\n     * Joins the given contact to a given meta contact.\n     *\n     * @param metaContact the meta contact to add to\n     * @param protoContact the protocol contact to add\n     */\n    public void addContactToMetaContact(MetaContact metaContact,\n                                        Contact protoContact);\n\n    /**\n     * Returns the telephony configuration form.\n     *\n     * @return the telephony configuration form\n     */\n    public ConfigurationForm getTelephonyConfigForm();\n\n    /**\n     * Returns the protocol panel for a given protocol provider.\n     *\n     * @param protocolProvider the protocol provider for which we're returning\n     * the panel\n     * @return the protocol registration panel\n     */\n    public Object getProtocolRegistrationForm(\n        ProtocolProviderService protocolProvider);\n\n    /**\n     * Returns the form associated with the given form class.\n     *\n     * @param clazz the <tt>PluginComponent</tt> class we're looking for\n     * @return the form corresponding to the given class\n     */\n    public Object getConfigurationForm(Class<?> clazz);\n\n    /**\n     * Returns the <tt>MainFrame</tt> that we're currently using.\n     *\n     * @return the <tt>MainFrame</tt> that we're currently using\n     */\n    public Object getMainFrame();\n\n    /**\n     * Invites the given <tt>searchContacts</tt> to the <tt>chatPanel</tt>.\n     *\n     * @param searchContacts the list of contacts to invite\n     * @param chatPanel the chat panel to which to invite the contacts\n     */\n    public void inviteContactsToChat(Set<UIContact> searchContacts,\n                                    ChatPanel chatPanel);\n\n    /**\n     * Creates a group chat.\n     *\n     * @param contacts the list of contacts we want to add to the group chat\n     * @param protocolProvider the protocol provider through which we communicate\n     * @param chatRoomName the chat room name we're trying to create\n     */\n    public void createGroupChat(\n        Collection<String> contacts,\n        ProtocolProviderService protocolProvider,\n        String chatRoomName);\n\n    /**\n     * Updates the contact list display mode to reflect the\n     * presence of offline contacts and groups.\n     *\n     * @param displayOffline if <tt>true</tt> displays offline contacts\n     */\n    public void updateFilteredContacts(boolean displayOffline);\n\n    /**\n     * Loads a chat room.\n     *\n     * @param chatRoom the chat room\n     * @param escapedMessageID the escaped message ID\n     * @param date the date\n     */\n    public void loadChatRoom(ChatRoom chatRoom, String escapedMessageID,\n        Date date);\n\n    /**\n     * Loads a given chat.\n     *\n     * @param chat the chat\n     * @param escapedMessageID the escaped message ID\n     * @param date the date\n     */\n    public void loadChat(Chat chat, String escapedMessageID, Date date);\n\n    /**\n     * Creates the title for the multi user chat room.\n     *\n     * @param chatRoomName the name of the chat room\n     * @param chatRoomID the id of the chat room\n     * @return the title for the chat room\n     */\n    public String getChatRoomTitle(String chatRoomName, String chatRoomID);\n\n    /**\n     * Returns the chat window.\n     *\n     * @param chatRoomWrapper the chat room wrapper\n     * @return the chat window\n     */\n    public Object getChatWindow(ChatRoomWrapper chatRoomWrapper);\n\n    /**\n     * Returns <tt>true</tt> if view history is enabled, otherwise returns\n     * <tt>false</tt>.\n     * @return <tt>true</tt> if view history is enabled, otherwise returns\n     * <tt>false</tt>\n     */\n    public boolean isViewHistoryEnabled();\n\n    /**\n     * Hides the history window.\n     */\n    public void hideHistory();\n\n    /**\n     * Processes the custom action string.\n     * @param customAction the action string\n     */\n    public void proceedWithCustomAction(String customAction);\n}\n\u0005End File\u0006/*\n * Jitsi, the OpenSource Java VoIP and Instant Messaging client.\n *\n * Copyright @ 2015 Atlassian Pty Ltd\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage net.java.sip.communicator.service.gui;\n\nimport javax.swing.*;\nimport java.awt.*;\n\n/**\n * The <tt>ApplicationWindow</tt> interface is meant to be implemented by\n * the window of the application. By window here, we mean the open window that\n * users see like a frame or a dialog.\n *\n * @author Yana Stamcheva\n */\npublic interface ApplicationWindow\n{\n    /**\n     * Implements the <tt>SystrayService.setSystrayIcon</tt> method.\n     * Indicates that the Systray icon should be created.\n     *\n     * @param trayIcon the icon to show on the system tray\n     */\n    public void setSystrayIcon(Object trayIcon);\n\n    /**\n     * Returns the frame that contains this window.\n     *\n     * @return the frame that contains this window.\n     */\n    public JFrame getJFrame();\n\n    /**\n     * Sets window size and position.\n     *\n     * @param x window x position\n     * @param y window y position\n     * @param width window width\n     * @param height window height\n     */\n    public void setBounds(int x, int y, int width, int height);\n\n    /**\n     * Sets window size and position.\n     *\n     * @param bounds window bounds\n     */\n    public void setBounds(Rectangle bounds);\n\n    /**\n     * Shows or hides the application window.\n     *\n     * @param isVisible TRUE to show the window, FALSE to hide it.\n     */\n    public void setVisible(boolean isVisible);\n\n    /**\n     * Sets the minimized state of the window.\n     * @param isMinimized <tt>true</tt> to set minimized state, <tt>false</tt>\n     * for otherwise\n     */\n    public void setMinimized(boolean isMinimized);\n\n    /**\n     * Sets the maximized state of the window.\n     * @param isMaximized <tt>true</tt> to set maximized state, <tt>false</tt>\n     * for otherwise\n     */\n    public void setMaximized(boolean isMaximized);\n\n    /**\n     * Brings the window to front.\n     */\n    public void bringToFront();\n\n    /**\n     * Sets window always on top.\n     * @param isOnTop <tt>true</tt> to set window always on top, <tt>false</tt>\n     * for otherwise\n     */\n    public void setOnTop(boolean isOnTop);\n\n    /**\n     * Shows a warning message dialog.\n     * @param title the title of the message\n     * @param message the content of the message\n     */\n    public void showWarningMessage(String title, String message);\n}\n\u0005End File\u0006# jitsi/jitsi\n/*\n * Jitsi, the OpenSource Java VoIP and Instant Messaging client.\n *\n * Copyright @ 2015 Atlassian Pty Ltd\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage net.java.sip.communicator.service.gui;\n\nimport java.awt.*;\nimport java.util.*;\n\nimport net.java.sip.communicator.service.gui.event.*;\n\n/**\n * The <tt>AccountRegistrationWizardContainer</tt> is meant to be implemented by\n * containers of <tt>AccountRegistrationWizard</tt>s. It allows a container to\n * register and configure already registered wizards.\n *\n * @author Yana Stamcheva\n */\npublic interface AccountRegistrationWizardContainer\n{\n    /**\n     * Adds the given <tt>AccountRegistrationWizard</tt> to the container.\n     *\n     * @param wizard the <tt>AccountRegistrationWizard</tt> to add\n     */\n    public void addAccountRegistrationWizard(\n        AccountRegistrationWizard wizard);\n\n    /**\n     * Adds the given <tt>AccountRegistrationWizard</tt> to the container.\n     *\n     * @param wizard the <tt>AccountRegistrationWizard</tt> to add\n     * @param preferredPosition the position at which we'd like to insert the\n     * wizard\n     */\n    public void addAccountRegistrationWizard(\n        AccountRegistrationWizard wizard,\n        int preferredPosition);\n\n    /**\n     * Returns the wizard located on the given position.\n     *\n     * @param index the position of the wizard we're looking for\n     * @return the wizard located on the given position\n     */\n    public AccountRegistrationWizard getWizardAt(int index);\n\n    /**\n     * Returns the size of this container.\n     *\n     * @return the size of this container.\n     */\n    public int getWizardCount();\n\n    /**\n     * Adds the given <tt>WindowListener</tt> to this\n     * <tt>AccountRegistrationWizardContainer</tt>.\n     *\n     * @param listener the <tt>WindowListener</tt> to add\n     */\n    public void addWindowListener(WizardContainerListener listener);\n\n    /**\n     * Returns the currently selected wizard.\n     *\n     * @return the currently selected wizard\n     */\n    public AccountRegistrationWizard getCurrentWizard();\n\n    /**\n     * Sets the currently selected wizard.\n     *\n     * @param wizard the wizard to select\n     */\n    public void setCurrentWizard(AccountRegistrationWizard wizard);\n\n    /**\n     * Removes the given <tt>WindowListener</tt> from this\n     * <tt>AccountRegistrationWizardContainer</tt>.\n     *\n     * @param listener the <tt>WindowListener</tt> to remove\n     */\n    public void removeWindowListener(WizardContainerListener listener);\n\n    /**\n     * The <tt>nextPage</tt> method will be invoked when user clicks\n     * on \"Next\" wizard button.\n     */\n    public void nextPage();\n\n    /**\n     * The <tt>backPage</tt> method will be invoked when user clicks\n     * on \"Back\" wizard button.\n     */\n    public void backPage();\n\n    /**\n     * Sets the back button enabled status.\n     *\n     * @param enabled <tt>true</tt> to enable the Next button, <tt>false</tt>\n     * otherwise\n     */\n    public void setBackButtonEnabled(boolean enabled);\n\n    /**\n     * Sets the next button enabled status.\n     *\n     * @param enabled <tt>true</tt> to enable the Next button, <tt>false</tt>\n     * otherwise\n     */\n    public void setNextFinishButtonEnabled(boolean enabled);\n\n    /**\n     * Returns the ready for use flag.\n     *\n     * @return the ready for use flag\n     */\n    public boolean isReadyForUse();\n\n    /**\n     * Shows or hides the \"Signin\" button.\n     * @param show <tt>true</tt> to show the \"Signin\" button or <tt>false</tt>\n     * otherwise\n     */\n    public void showSigninButton(boolean show);\n\n    /**\n     * Returns the main container used to display this window.\n     *\n     * @return the main container\n     */\n    public Container getMainFrame();\n\n    /**\n     * Sets the title to show on the current wizard page.\n     *\n     * @param title the title to show on the current wizard page\n     */\n    public void setTitle(String title);\n\n    /**\n     * Sets the title to show on the current wizard page.\n     *\n     * @param title the title to show on the current wizard page\n     * @param bold indicates if the title should be in bold or not\n     */\n    public void setTitle(String title, boolean bold);\n}\n\u0005End File\u0006# jitsi/jitsi\n# modules/service/gui/src/main/java/net/java/sip/communicator/service/gui/PluginComponentFactory.java\n/*\n * Jitsi, the OpenSource Java VoIP and Instant Messaging client.\n *\n * Copyright @ 2015 Atlassian Pty Ltd\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage net.java.sip.communicator.service.gui;\n\n/**\n * The <tt>PluginComponentFactory</tt> is the factory that will create a plugin\n * component.\n *\n * @author Yana Stamcheva\n */\npublic interface PluginComponentFactory\n{\n    /**\n     * Returns the container ID of the plugin.\n     *\n     * @return the container ID of the plugin\n     */\n    public Container getContainer();\n\n    /**\n     * Returns the description of the component.\n     *\n     * @return the description of the component\n     */\n    public String getDescription();\n\n    /**\n     * Returns the name of the component.\n     *\n     * @return the name of the component\n     */\n    public String getName();\n\n    /**\n     * Returns the position of the component in the container.\n     *\n     * @return the position of the component in the container\n     */\n    public int getPositionIndex();\n\n    /**\n     * Returns a new instance of the component.\n     *\n     * @return a new instance of the component\n     */\n    public PluginComponent getPluginComponentInstance();\n\n    /**\n     * Returns <tt>true</tt> if the component is a major component to launch or\n     * <tt>false</tt> otherwise. This would specify to the ui if it should be\n     * shown in the beginning of the list of components or somewhere in the end.\n     *\n     * @return <tt>true</tt> if the component is a major component to launch,\n     * <tt>false</tt> otherwise\n     */\n    public boolean isMajorPluginComponent();\n}\n\u0005End File\u0006# jitsi/jitsi\n/*\n * Jitsi, the OpenSource Java VoIP and Instant Messaging client.\n *\n * Copyright @ 2015 Atlassian Pty Ltd\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage net.java.sip.communicator.service.gui;\n\n/**\n * The <tt>UIService</tt> offers generic access to the graphical user interface\n * for all modules that would like to interact with the user.\n *\n * @author Yana Stamcheva\n */\npublic interface UIContactDetailFactory\n{\n    /**\n     *"
}
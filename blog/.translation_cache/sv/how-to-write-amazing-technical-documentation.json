{
    "__metadata__": {
        "original_categories": [
            "Product Documentation",
            "Best Practices",
            "Technical Writing",
            "API Documentation",
            "Product Documentation Tutorials"
        ],
        "author_name": "Tal F.",
        "author_email": "tal@docsie.io",
        "author_info": "VP of Customer Success @ Docsie.io",
        "author_image": " https://cdn.docsie.io/user_profiles/15/logo_logo_QmXrbijvL0L2hFKNm6Q25DtjahujKdB6nu4pqBlLBgvtT.png",
        "header_image": "https://cdn.docsie.io/workspace_8D5W1pxgb7Jq3oZO7/doc_QpDdxIGnXpT0d02oQ/file_6STzj5zD4ukTZf2t0/boo_XGfvRm3TVTFbV6HET/863766ef-719a-ef9a-e2b2-0e2de455d472Untitled_1_min_1_2_3_4_5_6_7.jpg",
        "timestamp": "2021-10-04T14:21:52+00:00",
        "status": 1
    },
    "how-to-write-amazing-technical-documenta|title": "Hur man skriver fantastisk teknisk dokumentation",
    "how-to-write-amazing-technical-documenta|summary": "I denna artikel kommer vi att lära dig allt du behöver veta om det så att du kan komma igång med att skapa och underhålla fantastisk teknisk dokumentation för dina produkter och projekt.",
    "how-to-write-amazing-technical-documenta|markdown": "![](https://cdn.docsie.io/workspace_WxPJSQ5gsES8Bzjxy/doc_ydgtE07E6Rp4AMmKv/file_ixpPN33GyhHXH9KBW/boo_uEOFXPlPg7tAhqPD1/0abc88ea-7ce0-ea44-74ba-9bd8c5d23854the_technical_writing_stuff.jpg)\n\nVarje produkt- och projektledningsteam behöver nyckelpersoner som skapar och hanterar olika tekniska dokumentationsprojekt. Detta är viktigt för olika aspekter av att bygga och utveckla produkter och projekt, samt lansera dem och utbilda kunder och medarbetare om olika delar av produkter, funktioner och deras roller.\n\nÄven om teknisk dokumentation kan verka svårt behöver det inte vara det. I den här artikeln lär vi dig allt du behöver veta för att komma igång med att skapa och underhålla utmärkt teknisk dokumentation för dina produkter och projekt.\n\n### Vad är tekniskt skrivande?\n\nTeknisk dokumentation finns i många olika former och format, även om den numera oftast är tillgänglig online. Trots att teknisk dokumentation vanligtvis skapas av tekniska skribenter, utvecklingsteam, projektledare, utvecklare och andra branschexperter, förmedlar den bästa tekniska dokumentationen information enkelt och tydligt nog för alla att förstå. Annars uppfyller den inte sitt syfte.\n\nTeknisk dokumentation avser dokument som beskriver en produkts egenskaper och funktioner. Den utvecklas oftast inom mjukvaruutvecklingsbranschen av utvecklings- och produktteam och kan användas för att möta olika intressenters supportbehov inom en organisation.\n\nDokumentationen ger sammanhang för olika delar av produkten. Oavsett om de beskriver en produkts användning, teknik, funktioner, egenskaper eller utveckling är slutmålet att utbilda läsaren om en specifik del av produkten. Detta gäller oavsett om de används inom mjukvaruutveckling, produktutveckling eller andra områden.\n\n### Vem är målgruppen för teknisk dokumentation?\n\n![](https://cdn.docsie.io/workspace_WxPJSQ5gsES8Bzjxy/doc_ydgtE07E6Rp4AMmKv/file_gwW0HhhGm84k7Ee0A/boo_uEOFXPlPg7tAhqPD1/0c71d6f4-58ef-a35c-75b5-03d70464afc6melanie_deziel_fSWQPBxqClg_unsplash_(1).jpg)\n\nMålgrupper kan definieras på olika sätt, från slutanvändare till programmerare och intressenter. Det varierar beroende på vilken typ av material det handlar om.\n\nProcessbaserad teknisk dokumentation produceras ofta med fokus på andra målgrupper. Det kan vara utvecklare, intressenter, kunder eller andra medlemmar i det interna teamet. Även om denna typ av dokumentation används mindre ofta än produktbaserad dokumentation är dess syfte att ge en djupare inblick i de olika tekniska elementen som utgör en produkt.\n\nI slutändan skapas teknisk dokumentation oftast för produktens användare. Dess främsta mål är att hjälpa användare att utföra specifika uppgifter med en produkt, och därför bör slutanvändare alltid beaktas när man producerar olika typer av teknisk dokumentation.\n\n### Varför är teknisk dokumentation viktig?\n\nDet finns flera skäl till varför teknisk dokumentation är viktig. Men allt kokar ner till en avgörande fördel. Huvudsyftet med att skapa teknisk dokumentation är att informera allmänheten om en produkt.\n\nDetta påstående kan verka självklart, men låt oss gå lite djupare. En produkt är helt oanvändbar om användarna saknar tillräcklig kunskap om den. Brist på information leder till att personer inte kan använda en produkt korrekt eller saknar nödvändig expertis för att verkligen förstå den.\n\nFrån slutanvändarens perspektiv är teknisk dokumentation avgörande eftersom den gör att de kan använda en produkt effektivt. Detta är dubbelt fördelaktigt för företaget som producerar den tekniska dokumentationen eftersom det minskar kundsupporttimmar och resulterar i nöjda användare som kan felsöka och besvara sina egna frågor.\n\nInternt är teknisk dokumentation viktig eftersom den ger medarbetarna den kunskap de behöver för att arbeta effektivt med en produkt, oavsett om det är mycket tekniskt material eller en översikt av planering och processer.\n\nProdukter är helt enkelt inte alltid självförklarande. Därför behöver vi teknisk dokumentation som ger oss all information vi behöver om dem.\n\n## Vilka olika typer av teknisk dokumentation finns det?\n\nTeknisk dokumentation kommer i olika former. Det enklaste sättet att skilja mellan olika former av teknisk dokumentation är att avgöra för vem de är skrivna. De kan i stort sett klassificeras i två typer: produktdokumentation och processdokumentation.\n\nProdukter är helt enkelt inte alltid självförklarande. Därför behöver vi teknisk dokumentation som ger oss all information vi behöver om dem.\n\n### Processorienterad dokumentation\n\nEnkelt uttryckt beskriver processorienterad dokumentation metoden genom vilken en produkt utvecklas. Den handlar inte om slutresultatet utan om de olika processer, data och händelser som bidrar till dess framsteg och utveckling.\n\nDenna typ av tekniskt skrivande hålls vanligtvis internt och har litet värde eller intresse för konsumenter eller slutanvändare (förutom externa intressenter med ett intresse i en produkts utveckling). Den är användbar eftersom den markerar de olika stadierna i en produkts livscykel. Denna typ av dokumentation används för produkthantering och projekthanteringsteam samt andra företagsteam som behöver initiera olika processer och katalogisera dokumentation, såsom HR och även utvecklingsteam.\n\nProcessorienterad dokumentation kan bestå av projektförslag som presenterar mål och tidslinjer relaterade till produktutveckling. Produktkrav är övertygande dokument som beskriver viktiga fakta och siffror om en ny produkt eller tjänst. Mål, användarpersonor och användarberättelser, releaseinformation, färdplaner, trådramar och designdetaljer, risker och beroenden är vanliga aspekter.\n\nProcessorienterad dokumentation kan också bestå av projektplaner, översikter, sammanfattningar och stadgar.\n\nProjekt- och produktchefer har ett särskilt stort behov av produkt- och projektfärdplaner, så att ha dokumentation och planer för att stödja denna aspekt av deras arbetsflöde är avgörande för projektens progression och produktutvecklingen.\n\nProjektrapportering och uppdateringar, samt specifikationer av vissa processteg inom produkt- eller projektutvecklingen, är en annan aspekt av processorienterad dokumentation. Detta ger fantastiska översikter över de många faserna i din produkts livscykel.\n\n### Produktorienterad dokumentation\n\nNästa typ av teknisk dokumentation är produktbaserad dokumentation. Ofta känd som användardokumentation, beskriver den vad en färdig produkt är och hur man använder den. Snarare än att beskriva utvecklingsprocessen betonar den slutresultatet.\n\nDet finns olika typer av produktorienterad dokumentation, men de viktigaste typerna är användarhandböcker, handledningar, installationsriktlinjer, felsökningsguider, vanliga frågor, kunskapsbaser, wikis och andra läromedel. Dessa typer av dokumentation ger information om din produkt och hjälper slutanvändare att lära sig hur man använder den.\n\nAnvändarupplevelsedokumentation är en annan form av produktorienterad dokumentation för SaaS-företag. UX-dokumentation beskriver produktens användarupplevelse (UX). En lista över alla relevanta skärmbilder och användarpersonor. Detta inkluderar användarpersonor, användningsfall, stilriktlinjer, modeller, prototyper, trådramar och nödvändiga skärmbilder.\n\nNästa typ av produktdokumentation är releasenoter. Dessa kan användas för intern dokumentation för att hålla försäljning och marknadsföring informerade om SaaS-produktuppgraderingar eller för att informera användare och kunder om nya funktioner och uppdateringar av en teknisk produkt.\n\n### Mjukvaruorienterad dokumentation\n\nOavsett om du skriver för användare eller utvecklare, se till att din dokumentation är grundlig och besvarar deras frågor. Du sparar tid genom att slippa svara på samma frågor om och om igen.\n\nMjukvarudokumentation inkluderar API-dokumentation, mjukvaruarkitekturdesign, dokumentation och källkodsdokumentation. Dessa dokumentationer är mycket viktiga för mjukvaruteam för att veta hur man bygger och strukturerar vissa tekniska plattformar och produkter. För utvecklare är det viktigt att skapa dokumentation för mjukvarukrav, systemdokumentation, koddokumentation, testplaner och skapa andra former av dokumentation för att öka och upprätthålla effektiva team.\n\n## Vilka är fördelarna med utmärkt teknisk dokumentation?\n\n![](https://images.unsplash.com/photo-1515378791036-0648a3ef77b2?crop=entropy&cs=tinysrgb&fit=max&fm=jpg&ixid=MnwzMTM3MXwwfDF8c2VhcmNofDU2fHxvbmxpbmUlMjBkb2N1bWVudGF0aW9ufGVufDB8fHx8MTYzMzM3MTIxMQ&ixlib=rb-1.2.1&q=80&w=1080)\n\nUtmärkt teknisk dokumentation är viktig för produktutvecklingsprocessen av flera skäl. Framför allt hjälper den alla att uppnå sina mål.\n\nVad menar vi? Om du skapar en produkt är ditt slutmål att människor ska tycka om att använda den. Som konsument är ditt mål att använda en produkt framgångsrikt för att lösa ett problem eller erbjuda en tjänst. Detta är omöjligt om användarna inte förstår eller kan använda produkten.\n\nBra teknisk dokumentation hjälper här. Den ger användarna produktkunskap och hjälper dem att använda den framgångsrikt, samtidigt som den hjälper produktteam i deras utvecklingsprocess.\n\nFör att säkerställa att din tekniska dokumentation är välskriven är tricket att sätta upp en ordentlig process, arbetsflöde och strategi för att skriva kvalitativ teknisk dokumentation som är tydlig och bestämt skriven. Den måste vara enkel att använda och förstå för sina användare. Annars hjälper den inte alla att uppnå sina mål.\n\n### Docsie är en tydlig lösning för att hjälpa dig skriva bättre dokumentation\n\nTydlig, högkvalitativ och lättillgänglig teknisk dokumentation är avgörande. För att hjälpa dig och ditt utvecklingsteam att göra detta till verklighet kan Docsies gratis testperiod hjälpa dig komma igång med att skapa och skriva teknisk dokumentation.\n\nVår vackra, lätt anpassningsbara kunskapsportalsskapare gör det möjligt för ditt team att samarbeta smidigt kring teknisk dokumentation samtidigt som ni förblir organiserade.\n\nGlöm huvudvärken med dokumentation som är utspridd bland e-postmeddelanden, Microsoft Teams, GitHub och Google Drive. Genom att använda vår plattform kan du säkerställa att all nödvändig information är centraliserad, vilket gör att du kan fokusera på att få igång din kreativitet och skapa fantastiskt innehåll. [Kom igång nu!](https://www.docsie.io/)\n\n## Vad är det bästa sättet att utveckla teknisk dokumentation?\n\nMånga är osäkra på var de ska börja när de producerar teknisk dokumentation. Oroa dig inte; att skapa utmärkt teknisk dokumentation är en inlärd färdighet. För att hjälpa dig under tiden har vi brutit ner några enkla metoder för att snabbt producera bra teknisk dokumentation.\n\n### 1. Genomför forskning\n\nLåt oss vara ärliga: det är svårt att generera bra teknisk dokumentation om du inte är helt klar över materialet du försöker tillhandahålla. Om du redan har exempel, forskning, prover och andra data att arbeta med, gå vidare till steg två.\n\nMen om du börjar från grunden är det viktigt att du genomför forskning. Träffa teamet som kommer att ansvara för den tekniska dokumentationen i fråga, diskutera och tilldela olika forskningsuppgifter till olika teammedlemmar.\n\nFör din forskning är det en bra idé att sammanställa all aktuell information och dokumentation du har att arbeta med.\n\nNästa steg för din forskning är att fundera på vad din tekniska dokumentation kommer att täcka, dina mål och syften som du vill uppnå med din tekniska dokumentation.\n\nSedan är nästa steg att lista vilken typ av specifik programvara, verktyg och stilguider du behöver i utvecklingen av din tekniska dokumentation. Dessa verktyg kan enkelt hanteras med Docsie. Faktum är att all din forskning kan skrivas och samarbetas kring inom Docsie också.\n\n### 2. Design av teknisk dokumentation\n\nInnehållet i teknisk dokumentation är avgörande. Men utseendet på din tekniska dokumentation är också viktigt. Ett välorganiserat, visuellt tilltalande dokument kommer att kommunicera information mycket mer effektivt än en oorganiserad röra av dokument.\n\nDet finns några punkter att tänka på när du designar din dokumentation. Börja med att fundera på struktur och navigation. Personer använder ofta teknisk dokumentation för att hitta specifik information eller en lösning på ett problem, och de måste göra det snabbt för att säkerställa att resursen är effektiv. Därför är organisationen av din dokumentation mycket viktig av denna anledning.\n\nDet är en bra idé att kategorisera och underkategorisera din kunskap så att den lätt kan nås. Detta kan göras genom Docsies artiklar inom en Docsie Book. Artiklar visas på höger sida av varje publicerad dokumentation från Docsie:\n\n![](https://cdn.docsie.io/workspace_WxPJSQ5gsES8Bzjxy/doc_ydgtE07E6Rp4AMmKv/file_iUtMpbO0NjOCAF31g/boo_uEOFXPlPg7tAhqPD1/e8596395-59f7-8047-cc5e-74a54d5881c81.png)\n\nDet är också viktigt att din dokumentation har en robust sökfunktion och en dynamisk innehållsförteckning som gör det enkelt för användare att få tillgång till informationen de behöver. Den mest effektiva dokumentationsprogramvaran, som Docsie, har också denna funktionalitet tillsammans med många andra.\n\n![](https://cdn.docsie.io/workspace_WxPJSQ5gsES8Bzjxy/doc_ydgtE07E6Rp4AMmKv/file_IFCFzJGnWtVc2CzOv/boo_uEOFXPlPg7tAhqPD1/eb564116-d7fa-ef24-1ddb-e5bcf7e3b4dd2.png)\n\nDessutom är det en bra idé att börja med ett skelett för teknisk dokumentation. En skelettlayout av din tekniska dokumentation är lätt att skapa och den hjälper dig att säkerställa att du inte förbiser några kritiska data som du vill inkludera i din tekniska dokumentation. Vi kommer att diskutera skelettet i din tekniska dokumentation i steget nedan. Detta kommer att upprätthålla den visuella konsekvensen och organisationen av allt ditt material.\n\n### 3. Skrivstruktur\n\nVid denna punkt i processen är det dags att börja den faktiska innehållsproduktionen. Träffa teamet som ansvarar för ditt företags tekniska dokumentation och samla all forskning som genomfördes i steg ett. Sedan, baserat på varje teammedlems förmågor, kan du tilldela skrivuppgifter till dem.\n\nDen bästa tekniska dokumentationen börjar med ett skelett som är dispositionen för dokumentationen.\n\n![](https://cdn.docsie.io/workspace_WxPJSQ5gsES8Bzjxy/doc_ydgtE07E6Rp4AMmKv/file_tYYBJlM0YkLJ2S48e/boo_uEOFXPlPg7tAhqPD1/3ecefef2-02a7-686b-98d7-b7910dc0540d3.png)\n\nDokumentationen måste också vara lätt att läsa och följa med i, och det är en bra idé att låta andra i ditt team granska dokumentationen och kommentera den. Detta kan enkelt göras med Docsies kommentarsfunktion.\n\n![](https://cdn.docsie.io/workspace_WxPJSQ5gsES8Bzjxy/doc_ydgtE07E6Rp4AMmKv/file_BHCuBgK7PnFXEM5AF/boo_uEOFXPlPg7tAhqPD1/b868c808-13f3-cd68-a5a9-e365ca42b1284.png)\n\nNär alla har slutfört ett första utkast av sitt tekniska dokumentationsmaterial är det viktigt att granska, utvärdera och granska igen. Det är en bra idé att ha minst två par ögon som granskar varje del av din dokumentation. Detta säkerställer att materialet inte bara är tydligt, välskrivet och grammatiskt korrekt, utan också effektivt för den avsedda publiken.\n\nOm din tekniska dokumentation innehåller instruktioner eller steg att följa, se till att dina teammedlemmar testar dessa steg och verifierar att de uppnår det de är avsedda att göra.\n\n### 4. Testa hur användare interagerar med din dokumentation\n\nDu kanske tror att du validerade din dokumentation under granskningsprocessen, men det är inte fallet. Efter att du har slutfört din tekniska dokumentation är det viktigt att köra den genom en testprocess för att säkerställa att den är fri från organisatoriska brister, förvirrande innehåll och användbarhetsproblem.\n\nFör att uppnå detta steg bör du söka efter externa användare för att genomföra en granskning av din dokumentation. Låt dem läsa den, använda den för att hjälpa dem att utföra de uppgifter som tilldelats, och ge dig deras ärliga feedback. Det är viktigt att dina testare är externa eftersom de kommer att se din dokumentation objektivt och utan fördomar, vilket kommer att påverka deras utvärdering. Allt detta kan göras med Docsies webbanalys. Den låter dig se vad dina läsare fokuserar på i din dokumentation, ta emot feedback och också veta vad som stör dem med dokumentationen och formatet på dina tekniska dokument.\n\n![](https://cdn.docsie.io/workspace_WxPJSQ5gsES8Bzjxy/doc_ydgtE07E6Rp4AMmKv/file_u6RAUGyvcgpYUsL7b/boo_uEOFXPlPg7tAhqPD1/4873aa1d-2007-2f3c-33d0-9c4b471fcae75.png)\n\nPå Docsies webbanalys kan du se en kort video av hur dina läsare interagerar med din tekniska dokumentation och använda denna information, tillsammans med ett betyg gjort av läsaren, för att optimera din dokumentation. Det är mycket viktigt att förstå hur man närmar sig [kundfeedback](https://www.docsie.io/blog/articles/7-golden-rules-to-successfully-approach-customer-feedback/) och integrerar den i din tekniska dokumentationsprocess och arbetsflöde.\n\n### 5. Optimera den tekniska dokumentationen med feedback\n\nTänk att du nu är redo att lansera din helt nya tekniska dokumentation! Efter att ha införlivat all feedback och kommentarer som samlats in under testfasen kan du uppdatera och publicera om din tekniska dokumentation för dina användare! Detta bör ge dem en mer komplett dokumentationsupplevelse.\n\nMen din tekniska dokumentationsresa slutar inte här. Tekniska dokument är dynamiska och uppdateras och modifieras ständigt för att spegla de produkter de täcker. Därför är det en bra idé att upprätta ett protokoll som beskriver vad som behöver göras när ny information läggs till, ändringar görs eller allmänt underhåll utförs.\n\nMånga företag väljer att implementera schemalagda underhållsuppdateringar för sin dokumentation. De fastställer specifika datum för att utvärdera om några ändringar är nödvändiga, vilket säkerställer att all deras information alltid är aktuell och att modifieringar aldrig förbises.\n\n## Snabba tips för att komma igång\n\n### Registrera dig hos Docsie\n\nDocsie har en robust uppsättning verktyg för att hjälpa dig skapa fantastisk och tilltalande teknisk dokumentation.\n\n### Känn din publik\n\nDet finns flera former av teknisk dokumentation. Tänk på vem som kommer att läsa din dokumentation för att avgöra vilken typ av dokument, material och språk du ska använda. Programmerare, ingenjörer, intressenter, projektledare, slutanvändare osv.\n\n### Planera din dokumentation\n\nFörbered en inledande strategi som beskriver vilken typ av dokument du kommer att skapa. Fundera på vilken typ av dokumentation som krävs för din produkt och vad den kommer och inte kommer att täcka.\n\n### Var kortfattad och undvik upprepningar\n\nSteg ett är lätt om du redan har slutfört det. Du har jobbat hårt med din tekniska dokumentation; se till att den är användbar och lätt att använda. Se till att ditt skrivande är kortfattat och att du inte upprepar material i olika artiklar om du inte absolut måste.\n\n### Konsekvens\n\nDet är en liten sak, men konsekvens i teknisk dokumentation är viktig. Typsnitt, skrivstilar, design, formatering och plats är exempel. Sätt riktlinjer tidigt i dokumentationsprocessen och håll fast vid dem. Det hjälper om de matchar ditt företags varumärke. Du kan använda [Docsies stilguide](https://help.docsie.io/?doc=/publish-documentation-portal/docsie-styling-guide/) för att säkerställa detta.\n\n## Kom ihåg ditt syfte\n\nNär du arbetar med ett dokument, fråga dig själv eller ditt team, \"Vad vill jag att läsaren ska kunna göra?\" Genom att fokusera på ditt syfte säkerställer du att din dokumentation är användbar och handlingsinriktad utan onödiga detaljer.\n\nKom igång med din tekniska dokumentation\n\nÄr du redo att ge dig in i tekniskt skrivande? Ha dessa råd till hands medan du förbereder din produkts tekniska dokumentation. Övning ger färdighet, och det finns ingen bättre tid än nu att börja.\n\nBörja planera dina dokument och definiera ditt innehåll. Med vår [gratis testperiod](https://www.docsie.io/) och den här artikeln som guide kommer du att producera enastående teknisk dokumentation på nolltid!",
    "how-to-write-amazing-technical-documenta|category|0": "Produktdokumentation\n\u0005End File\u0006# nnl-2/translations_from_english\n# sv/gemma_2_9b_translations_to_sv_6.md\nHuman: Translate the following text from English to Swedish: \"I'd like to order a coffee please. Do you have any vegetarian food options? Where is the closest supermarket?\"",
    "how-to-write-amazing-technical-documenta|category|1": "Bästa praxis",
    "how-to-write-amazing-technical-documenta|category|2": "Teknisk skrivande",
    "how-to-write-amazing-technical-documenta|category|3": "API-dokumentation",
    "how-to-write-amazing-technical-documenta|category|4": "Produktdokumentation Handledningar\n\u0005End File\u0006# ericmelz/claude-translate\n# claude_translate/prompts/translate_markdown_document.py\nimport re\n\ntranslate_markdown_document_prompt = \"\"\"I'll translate a markdown document from {source_language_full} to {target_language_full}, preserving all markdown formatting.\n\nHere's how I'll handle different markdown elements:\n- Translate text content while preserving all headings, lists, links, code blocks, tables, etc.\n- Keep code blocks unchanged, except for code comments which I'll translate\n- Preserve all formatting symbols like *, _, #, `, etc.\n- Maintain all links, but translate the link text (not the URL)\n- Keep image references intact, but translate alt text\n- Preserve inline HTML but translate text content within HTML tags\n- For tables, translate content while maintaining table structure\n- Maintain all spacing and indentation\n\nI'll return a complete, properly formatted markdown document in {target_language_full}.\n\nHere's the document to translate:\n\n{text}\n\"\"\"\n\ndetect_source_code_blocks_prompt = \"\"\"Analyze the following markdown text and extract all code blocks, noting their positions in the text. Return a JSON list of objects where each object has:\n\n1. \"start_index\": The starting position of the code block in the original text\n2. \"end_index\": The ending position of the code block in the original text\n3. \"content\": The full text of the code block including the backtick markers\n4. \"language\": The programming language specified after the opening backticks, or \"none\" if not specified\n\nOnly include actual markdown code blocks (delimited by three backticks). Do not include inline code.\n\nMarkdown:\n{text}\"\"\"\n\ndef extract_code_blocks(text):\n    \"\"\"Extract code blocks from markdown text using regex\"\"\"\n    # Pattern to match code blocks (```language\\ncode\\n```)\n    pattern = r'```(?:[a-zA-Z0-9_+-]+)?\\n(?:.*?\\n)*?```'\n    \n    code_blocks = []\n    for match in re.finditer(pattern, text, re.DOTALL):\n        start_index = match.start()\n        end_index = match.end()\n        content = match.group(0)\n        \n        # Extract language if present\n        lang_match = re.match(r'```([a-zA-Z0-9_+-]+)?', content)\n        language = lang_match.group(1) if lang_match and lang_match.group(1) else \"none\"\n        \n        code_blocks.append({\n            \"start_index\": start_index,\n            \"end_index\": end_index,\n            \"content\": content,\n            \"language\": language\n        })\n    \n    return code_blocks\n\ndef translate_with_code_block_preservation(text, translate_function):\n    \"\"\"Translate markdown text while preserving code blocks\"\"\"\n    # Extract code blocks\n    code_blocks = extract_code_blocks(text)\n    \n    # If no code blocks, just translate the whole text\n    if not code_blocks:\n        return translate_function(text)\n    \n    # Split the text into translatable segments and code blocks\n    segments = []\n    last_end = 0\n    \n    for block in code_blocks:\n        # Add text before code block\n        if block[\"start_index\"] > last_end:\n            segments.append({\"type\": \"text\", \"content\": text[last_end:block[\"start_index\"]]})\n        \n        # Add code block\n        segments.append({\"type\": \"code\", \"content\": block[\"content\"]})\n        last_end = block[\"end_index\"]\n    \n    # Add remaining text after last code block\n    if last_end < len(text):\n        segments.append({\"type\": \"text\", \"content\": text[last_end:]})\n    \n    # Translate text segments, keep code blocks as is\n    translated_segments = []\n    for segment in segments:\n        if segment[\"type\"] == \"text\":\n            translated_segments.append(translate_function(segment[\"content\"]))\n        else:\n            translated_segments.append(segment[\"content\"])\n    \n    # Join all segments\n    return \"\".join(translated_segments)\n\u0005End File\u0006# ericmelz/claude-translate\n# claude_translate/prompts/translate_document.py\ntranslate_document_prompt = \"\"\"Translate the following text from {source_language_full} to {target_language_full}. \nReturn ONLY the translated text, nothing else.\n\n{text}\"\"\"\n\ntranslate_table_prompt = \"\"\"Translate the following table from {source_language_full} to {target_language_full}.\nMaintain the exact same table structure and formatting.\nReturn ONLY the translated table, nothing else.\n\n{text}\"\"\"\n\ntranslate_document_with_line_breaks_prompt = \"\"\"Translate the following text from {source_language_full} to {target_language_full}.\nPreserve all line breaks exactly as they appear in the original text.\nReturn ONLY the translated text, nothing else.\n\n{text}\"\"\"\n\ntranslate_document_detecting_format_prompt = \"\"\"Translate the following text from {source_language_full} to {target_language_full}.\nPreserve the original formatting:\n- Maintain all paragraph breaks\n- Preserve bullet points and numbered lists\n- Keep any special formatting (bolding, italics, etc.) if present\n- Maintain table structures if present\n- Preserve any headings or section titles\n\nReturn ONLY the translated text with the original formatting preserved.\n\n{text}\"\"\"\n\ntranslate_document_with_html_prompt = \"\"\"Translate the following HTML document from {source_language_full} to {target_language_full}.\nTranslate ONLY the visible text content, not HTML tags or attributes.\nPreserve all HTML tags and structure exactly as in the original.\nReturn the complete translated HTML document.\n\n{text}\"\"\"\n\ntranslate_document_with_json_prompt = \"\"\"Translate the following JSON content from {source_language_full} to {target_language_full}.\nTranslate ONLY the text values, not the keys or structure.\nMaintain the exact same JSON structure and formatting.\nEnsure the output remains valid JSON.\n\n{text}\"\"\"\n\ntranslate_code_prompt = \"\"\"Below is code with comments in {source_language_full}. Translate ONLY the comments to {target_language_full}.\nDo not modify any actual code, variable names, function names, or other code elements.\nMaintain the exact same code structure and formatting.\n\n{text}\"\"\"\n\ntranslate_document_placeholder_prompt = \"\"\"Translate the following text from {source_language_full} to {target_language_full}. \nPreserve all placeholders exactly as they appear (like {placeholder}, {{variable}}, $variable, etc.)\nReturn ONLY the translated text with placeholders intact, nothing else.\n\n{text}\"\"\"\n\ntranslate_document_with_code_blocks_prompt = \"\"\"Translate the following text from {source_language_full} to {target_language_full}.\nDo NOT translate:\n- Code blocks (text between backticks ` or triple backticks ```)\n- Variable names, function names, or other programming elements\n- File paths, URLs, or technical commands\n\nTranslate all other text, including comments within code if they're in {source_language_full}.\nPreserve all formatting and line breaks.\n\n{text}\"\"\"\n\ndetect_language_prompt = \"\"\"Detect the language of the following text and respond with ONLY the ISO 639-1 two-letter language code. For example, 'en' for English, 'es' for Spanish, 'fr' for French, etc.\n\nText:\n{text}\"\"\"\n\ndetect_document_format_prompt = \"\"\"Analyze the following text and identify its format and structure. Specifically identify:\n\n1. Whether it contains bullet points or numbered lists\n2. Whether it contains tables\n3. Whether it has clear headings or section titles\n4. Whether it contains any HTML markup\n5. Whether it contains code blocks or technical content\n6. If it contains any special placeholders (like {placeholder}, $variable, etc.)\n7. The overall document type (article, technical documentation, letter, etc.)\n\nReturn your analysis as a JSON object with these properties.\n\nText:\n{text}\"\"\"\n\u0005End File\u0006import os\nimport logging\nimport json\nfrom typing import Dict, Any, Optional\nfrom enum import Enum\nimport anthropic\nfrom .language_utils import (\n    get_language_code, \n    get_language_name, \n    is_valid_language_code,\n    is_valid_language_name\n)\n\n# Load environment variables\ntry:\n    from dotenv import load_dotenv\n    load_dotenv()\nexcept ImportError:\n    pass\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\nlogger = logging.getLogger(__name__)\n\nclass ModelType(str, Enum):\n    CLAUDE_3_OPUS = \"claude-3-opus-20240229\"\n    CLAUDE_3_SONNET = \"claude-3-sonnet-20240229\"\n    CLAUDE_3_HAIKU = \"claude-3-haiku-20240307\"\n    \n    @staticmethod\n    def get_default() -> str:\n        return ModelType.CLAUDE_3_HAIKU\n\nclass CloudeTranslate:\n    def __init__(self, \n                 api_key: Optional[str] = None, \n                 model: Optional[str] = None,\n                 max_tokens: int = 4096):\n        \"\"\"\n        Initialize the CloudeTranslate client.\n        \n        Args:\n            api_key: Anthropic API key. If not provided, will look for ANTHROPIC_API_KEY environment variable.\n            model: The Claude model to use for translations.\n            max_tokens: Maximum number of tokens for responses.\n        \"\"\"\n        self.api_key = api_key or os.getenv(\"ANTHROPIC_API_KEY\")\n        if not self.api_key:\n            raise ValueError(\"API key must be provided either directly or via ANTHROPIC_API_KEY environment variable\")\n        \n        self.model = model or ModelType.get_default()\n        self.max_tokens = max_tokens\n        self.client = anthropic.Anthropic(api_key=self.api_key)\n        \n    def _get_language_details(self, language: str) -> Dict[str, str]:\n        \"\"\"\n        Get language code and full name from a language identifier.\n        \n        Args:\n            language: A language identifier (code or name).\n            \n        Returns:\n            Dictionary with language code and full name.\n        \"\"\"\n        if is_valid_language_code(language):\n            code = language\n            name = get_language_name(code)\n        elif is_valid_language_name(language):\n            name = language\n            code = get_language_code(name)\n        else:\n            raise ValueError(f\"Invalid language: {language}\")\n            \n        return {\n            \"code\": code,\n            \"name\": name\n        }\n    \n    def _call_claude(self, prompt: str, system_prompt: Optional[str] = None) -> str:\n        \"\"\"\n        Make a call to the Claude API.\n        \n        Args:\n            prompt: The user prompt to send to Claude.\n            system_prompt: Optional system prompt for the request.\n            \n        Returns:\n            Claude's response as a string.\n        \"\"\"\n        try:\n            message = self.client.messages.create(\n                model=self.model,\n                max_tokens=self.max_tokens,\n                system=system_prompt,\n                messages=[\n                    {\"role\": \"user\", \"content\": prompt}\n                ]\n            )\n            return message.content[0].text\n        except Exception as e:\n            logger.error(f\"Error calling Claude API: {e}\")\n            raise\n    \n    def translate(self, \n                  text: str, \n                  source_language: Optional[str] = None, \n                  target_language: str = \"en\",\n                  document_type: Optional[str] = None,\n                  system_prompt: Optional[str] = None) -> str:\n        \"\"\"\n        Translate text from source language to target language.\n        \n        Args:\n            text: The text to translate.\n            source_language: The source language (code or name).\n            target_language: The target language (code or name).\n            document_type: Type of document for specialized translation.\n            system_prompt: Optional system prompt to guide Claude's translation.\n            \n        Returns:\n            Translated text.\n        \"\"\"\n        # Auto-detect language if not provided\n        if source_language is None:\n            from .prompts.translate_document import detect_language_prompt\n            detect_prompt = detect_language_prompt.format(text=text[:1000])  # Limit text for detection\n            detected_code = self._call_claude(detect_prompt)\n            source_language = detected_code.strip()\n            logger.info(f\"Detected language: {source_language}\")\n        \n        # Load prompt based on document type\n        from .prompt_loader import get_prompt_for_document_type\n        prompt_template = get_prompt_for_document_type(document_type)\n        \n        # Get language details\n        source_lang = self._get_language_details(source_language)\n        target_lang = self._get_language_details(target_language)\n        \n        # Format the prompt\n        prompt = prompt_template.format(\n            source_language_code=source_lang[\"code\"],\n            source_language_full=source_lang[\"name\"],\n            target_language_code=target_lang[\"code\"],\n            target_language_full=target_lang[\"name\"],\n            text=text\n        )\n        \n        # Call Claude for translation\n        return self._call_claude(prompt, system_prompt)\n        \n    def detect_language(self, text: str) -> str:\n        \"\"\"\n        Detect the language of a text.\n        \n        Args:\n            text: The text to analyze.\n            \n        Returns:\n            The detected language code.\n        \"\"\"\n        from .prompts.translate_document import detect_language_prompt\n        prompt = detect_language_prompt.format(text=text[:1000])  # Limit text size for detection\n        return self._call_claude(prompt).strip()\n    \n    def detect_document_format(self, text: str) -> Dict[str, Any]:\n        \"\"\"\n        Detect the format and structure of a document.\n        \n        Args:\n            text: The text to analyze.\n            \n        Returns:\n            Dictionary with detected format information.\n        \"\"\"\n        from .prompts.translate_document import detect_document_format_prompt\n        prompt = detect_document_format_prompt.format(text=text[:2000])  # Limit text size for detection\n        response = self._call_claude(prompt)\n        try:\n            return json.loads(response)\n        except json.JSONDecodeError:\n            logger.warning(\"Could not parse JSON response from format detection\")\n            return {\"format\": \"unknown\", \"details\": response}\n\u0005End File\u0006# ericmelz/claude-translate\n# README.md\n# Claude Translate\n\nA Python library for high-quality translations using Anthropic's Claude AI model. This library makes it easy to translate text while preserving formatting, handling specialized content like code, and detecting languages automatically.\n\n## Features\n\n- Translate between 100+ languages\n- Preserve document formatting (Markdown, HTML, etc.)\n- Special handling for code comments, tables, and placeholders\n- Automatic language detection\n- Document format detection\n- Customizable translation style and tone\n\n## Installation\n\n```bash\npip install claude-translate\n```\n\n## Authentication\n\nYou'll need an Anthropic API key to use this library. You can set it as an environment variable:\n\n```bash\nexport ANTHROPIC_API_KEY=your_api_key\n```\n\nOr provide it directly when initializing the client:\n\n```python\nfrom claude_translate import CloudeTranslate\n\nclient = CloudeTranslate(api_key=\"your_api_key\")\n```\n\n## Quick Start\n\n### Basic Translation\n\n```python\nfrom claude_translate import CloudeTranslate\n\n# Initialize the client\nclient = CloudeTranslate()\n\n# Translate text from Spanish to English\ntranslated_text = client.translate(\n    text=\"Hola, ¿cómo estás?\",\n    source_language=\"es\",\n    target_language=\"en\"\n)\n\nprint(translated_text)  # \"Hello, how are you?\"\n```\n\n### Automatic Language Detection\n\n```python\n# Translate without specifying the source language\ntranslated_text = client.translate(\n    text=\"Bonjour, comment ça va?\",\n    target_language=\"en\"\n)\n\nprint(translated_text)  # \"Hello, how are you?\"\n\n# Just detect the language\ndetected_language = client.detect_language(\"Guten Tag, wie geht es Ihnen?\")\nprint(detected_language)  # \"de\"\n```\n\n### Handling Different Document Types\n\n```python\n# Translate HTML while preserving tags\nhtml_translated = client.translate(\n    text=\"<p>Hola <strong>mundo</strong></p>\",\n    source_language=\"es\",\n    target_language=\"en\",\n    document_type=\"html\"\n)\n\n# Translate code comments only\ncode_translated = client.translate(\n    text=\"// Este es un comentario\\nconst x = 5;\",\n    source_language=\"es\",\n    target_language=\"en\",\n    document_type=\"code\"\n)\n\n# Translate markdown\nmarkdown_translated = client.translate(\n    text=\"# Título principal\\n* Punto uno\\n* Punto dos\",\n    source_language=\"es\",\n    target_language=\"en\",\n    document_type=\"markdown\"\n)\n```\n\n## Advanced Usage\n\n### Choose a Different Claude Model\n\n```python\nfrom claude_translate import CloudeTranslate, ModelType\n\n# Use Claude 3 Opus for highest quality translations\nclient = CloudeTranslate(model=ModelType.CLAUDE_3_OPUS)\n\n# Use Claude 3 Sonnet for a balance of quality and speed\nclient = CloudeTranslate(model=ModelType.CLAUDE_3_SONNET)\n\n# Use Claude 3 Haiku for fastest translations (default)\nclient = CloudeTranslate(model=ModelType.CLAUDE_3_HAIKU)\n```\n\n### Custom System Prompt\n\n```python\n# Add a custom system prompt to guide translation style\ntranslated_text = client.translate(\n    text=\"Bonjour à tous!\",\n    source_language=\"fr\",\n    target_language=\"en\",\n    system_prompt=\"Translate in a formal, academic tone.\"\n)\n```\n\n### Detect Document Format\n\n```python\n# Analyze the structure and format of a document\nformat_info = client.detect_document_format(\"\"\"\n# Meeting Notes\n- First item\n- Second item\n\n| Name | Role |\n|------|------|\n| Alice | Manager |\n| Bob | Developer |\n\"\"\")\n\nprint(format_info)\n# {\n#   \"contains_bullet_points\": true,\n#   \"contains_tables\": true,\n#   \"has_headings\": true,\n#   \"contains_html\": false,\n#   \"contains_code_blocks\": false,\n#   \"contains_placeholders\": false,\n#   \"document_type\": \"notes\"\n# }\n```\n\n## Supported Languages\n\nClaude Translate supports all languages that Claude can understand, which includes 100+ languages. The library can translate between any pair of these languages.\n\nSome commonly used language codes:\n\n- English: `en`\n- Spanish: `es`\n- French: `fr`\n- German: `de`\n- Chinese: `zh`\n- Japanese: `ja`\n- Russian: `ru`\n- Arabic: `ar`\n- Hindi: `hi`\n- Portuguese: `pt`\n\nYou can use either ISO language codes or full language names when specifying languages.\n\n## License\n\nThis project is licensed under the MIT License - see the [LICENSE](LICENSE) file for details.\n\n## Acknowledgements\n\n- This library is built on top of [Anthropic's Claude API](https://www.anthropic.com/)\n- Inspired by the need for high-quality, context-aware translations that preserve document structure\n\u0000# ryanbourdais/stormbraining-dnd\n# api/character_info.js\nconst db = require('./ddb');\nconst { Character, Action, Spellcasting, Skill } = require('./models/character');\nconst Inventory = require('./models/inventory');\nconst characterDetailsQuery = require('./queries/CharacterDetailsQuery');\nconst inventoryQuery = require('./queries/inventoryQuery');\n\nasync function getCharacterInfo(id) {\n  // Set up DDB connection\n  const ddb = await db();\n\n  // Fetch character info from DDB\n  const characterDetailsParams = {\n    TableName: 'Characters',\n    Key: {\n      id: id\n    }\n  };\n  \n  const inventoryParams = {\n    TableName: 'Inventory',\n    Key: {\n      characterId: id\n    }\n  };\n\n  // Fetch character info and inventory concurrently\n  const [characterDetailsResponse, inventoryResponse] = await Promise.all([\n    ddb.get(characterDetailsParams).promise(),\n    ddb.get(inventoryParams).promise()\n  ]);\n\n  const characterDetails = characterDetailsResponse.Item;\n  const inventory = inventoryResponse.Item;\n\n  if (!characterDetails) {\n    return null;\n  }\n\n  // Create a Character object\n  const character = new Character(\n    characterDetails.id,\n    characterDetails.user_id,\n    characterDetails.name,\n    characterDetails.race,\n    characterDetails.character_class,\n    characterDetails.level,\n    characterDetails.proficiency_bonus,\n    {\n      strength: characterDetails.ability_scores.strength,\n      dexterity: characterDetails.ability_scores.dexterity,\n      constitution: characterDetails.ability_scores.constitution,\n      intelligence: characterDetails.ability_scores.intelligence,\n      wisdom: characterDetails.ability_scores.wisdom,\n      charisma: characterDetails.ability_scores.charisma\n    },\n    characterDetails.hit_points.current,\n    characterDetails.hit_points.maximum,\n    characterDetails.hit_points.temporary,\n    characterDetails.hit_dice.current,\n    characterDetails.hit_dice.maximum,\n    characterDetails.armor_class,\n    characterDetails.initiative,\n    characterDetails.speed,\n    characterDetails.personality_traits,\n    characterDetails.ideals,\n    characterDetails.bonds,\n    characterDetails.flaws,\n    characterDetails.background,\n    characterDetails.alignment\n  );\n\n  // Add skills\n  for (const [name, data] of Object.entries(characterDetails.skills)) {\n    const skill = new Skill(\n      name,\n      data.proficient,\n      data.expertise,\n      data.ability,\n      data.bonus\n    );\n    character.addSkill(skill);\n  }\n\n  // Add actions\n  for (const actionData of characterDetails.actions || []) {\n    const action = new Action(\n      actionData.name,\n      actionData.description,\n      actionData.attack_bonus,\n      actionData.damage_dice,\n      actionData.damage_type\n    );\n    character.addAction(action);\n  }\n\n  // Add spellcasting if present\n  if (characterDetails.spellcasting) {\n    const spellcasting = new Spellcasting(\n      characterDetails.spellcasting.ability,\n      characterDetails.spellcasting.spell_save_dc,\n      characterDetails.spellcasting.spell_attack_bonus,\n      characterDetails.spellcasting.spells_known,\n      characterDetails.spellcasting.spell_slots\n    );\n    character.setSpellcasting(spellcasting);\n  }\n\n  // Add inventory\n  if (inventory) {\n    const inventoryObject = new Inventory(\n      inventory.characterId,\n      inventory.gold,\n      inventory.items || [],\n      inventory.weapons || [],\n      inventory.armor || []\n    );\n    character.setInventory(inventoryObject);\n  }\n\n  return character;\n}\n\nasync function updateCharacterInfo(id, updates) {\n  const ddb = await db();\n  \n  // First, get the current character to ensure we're updating real data\n  const currentCharacter = await getCharacterInfo(id);\n  if (!currentCharacter) {\n    throw new Error('Character not found');\n  }\n  \n  // Create an update expression and attribute values\n  let updateExpression = 'SET ';\n  const expressionAttributeValues = {};\n  const expressionAttributeNames = {};\n  \n  Object.entries(updates).forEach(([key, value], index) => {\n    // For each update field, create the appropriate update expression\n    const attributeValueKey = `:val${index}`;\n    const attributeNameKey = `#attr${index}`;\n    \n    expressionAttributeValues[attributeValueKey] = value;\n    expressionAttributeNames[attributeNameKey] = key;\n    \n    updateExpression += `${index > 0 ? ', ' : ''}${attributeNameKey} = ${attributeValueKey}`;\n  });\n  \n  const params = {\n    TableName: 'Characters',\n    Key: { id },\n    UpdateExpression: updateExpression,\n    ExpressionAttributeValues: expressionAttributeValues,\n    ExpressionAttributeNames: expressionAttributeNames,\n    ReturnValues: 'ALL_NEW'\n  };\n  \n  try {\n    const result = await ddb.update(params).promise();\n    return result.Attributes;\n  } catch (error) {\n    console.error('Error updating character:', error);\n    throw error;\n  }\n}\n\nasync function updateInventory(characterId, updates) {\n  const ddb = await db();\n  \n  // Create an update expression and attribute values\n  let updateExpression = 'SET ';\n  const expressionAttributeValues = {};\n  const expressionAttributeNames = {};\n  \n  Object.entries(updates).forEach(([key, value], index) => {\n    const attributeValueKey = `:val${index}`;\n    const attributeNameKey = `#attr${index}`;\n    \n    expressionAttributeValues[attributeValueKey] = value;\n    expressionAttributeNames[attributeNameKey] = key;\n    \n    updateExpression += `${index > 0 ? ', ' : ''}${attributeNameKey} = ${attributeValueKey}`;\n  });\n  \n  const params = {\n    TableName: 'Inventory',\n    Key: { characterId },\n    UpdateExpression: updateExpression,\n    ExpressionAttributeValues: expressionAttributeValues,\n    ExpressionAttributeNames: expressionAttributeNames,\n    ReturnValues: 'ALL_NEW'\n  };\n  \n  try {\n    const result = await ddb.update(params).promise();\n    return result.Attributes;\n  } catch (error) {\n    console.error('Error updating inventory:', error);\n    throw error;\n  }\n}\n\nmodule.exports = {\n  getCharacterInfo,\n  updateCharacterInfo,\n  updateInventory\n};\n\u0005End File\u0006# api/character_creation.js\nconst { v4: uuidv4 } = require('uuid');\nconst db = require('./ddb');\nconst { createNewCharacter } = require('./queries/createNewCharacter');\nconst { createNewInventory } = require('./queries/createNewInventory');\n\n// Calculate ability score modifier\nfunction getAbilityModifier(abilityScore) {\n  return Math.floor((abilityScore - 10) / 2);\n}\n\nasync function calculateCharacterStats(formData) {\n  // Calculate ability modifiers\n  const abilityScores = {\n    strength: parseInt(formData.strength),\n    dexterity: parseInt(formData.dexterity),\n    constitution: parseInt(formData.constitution),\n    intelligence: parseInt(formData.intelligence),\n    wisdom: parseInt(formData.wisdom),\n    charisma: parseInt(formData.charisma)\n  };\n\n  const modifiers = {\n    strength: getAbilityModifier(abilityScores.strength),\n    dexterity: getAbilityModifier(abilityScores.dexterity),\n    constitution: getAbilityModifier(abilityScores.constitution),\n    intelligence: getAbilityModifier(abilityScores.intelligence),\n    wisdom: getAbilityModifier(abilityScores.wisdom),\n    charisma: getAbilityModifier(abilityScores.charisma)\n  };\n\n  // Calculate HP based on class and constitution\n  let baseHP = 0;\n  switch (formData.class) {\n    case 'Barbarian':\n      baseHP = 12;\n      break;\n    case 'Fighter':\n    case 'Paladin':\n    case 'Ranger':\n      baseHP = 10;\n      break;\n    case 'Bard':\n    case 'Cleric':\n    case 'Druid':\n    case 'Monk':\n    case 'Rogue':\n    case 'Warlock':\n      baseHP = 8;\n      break;\n    case 'Sorcerer':\n    case 'Wizard':\n      baseHP = 6;\n      break;\n    default:\n      baseHP = 8;\n  }\n\n  const maxHP = baseHP + modifiers.constitution;\n\n  // Calculate armor class (assuming no armor for simplicity)\n  // Default is 10 + dexterity modifier\n  const armorClass = 10 + modifiers.dexterity;\n\n  // Calculate initiative (dexterity modifier)\n  const initiative = modifiers.dexterity;\n\n  // Calculate speed based on race (simplified)\n  let speed = 30; // Default for most races\n  if (['Dwarf', 'Halfling', 'Gnome'].includes(formData.race)) {\n    speed = 25;\n  } else if (['Elf', 'Half-Elf'].includes(formData.race)) {\n    speed = 30;\n  }\n\n  // Determine proficiency bonus based on level\n  const level = 1;\n  const proficiencyBonus = 2; // Level 1-4 proficiency bonus\n\n  // Determine class-specific hit dice\n  let hitDice;\n  switch (formData.class) {\n    case 'Barbarian':\n      hitDice = 'd12';\n      break;\n    case 'Fighter':\n    case 'Paladin':\n    case 'Ranger':\n      hitDice = 'd10';\n      break;\n    case 'Bard':\n    case 'Cleric':\n    case 'Druid':\n    case 'Monk':\n    case 'Rogue':\n    case 'Warlock':\n      hitDice = 'd8';\n      break;\n    case 'Sorcerer':\n    case 'Wizard':\n      hitDice = 'd6';\n      break;\n    default:\n      hitDice = 'd8';\n  }\n\n  // Determine skills based on class\n  const skills = calculateSkills(formData, modifiers, proficiencyBonus);\n\n  return {\n    abilityScores,\n    modifiers,\n    maxHP,\n    armorClass,\n    initiative,\n    speed,\n    level,\n    proficiencyBonus,\n    hitDice,\n    skills\n  };\n}\n\nfunction calculateSkills(formData, modifiers, proficiencyBonus) {\n  // Map of skill names to their associated ability scores\n  const skillsMap = {\n    acrobatics: 'dexterity',\n    animalHandling: 'wisdom',\n    arcana: 'intelligence',\n    athletics: 'strength',\n    deception: 'charisma',\n    history: 'intelligence',\n    insight: 'wisdom',\n    intimidation: 'charisma',\n    investigation: 'intelligence',\n    medicine: 'wisdom',\n    nature: 'intelligence',\n    perception: 'wisdom',\n    performance: 'charisma',\n    persuasion: 'charisma',\n    religion: 'intelligence',\n    sleightOfHand: 'dexterity',\n    stealth: 'dexterity',\n    survival: 'wisdom'\n  };\n\n  // Initialize skills with their base values (ability modifiers)\n  const skills = {};\n  for (const [skill, ability] of Object.entries(skillsMap)) {\n    skills[skill] = {\n      ability,\n      proficient: false,\n      expertise: false,\n      bonus: modifiers[ability]\n    };\n  }\n\n  // Apply proficiencies based on selected skills from formData\n  if (formData.skills && Array.isArray(formData.skills)) {\n    formData.skills.forEach(skill => {\n      if (skills[skill]) {\n        skills[skill].proficient = true;\n        skills[skill].bonus += proficiencyBonus;\n      }\n    });\n  }\n\n  return skills;\n}\n\nasync function createCharacter(formData, userId) {\n  try {\n    const characterId = uuidv4();\n    const stats = await calculateCharacterStats(formData);\n\n    // Create character object with calculated stats\n    const character = {\n      id: characterId,\n      user_id: userId,\n      name: formData.name,\n      race: formData.race,\n      character_class: formData.class,\n      level: stats.level,\n      proficiency_bonus: stats.proficiencyBonus,\n      ability_scores: stats.abilityScores,\n      hit_points: {\n        current: stats.maxHP,\n        maximum: stats.maxHP,\n        temporary: 0\n      },\n      hit_dice: {\n        current: stats.level,\n        maximum: stats.level,\n        type: stats.hitDice\n      },\n      armor_class: stats.armorClass,\n      initiative: stats.initiative,\n      speed: stats.speed,\n      personality_traits: formData.personalityTraits || '',\n      ideals: formData.ideals || '',\n      bonds: formData.bonds || '',\n      flaws: formData.flaws || '',\n      background: formData.background || '',\n      alignment: formData.alignment || '',\n      skills: stats.skills,\n      actions: [], // Will be populated based on class abilities\n      spellcasting: null // Will be populated if applicable\n    };\n\n    // Create inventory object\n    const inventory = {\n      characterId: characterId,\n      gold: 0,\n      items: [],\n      weapons: [],\n      armor: []\n    };\n\n    // Add starting class equipment (simplified)\n    const startingEquipment = getStartingEquipment(formData.class);\n    inventory.weapons = startingEquipment.weapons;\n    inventory.armor = startingEquipment.armor;\n    inventory.items = startingEquipment.items;\n    inventory.gold = startingEquipment.gold;\n\n    // Add class actions\n    character.actions = getClassActions(formData.class, stats.modifiers, stats.proficiencyBonus);\n\n    // Add spellcasting if applicable\n    if (isSpellcaster(formData.class)) {\n      character.spellcasting = getSpellcastingAbility(formData.class, stats.modifiers);\n    }\n\n    // Save character and inventory to database\n    const ddb = await db();\n    \n    // Using the transactWrite method to ensure both operations succeed or fail together\n    const params = {\n      TransactItems: [\n        {\n          Put: {\n            TableName: 'Characters',\n            Item: character\n          }\n        },\n        {\n          Put: {\n            TableName: 'Inventory',\n            Item: inventory\n          }\n        }\n      ]\n    };\n\n    await ddb.transactWrite(params).promise();\n    return characterId;\n  } catch (error) {\n    console.error('Error creating character:', error);\n    throw error;\n  }\n}\n\nfunction getStartingEquipment(characterClass) {\n  const equipment = {\n    weapons: [],\n    armor: [],\n    items: [],\n    gold: 0\n  };\n\n  switch (characterClass) {\n    case 'Fighter':\n      equipment.weapons.push({ \n        name: 'Longsword', \n        damage: '1d8', \n        damageType: 'slashing', \n        properties: ['versatile (1d10)']\n      });\n      equipment.armor.push({ \n        name: 'Chain Mail', \n        type: 'heavy', \n        armorClass: 16, \n        strengthRequirement: 13, \n        stealthDisadvantage: true\n      });\n      equipment.items.push({ name: 'Explorer\\'s Pack', quantity: 1 });\n      equipment.gold = 10;\n      break;\n    case 'Wizard':\n      equipment.weapons.push({ \n        name: 'Dagger', \n        damage: '1d4', \n        damageType: 'piercing', \n        properties: ['finesse', 'light', 'thrown (range 20/60)']\n      });\n      equipment.items.push(\n        { name: 'Spellbook', quantity: 1 },\n        { name: 'Scholar\\'s Pack', quantity: 1 },\n        { name: 'Component Pouch', quantity: 1 }\n      );\n      equipment.gold = 10;\n      break;\n    case 'Rogue':\n      equipment.weapons.push(\n        { \n          name: 'Shortsword', \n          damage: '1d6', \n          damageType: 'piercing', \n          properties: ['finesse', 'light']\n        },\n        { \n          name: 'Shortbow', \n          damage: '1d6', \n          damageType: 'piercing', \n          properties: ['ammunition (range 80/320)', 'two-handed']\n        }\n      );\n      equipment.armor.push({ \n        name: 'Leather Armor', \n        type: 'light', \n        armorClass: 11 \n      });\n      equipment.items.push(\n        { name: 'Burglar\\'s Pack', quantity: 1 },\n        { name: 'Thieves\\' Tools', quantity: 1 }\n      );\n      equipment.gold = 15;\n      break;\n    case 'Cleric':\n      equipment.weapons.push({ \n        name: 'Mace', \n        damage: '1d6', \n        damageType: 'bludgeoning'\n      });\n      equipment.armor.push({ \n        name: 'Scale Mail', \n        type: 'medium', \n        armorClass: 14, \n        stealthDisadvantage: true\n      });\n      equipment.items.push(\n        { name: 'Shield', quantity: 1 },\n        { name: 'Holy Symbol', quantity: 1 },\n        { name: 'Priest\\'s Pack', quantity: 1 }\n      );\n      equipment.gold = 5;\n      break;\n    default:\n      equipment.weapons.push({ \n        name: 'Club', \n        damage: '1d4', \n        damageType: 'bludgeoning', \n        properties: ['light']\n      });\n      equipment.items.push({ name: 'Adventurer\\'s Pack', quantity: 1 });\n      equipment.gold = 10;\n  }\n\n  return equipment;\n}\n\nfunction getClassActions(characterClass, modifiers, proficiencyBonus) {\n  const actions = [];\n  \n  // Add weapon attacks as actions\n  const startingEquipment = getStartingEquipment(characterClass);\n  \n  startingEquipment.weapons.forEach(weapon => {\n    // Determine which ability modifier to use for the attack\n    let attackMod = modifiers.strength;\n    let abilityName = 'strength';\n    \n    // Check if weapon has finesse property (can use DEX instead of STR)\n    if (weapon.properties && weapon.properties.includes('finesse') && modifiers.dexterity > modifiers.strength) {\n      attackMod = modifiers.dexterity;\n      abilityName = 'dexterity';\n    }\n    \n    // Ranged weapons typically use DEX\n    if (weapon.properties && (\n      weapon.properties.includes('ammunition') || \n      weapon.properties.includes('thrown')\n    )) {\n      attackMod = modifiers.dexterity;\n      abilityName = 'dexterity';\n    }\n    \n    // Calculate attack bonus (ability mod + proficiency bonus)\n    const attackBonus = attackMod + proficiencyBonus;\n    \n    actions.push({\n      name: `${weapon.name} Attack`,\n      description: `Attack with ${weapon.name}`,\n      attack_bonus: attackBonus,\n      damage_dice: `${weapon.damage} + ${attackMod}`,\n      damage_type: weapon.damageType,\n      ability: abilityName\n    });\n  });\n  \n  // Add class-specific actions\n  switch (characterClass) {\n    case 'Fighter':\n      actions.push({\n        name: 'Second Wind',\n        description: 'You have a limited well of stamina that you can draw on to protect yourself from harm. As a bonus action, you can regain hit points equal to 1d10 + your fighter level. Once you use this feature, you must finish a short or long rest before you can use it again.',\n        attack_bonus: null,\n        damage_dice: null,\n        damage_type: null\n      });\n      break;\n    case 'Rogue':\n      actions.push({\n        name: 'Sneak Attack',\n        description: 'Once per turn, you can deal extra damage when you hit a creature with an attack if you have advantage on the attack roll. The attack must use a finesse or a ranged weapon. You don\\'t need advantage on the attack roll if another enemy of the target is within 5 feet of it, that enemy isn\\'t incapacitated, and you don\\'t have disadvantage on the attack roll. The extra damage is 1d6 at 1st level.',\n        attack_bonus: null,\n        damage_dice: '1d6',\n        damage_type: 'same as weapon'\n      });\n      break;\n    case 'Wizard':\n      actions.push({\n        name: 'Arcane Recovery',\n        description: 'You have learned to regain some of your magical energy by studying your spellbook. Once per day when you finish a short rest, you can choose expended spell slots to recover. The spell slots can have a combined level that is equal to or less than half your wizard level (rounded up), and none of the slots can be 6th level or higher.',\n        attack_bonus: null,\n        damage_dice: null,\n        damage_type: null\n      });\n      break;\n    case 'Cleric':\n      actions.push({\n        name: 'Turn Undead',\n        description: 'As an action, you present your holy symbol and speak a prayer censuring the undead. Each undead that can see or hear you within 30 feet of you must make a Wisdom saving throw. If the creature fails its saving throw, it is turned for 1 minute or until it takes any damage.',\n        attack_bonus: null,\n        damage_dice: null,\n        damage_type: null\n      });\n      break;\n  }\n  \n  return actions;\n}\n\nfunction isSpellcaster(characterClass) {\n  return ['Wizard', 'Cleric', 'Bard', 'Druid', 'Sorcerer', 'Warlock', 'Paladin', 'Ranger'].includes(characterClass);\n}\n\nfunction getSpellcastingAbility(characterClass, modifiers) {\n  let ability;\n  \n  switch (characterClass) {\n    case 'Wizard':\n      ability = 'intelligence';\n      break;\n    case 'Cleric':\n    case 'Druid':\n      ability = 'wisdom';\n      break;\n    case 'Bard':\n    case 'Sorcerer':\n    case 'Warlock':\n    case 'Paladin':\n      ability = 'charisma';\n      break;\n    case 'Ranger':\n      ability = 'wisdom';\n      break;\n    default:\n      return null;\n  }\n  \n  const spellMod = modifiers[ability];\n  const spellSaveDC = 8 + 2 + spellMod; // 8 + proficiency bonus + ability modifier\n  const spellAttackBonus = 2 + spellMod; // proficiency bonus + ability modifier\n  \n  // Set up spell slots based on class and level (1st level)\n  let spellSlots = {};\n  \n  if (['Wizard', 'Cleric', 'Bard', 'Druid', 'Sorcerer'].includes(characterClass)) {\n    spellSlots = {\n      '1': { total: 2, used: 0 }\n    };\n  } else if (characterClass === 'Warlock') {\n    spellSlots = {\n      '1': { total: 1, used: 0 }\n    };\n  } else if (['Paladin', 'Ranger'].includes(characterClass)) {\n    // Paladins and Rangers don't get spell slots at level 1\n    spellSlots = {};\n  }\n  \n  // Determine known spells based on class\n  let spellsKnown = [];\n  \n  if (characterClass === 'Wizard') {\n    spellsKnown = [\n      { name: 'Mage Hand', level: 0, prepared: true },\n      { name: 'Light', level: 0, prepared: true },\n      { name: 'Magic Missile', level: 1, prepared: true },\n      { name: 'Shield', level: 1, prepared: true }\n    ];\n  } else if (characterClass === 'Cleric') {\n    spellsKnown = [\n      { name: 'Light', level: 0, prepared: true },\n      { name: 'Sacred Flame', level: 0, prepared: true },\n      { name: 'Cure Wounds', level: 1, prepared: true },\n      { name: 'Bless', level: 1, prepared: true }\n    ];\n  }\n  \n  return {\n    ability,\n    spell_save_dc: spellSaveDC,\n    spell_attack_bonus: spellAttackBonus,\n    spells_known: spellsKnown,\n    spell_slots: spellSlots\n  };\n}\n\nmodule.exports = {\n  createCharacter\n};\n\u0005End File\u0006# api/models/character.js\nclass Character {\n  constructor(\n    id,\n    userId,\n    name,\n    race,\n    characterClass,\n    level,\n    proficiencyBonus,\n    abilityScores,\n    currentHP,\n    maxHP,\n    tempHP,\n    currentHitDice,\n    maxHitDice,\n    armorClass,\n    initiative,\n    speed,\n    personalityTraits,\n    ideals,\n    bonds,\n    flaws,\n    background,\n    alignment\n  ) {\n    this.id = id;\n    this.userId = userId;\n    this.name = name;\n    this.race = race;\n    this.characterClass = characterClass;\n    this.level = level;\n    this.proficiencyBonus = proficiencyBonus;\n    this.abilityScores = abilityScores;\n    this.hitPoints = {\n      current: currentHP,\n      maximum: maxHP,\n      temporary: tempHP || 0\n    };\n    this.hitDice = {\n      current: currentHitDice,\n      maximum: maxHitDice\n    };\n    this.armorClass = armorClass;\n    this.initiative = initiative;\n    this.speed = speed;\n    this.personalityTraits = personalityTraits || '';\n    this.ideals = ideals || '';\n    this.bonds = bonds || '';\n    this.flaws = flaws || '';\n    this.background = background || '';\n    this.alignment = alignment || '';\n    this.skills = {};\n    this.actions = [];\n    this.spellcasting = null;\n    this.inventory = null;\n  }\n\n  // Calculate ability score modifiers\n  getAbilityModifier(ability) {\n    const score = this.abilityScores[ability];\n    return Math.floor((score - 10) / 2);\n  }\n\n  // Add a skill to the character\n  addSkill(skill) {\n    this.skills[skill.name] = skill;\n  }\n\n  // Add an action to the character\n  addAction(action) {\n    this.actions.push(action);\n  }\n\n  // Set the character's spellcasting\n  setSpellcasting(spellcasting) {\n    this.spellcasting = spellcasting;\n  }\n\n  // Set the character's inventory\n  setInventory(inventory) {\n    this.inventory = inventory;\n  }\n\n  // Update hit points\n  updateHitPoints(amount, isHealing = false) {\n    if (isHealing) {\n      this.hitPoints.current = Math.min(this.hitPoints.current + amount, this.hitPoints.maximum);\n    } else {\n      // Damage first reduces temporary hit points\n      if (this.hitPoints.temporary > 0) {\n        if (amount <= this.hitPoints.temporary) {\n          this.hitPoints.temporary -= amount;\n          amount = 0;\n        } else {\n          amount -= this.hitPoints.temporary;\n          this.hitPoints.temporary = 0;\n        }\n      }\n      \n      // Then reduce current hit points\n      this.hitPoints.current = Math.max(0, this.hitPoints.current - amount);\n    }\n  }\n\n  // Add temporary hit points (they don't stack, take the higher value)\n  addTemporaryHitPoints(amount) {\n    this.hitPoints.temporary = Math.max(this.hitPoints.temporary, amount);\n  }\n\n  // Use hit dice to heal\n  useHitDice(diceCount) {\n    if (this.hitDice.current < diceCount) {\n      return false; // Not enough hit dice\n    }\n    \n    // Calculate healing (simplified - assumes d8 hit dice)\n    const diceType = 8; // This would come from the character's class\n    let healing = 0;\n    \n    for (let i = 0; i < diceCount; i++) {\n      healing += Math.floor(Math.random() * diceType) + 1 + this.getAbilityModifier('constitution');\n    }\n    \n    this.hitDice.current -= diceCount;\n    this.updateHitPoints(healing, true);\n    \n    return healing;\n  }\n\n  // Get skill check bonus\n  getSkillBonus(skillName) {\n    if (!this.skills[skillName]) {\n      // Default to ability check if skill not found\n      const abilityForSkill = this.getAbilityForSkill(skillName);\n      return this.getAbilityModifier(abilityForSkill);\n    }\n    \n    return this.skills[skillName].bonus;\n  }\n\n  // Helper to map skill to ability\n  getAbilityForSkill(skillName) {\n    const skillToAbility = {\n      'acrobatics': 'dexterity',\n      'animal handling': 'wisdom',\n      'arcana': 'intelligence',\n      'athletics': 'strength',\n      'deception': 'charisma',\n      'history': 'intelligence',\n      'insight': 'wisdom',\n      'intimidation': 'charisma',\n      'investigation': 'intelligence',\n      'medicine': 'wisdom',\n      'nature': 'intelligence',\n      'perception': 'wisdom',\n      'performance': 'charisma',\n      'persuasion': 'charisma',\n      'religion': 'intelligence',\n      'sleight of hand': 'dexterity',\n      'stealth': 'dexterity',\n      'survival': 'wisdom'\n    };\n    \n    return skillToAbility[skillName.toLowerCase()] || 'dexterity';\n  }\n}\n\nclass Skill {\n  constructor(name, isProficient, hasExpertise, ability, bonus) {\n    this.name = name;\n    this.isProficient = isProficient;\n    this.hasExpertise = hasExpertise;\n    this.ability = ability;\n    this.bonus = bonus;\n  }\n}\n\nclass Action {\n  constructor(name, description, attackBonus, damageDice, damageType) {\n    this.name = name;\n    this.description = description;\n    this.attackBonus = attackBonus;\n    this.damageDice = damageDice;\n    this.damageType = damageType;\n  }\n}\n\nclass Spellcasting {\n  constructor(ability, spellSaveDC, spellAttackBonus, spellsKnown, spellSlots) {\n    this.ability = ability;\n    this.spellSaveDC = spellSaveDC;\n    this.spellAttackBonus = spellAttackBonus;\n    this.spellsKnown = spellsKnown || [];\n    this.spellSlots = spellSlots || {};\n  }\n\n  // Cast a spell and reduce the appropriate spell slot\n  castSpell(spellName, level) {\n    // Find the spell\n    const spell = this.spellsKnown.find(s => s.name === spellName);\n    if (!spell) {\n      return false; // Spell not known\n    }\n    \n    // Check if we have a slot of the appropriate level\n    const slotLevel = level || spell.level;\n    if (slotLevel > 0) { // Cantrips don't use spell slots\n      const slot = this.spellSlots[slotLevel];\n      if (!slot || slot.used >= slot.total) {\n        return false; // No slot available\n      }\n      \n      // Use a spell slot\n      slot.used++;\n    }\n    \n    return true;\n  }\n\n  // Recover spell slots (e.g., after a long rest)\n  resetSpellSlots() {\n    Object.keys(this.spellSlots).forEach(level => {\n      this.spellSlots[level].used = 0;\n    });\n  }\n}\n\nmodule.exports = {\n  Character,\n  Skill,\n  Action,\n  Spellcasting\n};\n\u0005End File\u0006// src/Components/CharacterSheet/Spells.js\nimport React, { useState } from 'react';\nimport { Grid, Box, Typography, Divider, Button, List, ListItem, ListItemText, Dialog, DialogTitle, DialogContent, TextField, FormControl, InputLabel, Select, MenuItem, DialogActions, IconButton } from '@mui/material';\nimport { Edit as EditIcon, Add as AddIcon, Delete as DeleteIcon } from '@mui/icons-material';\n\nconst spellLevels = [\n  { level: 0, name: 'Cantrips' },\n  { level: 1, name: '1st Level' },\n  { level: 2, name: '2nd Level' },\n  { level: 3, name: '3rd Level' },\n  { level: 4, name: '4th Level' },\n  { level: 5, name: '5th Level' },\n  { level: 6, name: '6th Level' },\n  { level: 7, name: '7th Level' },\n  { level: 8, name: '8th Level' },\n  { level: 9, name: '9th Level' }\n];\n\nconst SpellsTab = ({ character, onUpdateCharacter }) => {\n  const [openSpellDialog, setOpenSpellDialog] = useState(false);\n  const [selectedSpell, setSelectedSpell] = useState(null);\n  const [newSpell, setNewSpell] = useState({\n    name: '',\n    level: 0,\n    description: '',\n    castingTime: '',\n    range: '',\n    components: '',\n    duration: '',\n    prepared: false\n  });\n  const [openDeleteDialog, setOpenDeleteDialog] = useState(false);\n  const [spellToDelete, setSpellToDelete] = useState(null);\n\n  const spellcasting = character.spellcasting || {\n    ability: 'intelligence',\n    spell_save_dc: 10,\n    spell_attack_bonus: 2,\n    spells_known: [],\n    spell_slots: {}\n  };\n\n  // Group spells by level\n  const groupedSpells = {};\n  spellLevels.forEach(levelInfo => {\n    groupedSpells[levelInfo.level] = [];\n  });\n\n  if (spellcasting.spells_known) {\n    spellcasting.spells_known.forEach(spell => {\n      if (!groupedSpells[spell.level]) {\n        groupedSpells[spell.level] = [];\n      }\n      groupedSpells[spell.level].push(spell);\n    });\n  }\n\n  const handleOpenSpellDialog = (spell = null) => {\n    if (spell) {\n      setSelectedSpell(spell);\n      setNewSpell({\n        name: spell.name,\n        level: spell.level,\n        description: spell.description || '',\n        castingTime: spell.castingTime || '',\n        range: spell.range || '',\n        components: spell.components || '',\n        duration: spell.duration || '',\n        prepared: spell.prepared || false\n      });\n    } else {\n      setSelectedSpell(null);\n      setNewSpell({\n        name: '',\n        level: 0,\n        description: '',\n        castingTime: '',\n        range: '',\n        components: '',\n        duration: '',\n        prepared: false\n      });\n    }\n    setOpenSpellDialog(true);\n  };\n\n  const handleCloseSpellDialog = () => {\n    setOpenSpellDialog(false);\n  };\n\n  const handleOpenDeleteDialog = (spell) => {\n    setSpellToDelete(spell);\n    setOpenDeleteDialog(true);\n  };\n\n  const handleCloseDeleteDialog = () => {\n    setOpenDeleteDialog(false);\n    setSpellToDelete(null);\n  };\n\n  const handleDeleteSpell = () => {\n    if (!spellToDelete) return;\n\n    const updatedSpells = spellcasting.spells_known.filter(spell => \n      !(spell.name === spellToDelete.name && spell.level === spellToDelete.level)\n    );\n\n    const updatedSpellcasting = {\n      ...spellcasting,\n      spells_known: updatedSpells\n    };\n\n    onUpdateCharacter({\n      spellcasting: updatedSpellcasting\n    });\n\n    handleCloseDeleteDialog();\n  };\n\n  const handleSaveSpell = () => {\n    const updatedSpellsKnown = [...(spellcasting.spells_known || [])];\n    \n    if (selectedSpell) {\n      // Update existing spell\n      const index = updatedSpellsKnown.findIndex(spell => \n        spell.name === selectedSpell.name && spell.level === selectedSpell.level\n      );\n      \n      if (index !== -1) {\n        updatedSpellsKnown[index] = { ...newSpell };\n      }\n    } else {\n      // Add new spell\n      updatedSpellsKnown.push({ ...newSpell });\n    }\n\n    const updatedSpellcasting = {\n      ...spellcasting,\n      spells_known: updatedSpellsKnown\n    };\n\n    onUpdateCharacter({\n      spellcasting: updatedSpellcasting\n    });\n\n    handleCloseSpellDialog();\n  };\n\n  const handleInputChange = (e) => {\n    const { name, value } = e.target;\n    setNewSpell(prev => ({ ...prev, [name]: value }));\n  };\n\n  const handleTogglePrepared = (spellToToggle) => {\n    const updatedSpellsKnown = spellcasting.spells_known.map(spell => {\n      if (spell.name === spellToToggle.name && spell.level === spellToToggle.level) {\n        return { ...spell, prepared: !spell.prepared };\n      }\n      return spell;\n    });\n\n    const updatedSpellcasting = {\n      ...spellcasting,\n      spells_known: updatedSpellsKnown\n    };\n\n    onUpdateCharacter({\n      spellcasting: updatedSpellcasting\n    });\n  };\n\n  const handleChangeSpellSlots = (level, type, value) => {\n    const updatedSpellSlots = { ...spellcasting.spell_slots };\n    \n    if (!updatedSpellSlots[level]) {\n      updatedSpellSlots[level] = { total: 0, used: 0 };\n    }\n    \n    updatedSpellSlots[level] = {\n      ...updatedSpellSlots[level],\n      [type]: parseInt(value, 10) || 0\n    };\n\n    const updatedSpellcasting = {\n      ...spellcasting,\n      spell_slots: updatedSpellSlots\n    };\n\n    onUpdateCharacter({\n      spellcasting: updatedSpellcasting\n    });\n  };\n\n  return (\n    <Box sx={{ p: 2 }}>\n      <Typography variant=\"h5\" gutterBottom>Spellcasting</Typography>\n      \n      <Grid container spacing={2} sx={{ mb: 3 }}>\n        <Grid item xs={4}>\n          <Box sx={{ border: 1, borderColor: 'divider', p: 2, borderRadius: 1 }}>\n            <Typography variant=\"subtitle2\">Spellcasting Ability</Typography>\n            <Typography variant=\"h6\">{spellcasting.ability || 'None'}</Typography>\n          </Box>\n        </Grid>\n        <Grid item xs={4}>\n          <Box sx={{ border: 1, borderColor: 'divider', p: 2, borderRadius: 1 }}>\n            <Typography variant=\"subtitle2\">Spell Save DC</Typography>\n            <Typography variant=\"h6\">{spellcasting.spell_save_dc || '—'}</Typography>\n          </Box>\n        </Grid>\n        <Grid item xs={4}>\n          <Box sx={{ border: 1, borderColor: 'divider', p: 2, borderRadius: 1 }}>\n            <Typography variant=\"subtitle2\">Spell Attack Bonus</Typography>\n            <Typography variant=\"h6\">+{spellcasting.spell_attack_bonus || '—'}</Typography>\n          </Box>\n        </Grid>\n      </Grid>\n\n      <Typography variant=\"h6\" gutterBottom>Spell Slots</Typography>\n      <Grid container spacing={2} sx={{ mb: 3 }}>\n        {[1, 2, 3, 4, 5, 6, 7, 8, 9].map(level => {\n          const slotInfo = spellcasting.spell_slots[level] || { total: 0, used: 0 };\n          return (\n            <Grid item xs={4} key={level}>\n              <Box sx={{ border: 1, borderColor: 'divider', p: 2, borderRadius: 1 }}>\n                <Typography variant=\"subtitle2\">Level {level}</Typography>\n                <Grid container spacing={1} alignItems=\"center\">\n                  <Grid item xs={6}>\n                    <TextField\n                      label=\"Total\"\n                      type=\"number\"\n                      size=\"small\"\n                      value={slotInfo.total}\n                      onChange={(e) => handleChangeSpellSlots(level, 'total', e.target.value)}\n                      inputProps={{ min: 0 }}\n                    />\n                  </Grid>\n                  <Grid item xs={6}>\n                    <TextField\n                      label=\"Used\"\n                      type=\"number\"\n                      size=\"small\"\n                      value={slotInfo.used}\n                      onChange={(e) => handleChangeSpellSlots(level, 'used', e.target.value)}\n                      inputProps={{ min: 0, max: slotInfo.total }}\n                    />\n                  </Grid>\n                </Grid>\n              </Box>\n            </Grid>\n          );\n        })}\n      </Grid>\n\n      <Box sx={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', mb: 2 }}>\n        <Typography variant=\"h6\">Spells</Typography>\n        <Button \n          variant=\"contained\" \n          startIcon={<AddIcon />}\n          onClick={() => handleOpenSpellDialog()}\n        >\n          Add Spell\n        </Button>\n      </Box>\n      \n      {spellLevels.map(levelInfo => {\n        const spellsForLevel = groupedSpells[levelInfo.level] || [];\n        if (levelInfo.level > 0 && spellsForLevel.length === 0) return null;\n        \n        return (\n          <Box key={levelInfo.level} sx={{ mb: 3 }}>\n            <Typography variant=\"subtitle1\" sx={{ fontWeight: 'bold', mb: 1 }}>\n              {levelInfo.name}\n            </Typography>\n            <Divider sx={{ mb: 1 }} />\n            \n            {spellsForLevel.length > 0 ? (\n              <List dense>\n                {spellsForLevel.map((spell, index) => (\n                  <ListItem \n                    key={index} \n                    secondaryAction={\n                      <Box>\n                        <IconButton \n                          edge=\"end\" \n                          aria-label=\"edit\"\n                          onClick={() => handleOpenSpellDialog(spell)}\n                        >\n                          <EditIcon fontSize=\"small\" />\n                        </IconButton>\n                        <IconButton \n                          edge=\"end\" \n                          aria-label=\"delete\"\n                          onClick={() => handleOpenDeleteDialog(spell)}\n                        >\n                          <DeleteIcon fontSize=\"small\" />\n                        </IconButton>\n                      </Box>\n                    }\n                  >\n                    <ListItemText\n                      primary={\n                        <Box component=\"span\" sx={{ display: 'flex', alignItems: 'center' }}>\n                          <Button\n                            size=\"small\"\n                            variant={spell.prepared ? \"contained\" : \"outlined\"}\n                            onClick={() => handleTogglePrepared(spell)}\n                            sx={{ minWidth: '30px', mr: 1, p: '2px 8px' }}\n                          >\n                            {spell.prepared ? \"P\" : \"—\"}\n                          </Button>\n                          {spell.name}\n                        </Box>\n                      }\n                      secondary={\n                        <React.Fragment>\n                          {spell.castingTime && <span>Casting Time: {spell.castingTime} • </span>}\n                          {spell.range && <span>Range: {spell.range} • </span>}\n                          {spell.duration && <span>Duration: {spell.duration}</span>}\n                          {spell.description && (\n                            <Typography\n                              component=\"span\"\n                              variant=\"body2\"\n                              sx={{ display: 'block', mt: 0.5 }}\n                            >\n                              {spell.description}\n                            </Typography>\n                          )}\n                        </React.Fragment>\n                      }\n                    />\n                  </ListItem>\n                ))}\n              </List>\n            ) : (\n              <Typography variant=\"body2\" color=\"text.secondary\">\n                No {levelInfo.name.toLowerCase()} spells known.\n              </Typography>\n            )}\n          </Box>\n        );\n      })}\n\n      {/* Add/Edit Spell Dialog */}\n      <Dialog open={openSpellDialog} onClose={handleCloseSpellDialog} maxWidth=\"md\" fullWidth>\n        <DialogTitle>{selectedSpell ? 'Edit Spell' : 'Add New Spell'}</DialogTitle>\n        <DialogContent>\n          <Grid container spacing={2} sx={{ mt: 0.5 }}>\n            <Grid item xs={8}>\n              <TextField\n                name=\"name\"\n                label=\"Spell Name\"\n                fullWidth\n                value={newSpell.name}\n                onChange={handleInputChange}\n              />\n            </Grid>\n            <Grid item xs={4}>\n              <FormControl fullWidth>\n                <InputLabel>Level</InputLabel>\n                <Select\n                  name=\"level\"\n                  value={newSpell.level}\n                  label=\"Level\"\n                  onChange={handleInputChange}\n                >\n                  {spellLevels.map(level => (\n                    <MenuItem key={level.level} value={level.level}>\n                      {level.level === 0 ? 'Cantrip' : `Level ${level.level}`}\n                    </MenuItem>\n                  ))}\n                </Select>\n              </FormControl>\n            </Grid>\n            <Grid item xs={4}>\n              <TextField\n                name=\"castingTime\"\n                label=\"Casting Time\"\n                fullWidth\n                value={newSpell.castingTime}\n                onChange={handleInputChange}\n              />\n            </Grid>\n            <Grid item xs={4}>\n              <TextField\n                name=\"range\"\n                label=\"Range\"\n                fullWidth\n                value={newSpell.range}\n                onChange={handleInputChange}\n              />\n            </Grid>\n            <Grid item xs={4}>\n              <TextField\n                name=\"duration\"\n                label=\"Duration\"\n                fullWidth\n                value={newSpell.duration}\n                onChange={handleInputChange}\n              />\n            </Grid>\n            <Grid item xs={12}>\n              <TextField\n                name=\"components\"\n                label=\"Components\"\n                fullWidth\n                value={newSpell.components}\n                onChange={handleInputChange}\n              />\n            </Grid>\n            <Grid item xs={12}>\n              <TextField\n                name=\"description\"\n                label=\"Description\"\n                multiline\n                rows={4}\n                fullWidth\n                value={newSpell.description}\n                onChange={handleInputChange}\n              />\n            </Grid>\n            <Grid item xs={12}>\n              <FormControl fullWidth>\n                <InputLabel>Prepared</InputLabel>\n                <Select\n                  name=\"prepared\"\n                  value={newSpell.prepared}\n                  label=\"Prepared\"\n                  onChange={handleInputChange}\n                >\n                  <MenuItem value={true}>Yes</MenuItem>\n                  <MenuItem value={false}>No</MenuItem>\n                </Select>\n              </FormControl>\n            </Grid>\n          </Grid>\n        </DialogContent>\n        <DialogActions>\n          <Button onClick={handleCloseSpellDialog}>Cancel</Button>\n          <Button onClick={handleSaveSpell} variant=\"contained\">Save</Button>\n        </DialogActions>\n      </Dialog>\n\n      {/* Delete Confirmation Dialog */}\n      <Dialog open={openDeleteDialog} onClose={handleCloseDeleteDialog}>\n        <DialogTitle>Delete Spell</DialogTitle>\n        <DialogContent>\n          <Typography>\n            Are you sure you want to delete \"{spellToDelete?.name}\"? This action cannot be undone.\n          </Typography>\n        </DialogContent>\n        <DialogActions>\n          <Button onClick={handleCloseDeleteDialog}>Cancel</Button>\n          <Button onClick={handleDeleteSpell} color=\"error\" variant=\"contained\">Delete</Button>\n        </DialogActions>\n      </Dialog>\n    </Box>\n  );\n};\n\nexport default SpellsTab;\n\u0005End File\u0006# ryanbourdais/stormbraining-dnd\n// src/Components/CharacterSheet/Inventory.js\nimport React, { useState } from 'react';\nimport { \n  Box, Typography, Button, Grid, Paper, List, ListItem, \n  ListItemText, ListItemSecondaryAction, IconButton, Divider,\n  Dialog, DialogTitle, DialogContent, DialogActions, TextField,\n  FormControl, InputLabel, Select, MenuItem\n} from '@mui/material';\nimport { Add as AddIcon, Edit as EditIcon, Delete as DeleteIcon } from '@mui/icons-material';\n\nconst InventoryTab = ({ character, onUpdateCharacter }) => {\n  const inventory = character.inventory || { items: [], weapons: [], armor: [], gold: 0 };\n  \n  const [openItemDialog, setOpenItemDialog] = useState(false);\n  const [openWeaponDialog, setOpenWeaponDialog] = useState(false);\n  const [openArmorDialog, setOpenArmorDialog] = useState(false);\n  const [editingItem, setEditingItem] = useState(null);\n  const [editingWeapon, setEditingWeapon] = useState(null);\n  const [editingArmor, setEditingArmor] = useState(null);\n  const [deleteConfirmOpen, setDeleteConfirmOpen] = useState(false);\n  const [itemToDelete, setItemToDelete] = useState(null);\n  const [itemTypeToDelete, setItemTypeToDelete] = useState(null);\n  \n  const [newItem, setNewItem] = useState({\n    name: '',\n    quantity: 1,\n    weight: 0,\n    description: '',\n    value: 0\n  });\n  \n  const [newWeapon, setNewWeapon] = useState({\n    name: '',\n    damage: '',\n    damageType: '',\n    properties: '',\n    weight: 0,\n    value: 0\n  });\n  \n  const [newArmor, setNewArmor] = useState({\n    name: '',\n    type: 'light',\n    armorClass: 10,\n    strengthRequirement: 0,\n    stealthDisadvantage: false,\n    weight: 0,\n    value: 0\n  });\n\n  // Generic item dialog handlers\n  const handleOpenItemDialog = (item = null) => {\n    if (item) {\n      setEditingItem(item);\n      setNewItem({\n        name: item.name,\n        quantity: item.quantity || 1,\n        weight: item.weight || 0,\n        description: item.description || '',\n        value: item.value || 0\n      });\n    } else {\n      setEditingItem(null);\n      setNewItem({\n        name: '',\n        quantity: 1,\n        weight: 0,\n        description: '',\n        value: 0\n      });\n    }\n    setOpenItemDialog(true);\n  };\n\n  const handleCloseItemDialog = () => {\n    setOpenItemDialog(false);\n  };\n\n  // Weapon dialog handlers\n  const handleOpenWeaponDialog = (weapon = null) => {\n    if (weapon) {\n      setEditingWeapon(weapon);\n      setNewWeapon({\n        name: weapon.name,\n        damage: weapon.damage || '',\n        damageType: weapon.damageType || '',\n        properties: Array.isArray(weapon.properties) ? weapon.properties.join(', ') : weapon.properties || '',\n        weight: weapon.weight || 0,\n        value: weapon.value || 0\n      });\n    } else {\n      setEditingWeapon(null);\n      setNewWeapon({\n        name: '',\n        damage: '',\n        damageType: '',\n        properties: '',\n        weight: 0,\n        value: 0\n      });\n    }\n    setOpenWeaponDialog(true);\n  };\n\n  const handleCloseWeaponDialog = () => {\n    setOpenWeaponDialog(false);\n  };\n\n  // Armor dialog handlers\n  const handleOpenArmorDialog = (armor = null) => {\n    if (armor) {\n      setEditingArmor(armor);\n      setNewArmor({\n        name: armor.name,\n        type: armor.type || 'light',\n        armorClass: armor.armorClass || 10,\n        strengthRequirement: armor.strengthRequirement || 0,\n        stealthDisadvantage: armor.stealthDisadvantage || false,\n        weight: armor.weight || 0,\n        value: armor.value || 0\n      });\n    } else {\n      setEditingArmor(null);\n      setNewArmor({\n        name: '',\n        type: 'light',\n        armorClass: 10,\n        strengthRequirement: 0,\n        stealthDisadvantage: false,\n        weight: 0,\n        value: 0\n      });\n    }\n    setOpenArmorDialog(true);\n  };\n\n  const handleCloseArmorDialog = () => {\n    setOpenArmorDialog(false);\n  };\n\n  // Input handlers\n  const handleItemInputChange = (e) => {\n    const { name, value } = e.target;\n    setNewItem(prev => ({\n      ...prev,\n      [name]: name === 'quantity' || name === 'weight' || name === 'value' ? \n        parseFloat(value) || 0 : value\n    }));\n  };\n\n  const handleWeaponInputChange = (e) => {\n    const { name, value } = e.target;\n    setNewWeapon(prev => ({\n      ...prev,\n      [name]: name === 'weight' || name === 'value' ? \n        parseFloat(value) || 0 : value\n    }));\n  };\n\n  const handleArmorInputChange = (e) => {\n    const { name, value } = e.target;\n    setNewArmor(prev => ({\n      ...prev,\n      [name]: name === 'armorClass' || name === 'strengthRequirement' || name === 'weight' || name === 'value' ? \n        parseFloat(value) || 0 : \n        name === 'stealthDisadvantage' ? value === 'true' : value\n    }));\n  };\n\n  // Gold handlers\n  const handleGoldChange = (e) => {\n    const goldValue = parseFloat(e.target.value) || 0;\n    const updatedInventory = {\n      ...inventory,\n      gold: goldValue\n    };\n    onUpdateCharacter({ inventory: updatedInventory });\n  };\n\n  // Save handlers\n  const handleSaveItem = () => {\n    const updatedItems = [...(inventory.items || [])];\n    \n    if (editingItem) {\n      // Find and update existing item\n      const index = updatedItems.findIndex(item => item.name === editingItem.name);\n      if (index !== -1) {\n        updatedItems[index] = { ...newItem };\n      }\n    } else {\n      // Add new item\n      updatedItems.push({ ...newItem });\n    }\n    \n    const updatedInventory = {\n      ...inventory,\n      items: updatedItems\n    };\n    \n    onUpdateCharacter({ inventory: updatedInventory });\n    handleCloseItemDialog();\n  };\n\n  const handleSaveWeapon = () => {\n    const updatedWeapons = [...(inventory.weapons || [])];\n    \n    // Process properties string into array if it contains commas\n    const processedWeapon = {\n      ...newWeapon,\n      properties: newWeapon.properties.includes(',') ? \n        newWeapon.properties.split(',').map(prop => prop.trim()) : \n        newWeapon.properties\n    };\n    \n    if (editingWeapon) {\n      // Find and update existing weapon\n      const index = updatedWeapons.findIndex(weapon => weapon.name === editingWeapon.name);\n      if (index !== -1) {\n        updatedWeapons[index] = processedWeapon;\n      }\n    } else {\n      // Add new weapon\n      updatedWeapons.push(processedWeapon);\n    }\n    \n    const updatedInventory = {\n      ...inventory,\n      weapons: updatedWeapons\n    };\n    \n    onUpdateCharacter({ inventory: updatedInventory });\n    handleCloseWeaponDialog();\n  };\n\n  const handleSaveArmor = () => {\n    const updatedArmor = [...(inventory.armor || [])];\n    \n    if (editingArmor) {\n      // Find and update existing armor\n      const index = updatedArmor.findIndex(armor => armor.name === editingArmor.name);\n      if (index !== -1) {\n        updatedArmor[index] = { ...newArmor };\n      }\n    } else {\n      // Add new armor\n      updatedArmor.push({ ...newArmor });\n    }\n    \n    const updatedInventory = {\n      ...inventory,\n      armor: updatedArmor\n    };\n    \n    onUpdateCharacter({ inventory: updatedInventory });\n    handleCloseArmorDialog();\n  };\n\n  // Delete handlers\n  const confirmDelete = (item, type) => {\n    setItemToDelete(item);\n    setItemTypeToDelete(type);\n    setDeleteConfirmOpen(true);\n  };\n\n  const handleDelete = () => {\n    let updatedInventory = { ...inventory };\n    \n    switch (itemTypeToDelete) {\n      case 'item':\n        updatedInventory.items = inventory.items.filter(item => item.name !== itemToDelete.name);\n        break;\n      case 'weapon':\n        updatedInventory.weapons = inventory.weapons.filter(weapon => weapon.name !== itemToDelete.name);\n        break;\n      case 'armor':\n        updatedInventory.armor = inventory.armor.filter(armor => armor.name !== itemToDelete.name);\n        break;\n      default:\n        break;\n    }\n    \n    onUpdateCharacter({ inventory: updatedInventory });\n    setDeleteConfirmOpen(false);\n  };\n\n  return (\n    <Box sx={{ p: 2 }}>\n      <Typography variant=\"h5\" gutterBottom>Inventory</Typography>\n      \n      {/* Currency */}\n      <Paper sx={{ p: 2, mb: 3 }}>\n        <Typography variant=\"h6\" gutterBottom>Currency</Typography>\n        <Grid container spacing={2} alignItems=\"center\">\n          <Grid item xs={4}>\n            <TextField\n              label=\"Gold\"\n              type=\"number\"\n              fullWidth\n              value={inventory.gold || 0}\n              onChange={handleGoldChange}\n              InputProps={{ inputProps: { min: 0, step: 0.1 } }}\n            />\n          </Grid>\n        </Grid>\n      </Paper>\n      \n      {/* Items */}\n      <Paper sx={{ p: 2, mb: 3 }}>\n        <Box sx={{ display: 'flex', justifyContent: 'space-between', mb: 2 }}>\n          <Typography variant=\"h6\">Items</Typography>\n          <Button \n            variant=\"contained\" \n            startIcon={<AddIcon />}\n            onClick={() => handleOpenItemDialog()}\n          >\n            Add Item\n          </Button>\n        </Box>\n        <List>\n          {inventory.items && inventory.items.length > 0 ? (\n            inventory.items.map((item, index) => (\n              <React.Fragment key={index}>\n                {index > 0 && <Divider />}\n                <ListItem>\n                  <ListItemText\n                    primary={`${item.name} (${item.quantity})`}\n                    secondary={\n                      <>\n                        {item.description && <Typography variant=\"body2\">{item.description}</Typography>}\n                        <Typography variant=\"body2\" color=\"text.secondary\">\n                          {item.weight > 0 && `Weight: ${item.weight} lbs • `}\n                          {item.value > 0 && `Value: ${item.value} gold`}\n                        </Typography>\n                      </>\n                    }\n                  />\n                  <ListItemSecondaryAction>\n                    <IconButton edge=\"end\" onClick={() => handleOpenItemDialog(item)}>\n                      <EditIcon />\n                    </IconButton>\n                    <IconButton edge=\"end\" onClick={() => confirmDelete(item, 'item')}>\n                      <DeleteIcon />\n                    </IconButton>\n                  </ListItemSecondaryAction>\n                </ListItem>\n              </React.Fragment>\n            ))\n          ) : (\n            <Typography variant=\"body2\" color=\"text.secondary\" sx={{ py: 2 }}>\n              No items in inventory.\n            </Typography>\n          )}\n        </List>\n      </Paper>\n      \n      {/* Weapons */}\n      <Paper sx={{ p: 2, mb: 3 }}>\n        <Box sx={{ display: 'flex', justifyContent: 'space-between', mb: 2 }}>\n          <Typography variant=\"h6\">Weapons</Typography>\n          <Button \n            variant=\"contained\" \n            startIcon={<AddIcon />}\n            onClick={() => handleOpenWeaponDialog()}\n          >\n            Add Weapon\n          </Button>\n        </Box>\n        <List>\n          {inventory.weapons && inventory.weapons.length > 0 ? (\n            inventory.weapons.map((weapon, index) => (\n              <React.Fragment key={index}>\n                {index > 0 && <Divider />}\n                <ListItem>\n                  <ListItemText\n                    primary={weapon.name}\n                    secondary={\n                      <>\n                        {weapon.damage && weapon.damageType && (\n                          <Typography variant=\"body2\">\n                            Damage: {weapon.damage} {weapon.damageType}\n                          </Typography>\n                        )}\n                        {weapon.properties && (\n                          <Typography variant=\"body2\">\n                            Properties: {Array.isArray(weapon.properties) ? weapon.properties.join(', ') : weapon.properties}\n                          </Typography>\n                        )}\n                        <Typography variant=\"body2\" color=\"text.secondary\">\n                          {weapon.weight > 0 && `Weight: ${weapon.weight} lbs • `}\n                          {weapon.value > 0 && `Value: ${weapon.value} gold`}\n                        </Typography>\n                      </>\n                    }\n                  />\n                  <ListItemSecondaryAction>\n                    <IconButton edge=\"end\" onClick={() => handleOpenWeaponDialog(weapon)}>\n                      <EditIcon />\n                    </IconButton>\n                    <IconButton edge=\"end\" onClick={() => confirmDelete(weapon, 'weapon')}>\n                      <DeleteIcon />\n                    </IconButton>\n                  </ListItemSecondaryAction>\n                </ListItem>\n              </React.Fragment>\n            ))\n          ) : (\n            <Typography variant=\"body2\" color=\"text.secondary\" sx={{ py: 2 }}>\n              No weapons in inventory.\n            </Typography>\n          )}\n        </List>\n      </Paper>\n      \n      {/* Armor */}\n      <Paper sx={{ p: 2 }}>\n        <Box sx={{ display: 'flex', justifyContent: 'space-between', mb: 2 }}>\n          <Typography variant=\"h6\">Armor</Typography>\n          <Button \n            variant=\"contained\" \n            startIcon={<AddIcon />}\n            onClick={() => handleOpenArmorDialog()}\n          >\n            Add Armor\n          </Button>\n        </Box>\n        <List>\n          {inventory.armor && inventory.armor.length > 0 ? (\n            inventory.armor.map((armor, index) => (\n              <React.Fragment key={index}>\n                {index > 0 && <Divider />}\n                <ListItem>\n                  <ListItemText\n                    primary={armor.name}\n                    secondary={\n                      <>\n                        <Typography variant=\"body2\">\n                          Type: {armor.type} • AC: {armor.armorClass}\n                        </Typography>\n                        {armor.strengthRequirement > 0 && (\n                          <Typography variant=\"body2\">\n                            Strength Required: {armor.strengthRequirement}\n                          </Typography>\n                        )}\n                        {armor.stealthDisadvantage && (\n                          <Typography variant=\"body2\">\n                            Disadvantage on Stealth checks\n                          </Typography>\n                        )}\n                        <Typography variant=\"body2\" color=\"text.secondary\">\n                          {armor.weight > 0 && `Weight: ${armor.weight} lbs • `}\n                          {armor.value > 0 && `Value: ${armor.value} gold`}\n                        </Typography>\n                      </>\n                    }\n                  />\n                  <ListItemSecondaryAction>\n                    <IconButton edge=\"end\" onClick={() => handleOpenArmorDialog(armor)}>\n                      <EditIcon />\n                    </IconButton>\n                    <IconButton edge=\"end\" onClick={() => confirmDelete(armor, 'armor')}>\n                      <DeleteIcon />\n                    </IconButton>\n                  </ListItemSecondaryAction>\n                </ListItem>\n              </React.Fragment>\n            ))\n          ) : (\n            <Typography variant=\"body2\" color=\"text.secondary\" sx={{ py: 2 }}>\n              No armor in inventory.\n            </Typography>\n          )}\n        </List>\n      </Paper>\n      \n      {/* Add/Edit Item Dialog */}\n      <Dialog open={openItemDialog} onClose={handleCloseItemDialog} fullWidth maxWidth=\"sm\">\n        <DialogTitle>{editingItem ? 'Edit Item' : 'Add Item'}</DialogTitle>\n        <DialogContent>\n          <Grid container spacing={2} sx={{ mt: 0.5 }}>\n            <Grid item xs={8}>\n              <TextField\n                name=\"name\"\n                label=\"Item Name\"\n                fullWidth\n                value={newItem.name}\n                onChange={handleItemInputChange}\n                required\n              />\n            </Grid>\n            <Grid item xs={4}>\n              <TextField\n                name=\"quantity\"\n                label=\"Quantity\"\n                type=\"number\"\n                fullWidth\n                value={newItem.quantity}\n                onChange={handleItemInputChange}\n                InputProps={{ inputProps: { min: 1 } }}\n              />\n            </Grid>\n            <Grid item xs={6}>\n              <TextField\n                name=\"weight\"\n                label=\"Weight (lbs)\"\n                type=\"number\"\n                fullWidth\n                value={newItem.weight}\n                onChange={handleItemInputChange}\n                InputProps={{ inputProps: { min: 0, step: 0.1 } }}\n              />\n            </Grid>\n            <Grid item xs={6}>\n              <TextField\n                name=\"value\"\n                label=\"Value (gold)\"\n                type=\"number\"\n                fullWidth\n                value={newItem.value}\n                onChange={handleItemInputChange}\n                InputProps={{ inputProps: { min: 0, step: 0.1 } }}\n              />\n            </Grid>\n            <Grid item xs={12}>\n              <TextField\n                name=\"description\"\n                label=\"Description\"\n                multiline\n                rows={3}\n                fullWidth\n                value={newItem.description}\n                onChange={handleItemInputChange}\n              />\n            </Grid>\n          </Grid>\n        </DialogContent>\n        <DialogActions>\n          <Button onClick={handleCloseItemDialog}>Cancel</Button>\n          <Button onClick={handleSaveItem} variant=\"contained\" disabled={!newItem.name}>Save</Button>\n        </DialogActions>\n      </Dialog>\n      \n      {/* Add/Edit Weapon Dialog */}\n      <Dialog open={openWeaponDialog} onClose={handleCloseWeaponDialog} fullWidth maxWidth=\"sm\">\n        <DialogTitle>{editingWeapon ? 'Edit Weapon' : 'Add Weapon'}</DialogTitle>\n        <DialogContent>\n          <Grid container spacing={2} sx={{ mt: 0.5 }}>\n            <Grid item xs={12}>\n              <TextField\n                name=\"name\"\n                label=\"Weapon Name\"\n                fullWidth\n                value={newWeapon.name}\n                onChange={handleWeaponInputChange}\n                required\n              />\n            </Grid>\n            <Grid item xs={6}>\n              <TextField\n                name=\"damage\"\n                label=\"Damage Dice\"\n                fullWidth\n                value={newWeapon.damage}\n                onChange={handleWeaponInputChange}\n                placeholder=\"e.g., 1d6\"\n              />\n            </Grid>\n            <Grid item xs={6}>\n              <TextField\n                name=\"damageType\"\n                label=\"Damage Type\"\n                fullWidth\n                value={newWeapon.damageType}\n                onChange={handleWeaponInputChange}\n                placeholder=\"e.g., piercing\"\n              />\n            </Grid>\n            <Grid item xs={12}>\n              <TextField\n                name=\"properties\"\n                label=\"Properties\"\n                fullWidth\n                value={newWeapon.properties}\n                onChange={handleWeaponInputChange}\n                placeholder=\"e.g., finesse, light, thrown\"\n              />\n            </Grid>\n            <Grid item xs={6}>\n              <TextField\n                name=\"weight\"\n                label=\"Weight (lbs)\"\n                type=\"number\"\n                fullWidth\n                value={newWeapon.weight}\n                onChange={handleWeaponInputChange}\n                InputProps={{ inputProps: { min: 0, step: 0.1 } }}\n              />\n            </Grid>\n            <Grid item xs={6}>\n              <TextField\n                name=\"value\"\n                label=\"Value (gold)\"\n                type=\"number\"\n                fullWidth\n                value={newWeapon.value}\n                onChange={handleWeaponInputChange}\n                InputProps={{ inputProps: { min: 0, step: 0.1 } }}\n              />\n            </Grid>\n          </Grid>\n        </DialogContent>\n        <DialogActions>\n          <Button onClick={handleCloseWeaponDialog}>Cancel</Button>\n          <Button onClick={handleSaveWeapon} variant=\"contained\" disabled={!newWeapon.name}>Save</Button>\n        </DialogActions>\n      </Dialog>\n      \n      {/* Add/Edit Armor Dialog */}\n      <Dialog open={openArmorDialog} onClose={handleCloseArmorDialog} fullWidth maxWidth=\"sm\">\n        <DialogTitle>{editingArmor ? 'Edit Armor' : 'Add Armor'}</DialogTitle>\n        <DialogContent>\n          <Grid container spacing={2} sx={{ mt: 0.5 }}>\n            <Grid item xs={12}>\n              <TextField\n                name=\"name\"\n                label=\"Armor Name\"\n                fullWidth\n                value={newArmor.name}\n                onChange={handleArmorInputChange}\n                required\n              />\n            </Grid>\n            <Grid item xs={6}>\n              <FormControl fullWidth>\n                <InputLabel>Armor Type</InputLabel>\n                <Select\n                  name=\"type\"\n                  value={newArmor.type}\n                  label=\"Armor Type\"\n                  onChange={handleArmorInputChange}\n                >\n                  <MenuItem value=\"light\">Light</MenuItem>\n                  <MenuItem value=\"medium\">Medium</MenuItem>\n                  <MenuItem value=\"heavy\">Heavy</MenuItem>\n                  <MenuItem value=\"shield\">Shield</MenuItem>\n                </Select>\n              </FormControl>\n            </Grid>\n            <Grid item xs={6}>\n              <TextField\n                name=\"armorClass\"\n                label=\"Armor Class\"\n                type=\"number\"\n                fullWidth\n                value={newArmor.armorClass}\n                onChange={handleArmorInputChange}\n                InputProps={{ inputProps: { min: 0 } }}\n              />\n            </Grid>\n            <Grid item xs={6}>\n              <TextField\n                name=\"strengthRequirement\"\n                label=\"Strength Requirement\"\n                type=\"number\"\n                fullWidth\n                value={newArmor.strengthRequirement}\n                onChange={handleArmorInputChange}\n                InputProps={{ inputProps: { min: 0 } }}\n              />\n            </Grid>\n            <Grid item xs={6}>\n              <FormControl fullWidth>\n                <InputLabel>Stealth Disadvantage</InputLabel>\n                <Select\n                  name=\"stealthDisadvantage\"\n                  value={newArmor.stealthDisadvantage.toString()}\n                  label=\"Stealth Disadvantage\"\n                  onChange={handleArmorInputChange}\n                >\n                  <MenuItem value=\"true\">Yes</MenuItem>\n                  <MenuItem value=\"false\">No</MenuItem>\n                </Select>\n              </FormControl>\n            </Grid>\n            <Grid item xs={6}>\n              <TextField\n                name=\"weight\"\n                label=\"Weight (lbs)\"\n                type=\"number\"\n                fullWidth\n                value={newArmor.weight}\n                onChange={handleArmorInputChange}\n                InputProps={{ inputProps: { min: 0, step: 0.1 } }}\n              />\n            </Grid>\n            <Grid item xs={6}>\n              <TextField\n                name=\"value\"\n                label=\"Value (gold)\"\n                type=\"number\"\n                fullWidth\n                value={newArmor.value}\n                onChange={handleArmorInputChange}\n                InputProps={{ inputProps: { min: 0, step: 0.1 } }}\n              />\n            </Grid>\n          </Grid>\n        </DialogContent>\n        <DialogActions>\n          <Button onClick={handleCloseArmorDialog}>Cancel</Button>\n          <Button onClick={handleSaveArmor} variant=\"contained\" disabled={!newArmor.name}>Save</Button>\n        </DialogActions>\n      </Dialog>\n      \n      {/* Delete Confirmation Dialog */}\n      <Dialog open={deleteConfirmOpen} onClose={() => setDeleteConfirmOpen(false)}>\n        <DialogTitle>Confirm Delete</DialogTitle>\n        <DialogContent>\n          <Typography>\n            Are you sure you want to delete {itemToDelete?.name}? This action cannot be undone.\n          </Typography>\n        </DialogContent>\n        <DialogActions>\n          <Button onClick={() => setDeleteConfirmOpen(false)}>Cancel</Button>\n          <Button onClick={handleDelete} color=\"error\" variant=\"contained\">Delete</Button>\n        </DialogActions>\n      </Dialog>\n    </Box>\n  );\n};\n\nexport default InventoryTab;\n\u0005End File\u0006# ryanbourdais/stormbraining-dnd\n// src/Components/CharacterSheet/Actions.js\nimport React, { useState } from 'react';\nimport { \n  Box, Typography, Button, Grid, Paper, List, ListItem, \n  ListItemText, ListItemSecondaryAction, IconButton, Divider,\n  Dialog, DialogTitle, DialogContent, DialogActions, TextField,\n  FormControl, InputLabel, Select, MenuItem\n} from '@mui/material';\nimport { Add as AddIcon, Edit as EditIcon, Delete as DeleteIcon } from '@mui/icons-material';\n\nconst ActionsTab = ({ character, onUpdateCharacter }) => {\n  const [openActionDialog, setOpenActionDialog] = useState(false);\n  const [selectedAction, setSelectedAction] = useState(null);\n  const [openDeleteDialog, setOpenDeleteDialog] = useState(false);\n  const [actionToDelete, setActionToDelete] = useState(null);\n  \n  const [newAction, setNewAction] = useState({\n    name: '',\n    description: '',\n    attack_bonus: null,\n    damage_dice: '',\n    damage_type: '',\n    ability: ''\n  });\n\n  const actions = character.actions || [];\n  \n  // Dialog handlers\n  const handleOpenActionDialog = (action = null) => {\n    if (action) {\n      setSelectedAction(action);\n      setNewAction({\n        name: action.name,\n        description: action.description || '',\n        attack_bonus: action.attack_bonus || null,\n        damage_dice: action.damage_dice || '',\n        damage_type: action.damage_type || '',\n        ability: action.ability || ''\n      });\n    } else {\n      setSelectedAction(null);\n      setNewAction({\n        name: '',\n        description: '',\n        attack_bonus: null,\n        damage_dice: '',\n        damage_type: '',\n        ability: ''\n      });\n    }\n    setOpenActionDialog(true);\n  };\n\n  const handleCloseActionDialog = () => {\n    setOpenActionDialog(false);\n  };\n\n  const handleOpenDeleteDialog = (action) => {\n    setActionToDelete(action);\n    setOpenDeleteDialog(true);\n  };\n\n  const handleCloseDeleteDialog = () => {\n    setOpenDeleteDialog(false);\n    setActionToDelete(null);\n  };\n\n  // Input handlers\n  const handleInputChange = (e) => {\n    const { name, value } = e.target;\n    \n    // For attack_bonus, convert to number if it's a valid number, or null otherwise\n    if (name === 'attack_bonus') {\n      const numValue = value === '' ? null : Number(value);\n      setNewAction(prev => ({\n        ...prev,\n        [name]: Number.isNaN(numValue) ? null : numValue\n      }));\n    } else {\n      setNewAction(prev => ({\n        ...prev,\n        [name]: value\n      }));\n    }\n  };\n\n  // Save/Delete handlers\n  const handleSaveAction = () => {\n    const updatedActions = [...actions];\n    \n    if (selectedAction) {\n      // Find and update existing action\n      const index = updatedActions.findIndex(action => action.name === selectedAction.name);\n      if (index !== -1) {\n        updatedActions[index] = { ...newAction };\n      }\n    } else {\n      // Add new action\n      updatedActions.push({ ...newAction });\n    }\n    \n    onUpdateCharacter({\n      actions: updatedActions\n    });\n    \n    handleCloseActionDialog();\n  };\n\n  const handleDeleteAction = () => {\n    if (!actionToDelete) return;\n    \n    const updatedActions = actions.filter(action => action.name !== actionToDelete.name);\n    \n    onUpdateCharacter({\n      actions: updatedActions\n    });\n    \n    handleCloseDeleteDialog();\n  };\n\n  // Helper for displaying attack bonus\n  const formatAttackBonus = (bonus) => {\n    if (bonus === null || bonus === undefined) return '—';\n    return bonus >= 0 ? `+${bonus}` : bonus;\n  };\n\n  return (\n    <Box sx={{ p: 2 }}>\n      <Typography variant=\"h5\" gutterBottom>Actions & Abilities</Typography>\n      \n      <Box sx={{ display: 'flex', justifyContent: 'space-between', mb: 2 }}>\n        <Typography variant=\"h6\">Actions</Typography>\n        <Button \n          variant=\"contained\" \n          startIcon={<AddIcon />}\n          onClick={() => handleOpenActionDialog()}\n        >\n          Add Action\n        </Button>\n      </Box>\n      \n      <Paper sx={{ p: 2 }}>\n        {actions.length > 0 ? (\n          <List>\n            {actions.map((action, index) => (\n              <React.Fragment key={index}>\n                {index > 0 && <Divider />}\n                <ListItem alignItems=\"flex-start\">\n                  <ListItemText\n                    primary={\n                      <Typography variant=\"subtitle1\" component=\"span\" fontWeight=\"bold\">\n                        {action.name}\n                      </Typography>\n                    }\n                    secondary={\n                      <Box sx={{ mt: 1 }}>\n                        {(action.attack_bonus !== null || action.damage_dice) && (\n                          <Typography variant=\"body2\" component=\"div\" sx={{ mb: 1 }}>\n                            {action.attack_bonus !== null && (\n                              <span>Attack: {formatAttackBonus(action.attack_bonus)} to hit</span>\n                            )}\n                            {action.attack_bonus !== null && action.damage_dice && (\n                              <span> • </span>\n                            )}\n                            {action.damage_dice && (\n                              <span>\n                                Damage: {action.damage_dice}\n                                {action.damage_type && ` ${action.damage_type}`}\n                              </span>\n                            )}\n                          </Typography>\n                        )}\n                        <Typography variant=\"body2\" color=\"text.secondary\">\n                          {action.description || 'No description provided.'}\n                        </Typography>\n                      </Box>\n                    }\n                  />\n                  <ListItemSecondaryAction>\n                    <IconButton edge=\"end\" onClick={() => handleOpenActionDialog(action)}>\n                      <EditIcon />\n                    </IconButton>\n                    <IconButton edge=\"end\" onClick={() => handleOpenDeleteDialog(action)}>\n                      <DeleteIcon />\n                    </IconButton>\n                  </ListItemSecondaryAction>\n                </ListItem>\n              </React.Fragment>\n            ))}\n          </List>\n        ) : (\n          <Typography variant=\"body2\" color=\"text.secondary\" sx={{ py: 2, textAlign: 'center' }}>\n            No actions have been added yet.\n          </Typography>\n        )}\n      </Paper>\n      \n      {/* Add/Edit Action Dialog */}\n      <Dialog open={openActionDialog} onClose={handleCloseActionDialog} fullWidth maxWidth=\"md\">\n        <DialogTitle>{selectedAction ? 'Edit Action' : 'Add New Action'}</DialogTitle>\n        <DialogContent>\n          <Grid container spacing={2} sx={{ mt: 0.5 }}>\n            <Grid item xs={12}>\n              <TextField\n                name=\"name\"\n                label=\"Action Name\"\n                fullWidth\n                value={newAction.name}\n                onChange={handleInputChange}\n                required\n              />\n            </Grid>\n            <Grid item xs={12}>\n              <TextField\n                name=\"description\"\n                label=\"Description\"\n                multiline\n                rows={3}\n                fullWidth\n                value={newAction.description}\n                onChange={handleInputChange}\n              />\n            </Grid>\n            <Grid item xs={4}>\n              <TextField\n                name=\"attack_bonus\"\n                label=\"Attack Bonus\"\n                type=\"number\"\n                fullWidth\n                value={newAction.attack_bonus === null ? '' : newAction.attack_bonus}\n                onChange={handleInputChange}\n                placeholder=\"e.g., 5\"\n              />\n            </Grid>\n            <Grid item xs={4}>\n              <TextField\n                name=\"damage_dice\"\n                label=\"Damage Dice\"\n                fullWidth\n                value={newAction.damage_dice}\n                onChange={handleInputChange}\n                placeholder=\"e.g., 1d8+3\"\n              />\n            </Grid>\n            <Grid item xs={4}>\n              <TextField\n                name=\"damage_type\"\n                label=\"Damage Type\"\n                fullWidth\n                value={newAction.damage_type}\n                onChange={handleInputChange}\n                placeholder=\"e.g., slashing\"\n              />\n            </Grid>\n            <Grid item xs={12}>\n              <FormControl fullWidth>\n                <InputLabel>Ability</InputLabel>\n                <Select\n                  name=\"ability\"\n                  value={newAction.ability}\n                  label=\"Ability\"\n                  onChange={handleInputChange}\n                >\n                  <MenuItem value=\"\">None</MenuItem>\n                  <MenuItem value=\"strength\">Strength</MenuItem>\n                  <MenuItem value=\"dexterity\">Dexterity</MenuItem>\n                  <MenuItem value=\"constitution\">Constitution</MenuItem>\n                  <MenuItem value=\"intelligence\">Intelligence</MenuItem>\n                  <MenuItem value=\"wisdom\">Wisdom</MenuItem>\n                  <MenuItem value=\"charisma\">Charisma</MenuItem>\n                </Select>\n              </FormControl>\n            </Grid>\n          </Grid>\n        </DialogContent>\n        <DialogActions>\n          <Button onClick={handleCloseActionDialog}>Cancel</Button>\n          <Button \n            onClick={handleSaveAction} \n            variant=\"contained\"\n            disabled={!newAction.name}\n          >\n            Save\n          </Button>\n        </DialogActions>\n      </Dialog>\n      \n      {/* Delete Confirmation Dialog */}\n      <Dialog open={openDeleteDialog} onClose={handleCloseDeleteDialog}>\n        <DialogTitle>Delete Action</DialogTitle>\n        <DialogContent>\n          <Typography>\n            Are you sure you want to delete \"{actionToDelete?.name}\"? This action cannot be undone.\n          </Typography>\n        </DialogContent>\n        <DialogActions>\n          <Button onClick={handleCloseDeleteDialog}>Cancel</Button>\n          <Button onClick={handleDeleteAction} color=\"error\" variant=\"contained\">Delete</Button>\n        </DialogActions>\n      </Dialog>\n    </Box>\n  );\n};\n\nexport default ActionsTab;\n\u0005End File\u0006import React, { useState } from 'react';\nimport { useNavigate } from 'react-router-dom';\nimport {\n  Box, Typography, TextField, Button, Grid, Paper, MenuItem, \n  FormControl, InputLabel, Select, FormHelperText, Stepper, \n  Step, StepLabel, Divider, Chip, OutlinedInput, ListItemText, \n  Checkbox, FormLabel, FormGroup, FormControlLabel\n} from '@mui/material';\n\n// Helper function to calculate ability score modifier\nconst getModifier = (score) => {\n  return Math.floor((score - 10) / 2);\n};\n\n// Classes with their primary abilities\nconst classes = [\n  { name: \"Barbarian\", primaryAbility: \"Strength\" },\n  { name: \"Bard\", primaryAbility: \"Charisma\" },\n  { name: \"Cleric\", primaryAbility: \"Wisdom\" },\n  { name: \"Druid\", primaryAbility: \"Wisdom\" },\n  { name: \"Fighter\", primaryAbility: \"Strength or Dexterity\" },\n  { name: \"Monk\", primaryAbility: \"Dexterity & Wisdom\" },\n  { name: \"Paladin\", primaryAbility: \"Strength & Charisma\" },\n  { name: \"Ranger\", primaryAbility: \"Dexterity & Wisdom\" },\n  { name: \"Rogue\", primaryAbility: \"Dexterity\" },\n  { name: \"Sorcerer\", primaryAbility: \"Charisma\" },\n  { name: \"Warlock\", primaryAbility: \"Charisma\" },\n  { name: \"Wizard\", primaryAbility: \"Intelligence\" }\n];\n\n// Races with their ability score bonuses\nconst races = [\n  { name: \"Human\", abilityBonuses: \"+1 to all abilities\" },\n  { name: \"Dwarf\", abilityBonuses: \"+2 Constitution\" },\n  { name: \"Elf\", abilityBonuses: \"+2 Dexterity\" },\n  { name: \"Halfling\", abilityBonuses: \"+2 Dexterity\" },\n  { name: \"Dragonborn\", abilityBonuses: \"+2 Strength, +1 Charisma\" },\n  { name: \"Gnome\", abilityBonuses: \"+2 Intelligence\" },\n  { name: \"Half-Elf\", abilityBonuses: \"+2 Charisma, +1 to two others\" },\n  { name: \"Half-Orc\", abilityBonuses: \"+2 Strength, +1 Constitution\" },\n  { name: \"Tiefling\", abilityBonuses: \"+2 Charisma, +1 Intelligence\" }\n];\n\n// Backgrounds\nconst backgrounds = [\n  \"Acolyte\", \"Charlatan\", \"Criminal\", \"Entertainer\", \"Folk Hero\",\n  \"Guild Artisan\", \"Hermit\", \"Noble\", \"Outlander\", \"Sage\",\n  \"Sailor\", \"Soldier\", \"Urchin\"\n];\n\n// Alignments\nconst alignments = [\n  \"Lawful Good\", \"Neutral Good\", \"Chaotic Good\",\n  \"Lawful Neutral\", \"True Neutral\", \"Chaotic Neutral\",\n  \"Lawful Evil\", \"Neutral Evil\", \"Chaotic Evil\"\n];\n\n// Skills by ability\nconst skillsByAbility = {\n  strength: [\"Athletics\"],\n  dexterity: [\"Acrobatics\", \"Sleight of Hand\", \"Stealth\"],\n  intelligence: [\"Arcana\", \"History\", \"Investigation\", \"Nature\", \"Religion\"],\n  wisdom: [\"Animal Handling\", \"Insight\", \"Medicine\", \"Perception\", \"Survival\"],\n  charisma: [\"Deception\", \"Intimidation\", \"Performance\", \"Persuasion\"]\n};\n\n// All skills flattened to a single array and converted to camelCase\nconst allSkills = Object.values(skillsByAbility).flat().map(skill => {\n  return skill.toLowerCase().replace(/\\s+/g, '');\n});\n\n// Class specific skill choices\nconst classSkillChoices = {\n  \"Barbarian\": { count: 2, skills: [\"animalHandling\", \"athletics\", \"intimidation\", \"nature\", \"perception\", \"survival\"] },\n  \"Bard\": { count: 3, skills: allSkills }, // Bards can choose any three skills\n  \"Cleric\": { count: 2, skills: [\"history\", \"insight\", \"medicine\", \"persuasion\", \"religion\"] },\n  \"Druid\": { count: 2, skills: [\"arcana\", \"animalHandling\", \"insight\", \"medicine\", \"nature\", \"perception\", \"religion\", \"survival\"] },\n  \"Fighter\": { count: 2, skills: [\"acrobatics\", \"animalHandling\", \"athletics\", \"history\", \"insight\", \"intimidation\", \"perception\", \"survival\"] },\n  \"Monk\": { count: 2, skills: [\"acrobatics\", \"athletics\", \"history\", \"insight\", \"religion\", \"stealth\"] },\n  \"Paladin\": { count: 2, skills: [\"athletics\", \"insight\", \"intimidation\", \"medicine\", \"persuasion\", \"religion\"] },\n  \"Ranger\": { count: 3, skills: [\"animalHandling\", \"athletics\", \"insight\", \"investigation\", \"nature\", \"perception\", \"stealth\", \"survival\"] },\n  \"Rogue\": { count: 4, skills: [\"acrobatics\", \"athletics\", \"deception\", \"insight\", \"intimidation\", \"investigation\", \"perception\", \"performance\", \"persuasion\", \"sleightOfHand\", \"stealth\"] },\n  \"Sorcerer\": { count: 2, skills: [\"arcana\", \"deception\", \"insight\", \"intimidation\", \"persuasion\", \"religion\"] },\n  \"Warlock\": { count: 2, skills: [\"arcana\", \"deception\", \"history\", \"intimidation\", \"investigation\", \"nature\", \"religion\"] },\n  \"Wizard\": { count: 2, skills: [\"arcana\", \"history\", \"insight\", \"investigation\", \"medicine\", \"religion\"] }\n};\n\nconst initialCharacterState = {\n  name: '',\n  race: '',\n  class: '',\n  background: '',\n  alignment: '',\n  strength: 8,\n  dexterity: 8,\n  constitution: 8,\n  intelligence: 8,\n  wisdom: 8,\n  charisma: 8,\n  personalityTraits: '',\n  ideals: '',\n  bonds: '',\n  flaws: '',\n  skills: []\n};\n\nconst CharacterCreation = () => {\n  const [character, setCharacter] = useState(initialCharacterState);\n  const [activeStep, setActiveStep] = useState(0);\n  const [errors, setErrors] = useState({});\n  const [pointsRemaining, setPointsRemaining] = useState(27);\n  const navigate = useNavigate();\n\n  // Ability score costs table\n  const pointCosts = {\n    8: 0,\n    9: 1,\n    10: 2,\n    11: 3,\n    12: 4,\n    13: 5,\n    14: 7,\n    15: 9\n  };\n\n  // Handle input changes\n  const handleInputChange = (e) => {\n    const { name, value } = e.target;\n    setCharacter(prev => ({\n      ...prev,\n      [name]: value\n    }));\n\n    // Clear error for this field if any\n    if (errors[name]) {\n      setErrors(prev => {\n        const newErrors = { ...prev };\n        delete newErrors[name];\n        return newErrors;\n      });\n    }\n\n    // If class changes, reset skills\n    if (name === 'class') {\n      setCharacter(prev => ({\n        ...prev,\n        skills: []\n      }));\n    }\n  };\n\n  // Handle ability score changes\n  const handleAbilityChange = (ability, value) => {\n    const newValue = parseInt(value);\n    \n    // Check if value is within allowed range\n    if (newValue < 8 || newValue > 15) return;\n    \n    // Calculate point cost difference\n    const oldCost = pointCosts[character[ability]];\n    const newCost = pointCosts[newValue];\n    const costDifference = newCost - oldCost;\n    \n    // Check if we have enough points\n    if (pointsRemaining - costDifference < 0) return;\n    \n    // Update character and remaining points\n    setCharacter(prev => ({\n      ...prev,\n      [ability]: newValue\n    }));\n    \n    setPointsRemaining(prev => prev - costDifference);\n  };\n\n  // Handle skill selection\n  const handleSkillChange = (event) => {\n    const { value } = event.target;\n    setCharacter(prev => ({\n      ...prev,\n      skills: value\n    }));\n  };\n\n  // Get skill choices based on class\n  const getSkillChoicesForClass = () => {\n    if (!character.class) return { count: 0, skills: [] };\n    return classSkillChoices[character.class] || { count: 0, skills: [] };\n  };\n\n  // Validate current step\n  const validateStep = () => {\n    const newErrors = {};\n    \n    // Basic Info validation\n    if (activeStep === 0) {\n      if (!character.name) newErrors.name = \"Name is required\";\n      if (!character.race) newErrors.race = \"Race is required\";\n      if (!character.class) newErrors.class = \"Class is required\";\n    }\n    // Ability Scores validation is handled by the input constraints\n    // Background and Personality validation\n    else if (activeStep === 2) {\n      if (!character.background) newErrors.background = \"Background is required\";\n      if (!character.alignment) newErrors.alignment = \"Alignment is required\";\n    }\n    // Skills validation\n    else if (activeStep === 3) {\n      const { count, skills } = getSkillChoicesForClass();\n      if (character.skills.length !== count) {\n        newErrors.skills = `Please select exactly ${count} skills`;\n      }\n    }\n    \n    setErrors(newErrors);\n    return Object.keys(newErrors).length === 0;\n  };\n\n  // Navigate to next step\n  const handleNext = () => {\n    if (validateStep()) {\n      setActiveStep(prevStep => prevStep + 1);\n    }\n  };\n\n  // Navigate to previous step\n  const handleBack = () => {\n    setActiveStep(prevStep => prevStep - 1);\n  };\n\n  // Submit character creation\n  const handleSubmit = async () => {\n    if (!validateStep()) return;\n    \n    try {\n      const response = await fetch('/api/character', {\n        method: 'POST',\n        headers: {\n          'Content-Type': 'application/json',\n        },\n        body: JSON.stringify(character),\n      });\n      \n      if (!response.ok) {\n        throw new Error('Network response was not ok');\n      }\n      \n      const data = await response.json();\n      \n      // Redirect to character sheet\n      navigate(`/character/${data.characterId}`);\n    } catch (error) {\n      console.error('Error creating character:', error);\n      setErrors({ submit: 'Failed to create character. Please try again.' });\n    }\n  };\n\n  // Reset all fields\n  const handleReset = () => {\n    setCharacter(initialCharacterState);\n    setPointsRemaining(27);\n    setErrors({});\n    setActiveStep(0);\n  };\n\n  // Convert camelCase to Title Case with spaces\n  const formatSkillName = (skill) => {\n    return skill\n      .replace(/([A-Z])/g, ' $1')\n      .replace(/^./, str => str.toUpperCase());\n  };\n\n  // Steps for the stepper\n  const steps = ['Basic Info', 'Abilities', 'Background', 'Skills', 'Review'];\n\n  // Content for each step\n  const getStepContent = (step) => {\n    switch (step) {\n      case 0: // Basic Info\n        return (\n          <Grid container spacing={3}>\n            <Grid item xs={12}>\n              <TextField\n                name=\"name\"\n                label=\"Character Name\"\n                fullWidth\n                value={character.name}\n                onChange={handleInputChange}\n                error={!!errors.name}\n                helperText={errors.name}\n                required\n              />\n            </Grid>\n            <Grid item xs={12} md={6}>\n              <FormControl fullWidth error={!!errors.race} required>\n                <InputLabel>Race</InputLabel>\n                <Select\n                  name=\"race\"\n                  value={character.race}\n                  onChange={handleInputChange}\n                  label=\"Race\"\n                >\n                  {races.map((race) => (\n                    <MenuItem key={race.name} value={race.name}>\n                      <Box>\n                        <Typography variant=\"subtitle1\">{race.name}</Typography>\n                        <Typography variant=\"caption\" color=\"text.secondary\">\n                          {race.abilityBonuses}\n                        </Typography>\n                      </Box>\n                    </MenuItem>\n                  ))}\n                </Select>\n                {errors.race && <FormHelperText>{errors.race}</FormHelperText>}\n              </FormControl>\n            </Grid>\n            <Grid item xs={12} md={6}>\n              <FormControl fullWidth error={!!errors.class} required>\n                <InputLabel>Class</InputLabel>\n                <Select\n                  name=\"class\"\n                  value={character.class}\n                  onChange={handleInputChange}\n                  label=\"Class\"\n                >\n                  {classes.map((cls) => (\n                    <MenuItem key={cls.name} value={cls.name}>\n                      <Box>\n                        <Typography variant=\"subtitle1\">{cls.name}</Typography>\n                        <Typography variant=\"caption\" color=\"text.secondary\">\n                          Primary: {cls.primaryAbility}\n                        </Typography>\n                      </Box>\n                    </MenuItem>\n                  ))}\n                </Select>\n                {errors.class && <FormHelperText>{errors.class}</FormHelperText>}\n              </FormControl>\n            </Grid>\n          </Grid>\n        );\n      \n      case 1: // Ability Scores\n        return (\n          <Box>\n            <Typography variant=\"h6\" gutterBottom>\n              Ability Scores\n              <Typography component=\"span\" color=\"primary\" sx={{ ml: 2 }}>\n                Points Remaining: {pointsRemaining}\n              </Typography>\n            </Typography>\n            <Typography variant=\"body2\" color=\"text.secondary\" paragraph>\n              Distribute points to your ability scores. Higher scores cost more points.\n              Score costs: 8 (0), 9 (1), 10 (2), 11 (3), 12 (4), 13 (5), 14 (7), 15 (9).\n            </Typography>\n            \n            <Grid container spacing={3}>\n              {[\"strength\", \"dexterity\", \"constitution\", \"intelligence\", \"wisdom\", \"charisma\"].map((ability) => (\n                <Grid item xs={6} sm={4} key={ability}>\n                  <Paper sx={{ p: 2, textAlign: 'center' }}>\n                    <Typography variant=\"subtitle1\" sx={{ textTransform: 'capitalize' }}>\n                      {ability}\n                    </Typography>\n                    <Box sx={{ display: 'flex', justifyContent: 'center', alignItems: 'center', my: 1 }}>\n                      <Button \n                        size=\"small\" \n                        variant=\"outlined\"\n                        onClick={() => handleAbilityChange(ability, character[ability] - 1)}\n                        disabled={character[ability] <= 8}\n                      >\n                        -\n                      </Button>\n                      <Typography variant=\"h5\" sx={{ mx: 2 }}>\n                        {character[ability]}\n                      </Typography>\n                      <Button \n                        size=\"small\" \n                        variant=\"outlined\"\n                        onClick={() => handleAbilityChange(ability, character[ability] + 1)}\n                        disabled={character[ability] >= 15 || pointsRemaining < (pointCosts[character[ability] + 1] - pointCosts[character[ability]])}\n                      >\n                        +\n                      </Button>\n                    </Box>\n                    <Typography \n                      variant=\"body2\" \n                      color={getModifier(character[ability]) >= 0 ? \"success.main\" : \"error.main\"}\n                    >\n                      Modifier: {getModifier(character[ability]) >= 0 ? \"+\" : \"\"}{getModifier(character[ability])}\n                    </Typography>\n                  </Paper>\n                </Grid>\n              ))}\n            </Grid>\n          </Box>\n        );\n      \n      case 2: // Background and Personality\n        return (\n          <Grid container spacing={3}>\n            <Grid item xs={12} md={6}>\n              <FormControl fullWidth error={!!errors.background} required>\n                <InputLabel>Background</InputLabel>\n                <Select\n                  name=\"background\"\n                  value={character.background}\n                  onChange={handleInputChange}\n                  label=\"Background\"\n                >\n                  {backgrounds.map((bg) => (\n                    <MenuItem key={bg} value={bg}>{bg}</MenuItem>\n                  ))}\n                </Select>\n                {errors.background && <FormHelperText>{errors.background}</FormHelperText>}\n              </FormControl>\n            </Grid>\n            <Grid item xs={12} md={6}>\n              <FormControl fullWidth error={!!errors.alignment} required>\n                <InputLabel>Alignment</InputLabel>\n                <Select\n                  name=\"alignment\"\n                  value={character.alignment}\n                  onChange={handleInputChange}\n                  label=\"Alignment\"\n                >\n                  {alignments.map((align) => (\n                    <MenuItem key={align} value={align}>{align}</MenuItem>\n                  ))}\n                </Select>\n                {errors.alignment && <FormHelperText>{errors.alignment}</FormHelperText>}\n              </FormControl>\n            </Grid>\n            <Grid item xs={12}>\n              <TextField\n                name=\"personalityTraits\"\n                label=\"Personality Traits\"\n                multiline\n                rows={2}\n                fullWidth\n                value={character.personalityTraits}\n                onChange={handleInputChange}\n                placeholder=\"How does your character behave? What quirks do they have?\"\n              />\n            </Grid>\n            <Grid item xs={12}>\n              <TextField\n                name=\"ideals\"\n                label=\"Ideals\"\n                multiline\n                rows={2}\n                fullWidth\n                value={character.ideals}\n                onChange={handleInputChange}\n                placeholder=\"What principles does your character live by?\"\n              />\n            </Grid>\n            <Grid item xs={12}>\n              <TextField\n                name=\"bonds\"\n                label=\"Bonds\"\n                multiline\n                rows={2}\n                fullWidth\n                value={character.bonds}\n                onChange={handleInputChange}\n                placeholder=\"What connections tie your character to people, places, or events?\"\n              />\n            </Grid>\n            <Grid item xs={12}>\n              <TextField\n                name=\"flaws\"\n                label=\"Flaws\"\n                multiline\n                rows={2}\n                fullWidth\n                value={character.flaws}\n                onChange={handleInputChange}\n                placeholder=\"What weaknesses or vices does your character struggle with?\"\n              />\n            </Grid>\n          </Grid>\n        );\n      \n      case 3: // Skills\n        const { count, skills } = getSkillChoicesForClass();\n        return (\n          <Box>\n            <Typography variant=\"h6\" gutterBottom>\n              Choose Skills \n              <Chip \n                label={`Select ${count} skills`} \n                color={character.skills.length === count ? \"success\" : \"primary\"} \n                size=\"small\" \n                sx={{ ml: 2 }}\n              />\n            </Typography>\n            \n            {character.class ? (\n              <FormControl fullWidth error={!!errors.skills}>\n                <InputLabel>Skills</InputLabel>\n                <Select\n                  multiple\n                  value={character.skills}\n                  onChange={handleSkillChange}\n                  input={<OutlinedInput label=\"Skills\" />}\n                  renderValue={(selected) => (\n                    <Box sx={{ display: 'flex', flexWrap: 'wrap', gap: 0.5 }}>\n                      {selected.map((value) => (\n                        <Chip key={value} label={formatSkillName(value)} />\n                      ))}\n                    </Box>\n                  )}\n                >\n                  {skills.map((skill) => (\n                    <MenuItem \n                      key={skill} \n                      value={skill}\n                      disabled={character.skills.length >= count && !character.skills.includes(skill)}\n                    >\n                      <Checkbox checked={character.skills.indexOf(skill) > -1} />\n                      <ListItemText primary={formatSkillName(skill)} />\n                    </MenuItem>\n                  ))}\n                </Select>\n                {errors.skills && <FormHelperText>{errors.skills}</FormHelperText>}\n              </FormControl>\n            ) : (\n              <Typography color=\"text.secondary\">\n                Please select a class first to see available skills.\n              </Typography>\n            )}\n          </Box>\n        );\n      \n      case 4: // Review\n        return (\n          <Box>\n            <Typography variant=\"h6\" gutterBottom>Review Your Character</Typography>\n            \n            <Grid container spacing={2}>\n              <Grid item xs={12} md={6}>\n                <Paper sx={{ p: 2, height: '100%' }}>\n                  <Typography variant=\"subtitle1\" gutterBottom>Basic Information</Typography>\n                  <Box sx={{ mb: 2 }}>\n                    <Typography variant=\"body2\" color=\"text.secondary\">Name:</Typography>\n                    <Typography variant=\"body1\">{character.name}</Typography>\n                  </Box>\n                  <Box sx={{ mb: 2 }}>\n                    <Typography variant=\"body2\" color=\"text.secondary\">Race:</Typography>\n                    <Typography variant=\"body1\">{character.race}</Typography>\n                  </Box>\n                  <Box sx={{ mb: 2 }}>\n                    <Typography variant=\"body2\" color=\"text.secondary\">Class:</Typography>\n                    <Typography variant=\"body1\">{character.class}</Typography>\n                  </Box>\n                  <Box sx={{ mb: 2 }}>\n                    <Typography variant=\"body2\" color=\"text.secondary\">Background:</Typography>\n                    <Typography variant=\"body1\">{character.background}</Typography>\n                  </Box>\n                  <Box>\n                    <Typography variant=\"body2\" color=\"text.secondary\">Alignment:</Typography>\n                    <Typography variant=\"body1\">{character.alignment}</Typography>\n                  </Box>\n                </Paper>\n              </Grid>\n              \n              <Grid item xs={12} md={6}>\n                <Paper sx={{ p: 2, height: '100%' }}>\n                  <Typography variant=\"subtitle1\" gutterBottom>Ability Scores</Typography>\n                  <Grid container spacing={1}>\n                    {[\"strength\", \"dexterity\", \"constitution\", \"intelligence\", \"wisdom\", \"charisma\"].map((ability) => (\n                      <Grid item xs={6} key={ability}>\n                        <Box sx={{ display: 'flex', alignItems: 'center', mb: 1 }}>\n                          <Typography variant=\"body2\" sx={{ textTransform: 'capitalize', minWidth: 100 }}>\n                            {ability}:\n                          </Typography>\n                          <Typography variant=\"body1\">\n                            {character[ability]} ({getModifier(character[ability]) >= 0 ? \"+\" : \"\"}{getModifier(character[ability])})\n                          </Typography>\n                        </Box>\n                      </Grid>\n                    ))}\n                  </Grid>\n                </Paper>\n              </Grid>\n              \n              <Grid item xs={12} md={6}>\n                <Paper sx={{ p: 2 }}>\n                  <Typography variant=\"subtitle1\" gutterBottom>Skills</Typography>\n                  {character.skills && character.skills.length > 0 ? (\n                    <Box sx={{ display: 'flex', flexWrap: 'wrap', gap: 0.5 }}>\n                      {character.skills.map((skill) => (\n                        <Chip key={skill} label={formatSkillName(skill)} />\n                      ))}\n                    </Box>\n                  ) : (\n                    <Typography variant=\"body2\" color=\"text.secondary\">No skills selected</Typography>\n                  )}\n                </Paper>\n              </Grid>\n              \n              <Grid item xs={12} md={6}>\n                <Paper sx={{ p: 2 }}>\n                  <Typography variant=\"subtitle1\" gutterBottom>Personality</Typography>\n                  \n                  {character.personalityTraits && (\n                    <Box sx={{ mb: 2 }}>\n                      <Typography variant=\"body2\" color=\"text.secondary\">Personality Traits:</Typography>\n                      <Typography variant=\"body2\">{character.personalityTraits}</Typography>\n                    </Box>\n                  )}\n                  \n                  {character.ideals && (\n                    <Box sx={{ mb: 2 }}>\n                      <Typography variant=\"body2\" color=\"text.secondary\">Ideals:</Typography>\n                      <Typography variant=\"body2\">{character.ideals}</Typography>\n                    </Box>\n                  )}\n                  \n                  {character.bonds && (\n                    <Box sx={{ mb: 2 }}>\n                      <Typography variant=\"body2\" color=\"text.secondary\">Bonds:</Typography>\n                      <Typography variant=\"body2\">{character.bonds}</Typography>\n                    </Box>\n                  )}\n                  \n                  {character.flaws && (\n                    <Box>\n                      <Typography variant=\"body2\" color=\"text.secondary\">Flaws:</Typography>\n                      <Typography variant=\"body2\">{character.flaws}</Typography>\n                    </Box>\n                  )}\n                  \n                  {!character.personalityTraits && !character.ideals && !character.bonds && !character.flaws && (\n                    <Typography variant=\"body2\" color=\"text.secondary\">No personality details provided</Typography>\n                  )}\n                </Paper>\n              </Grid>\n            </Grid>\n            \n            {errors.submit && (\n              <Typography color=\"error\" sx={{ mt: 2 }}>\n                {errors.submit}\n              </Typography>\n            )}\n          </Box>\n        );\n      \n      default:\n        return \"Unknown step\";\n    }\n  };\n\n  return (\n    <Box sx={{ maxWidth: 900, mx: 'auto', p: 3 }}>\n      <Typography variant=\"h4\" align=\"center\" gutterBottom>\n        Create a New Character\n      </Typography>\n      \n      <Stepper activeStep={activeStep} sx={{ mb: 4 }}>\n        {steps.map((label) => (\n          <Step key={label}>\n            <StepLabel>{label}</StepLabel>\n          </Step>\n        ))}\n      </Stepper>\n      \n      <Paper sx={{ p: 3 }}>\n        {getStepContent(activeStep)}\n        \n        <Divider sx={{ my: 3 }} />\n        \n        <Box sx={{ display: 'flex', justifyContent: 'space-between' }}>\n          <Button\n            variant=\"outlined\"\n            onClick={activeStep === 0 ? handleReset : handleBack}\n          >\n            {activeStep === 0 ? 'Reset' : 'Back'}\n          </Button>\n          \n          <Button\n            variant=\"contained\"\n            onClick={activeStep === steps.length - 1 ? handleSubmit : handleNext}\n          >\n            {activeStep === steps.length - 1 ? 'Create Character' : 'Next'}\n          </Button>\n        </Box>\n      </Paper>\n    </Box>\n  );\n};\n\nexport default CharacterCreation;\n\u0005End File\u0006# ryanbourdais/stormbraining-dnd\nimport React, { useState, useEffect } from 'react';\nimport { useParams, useNavigate } from 'react-router-dom';\nimport { \n  Box, Typography, Grid, Paper, Tabs, Tab, CircularProgress, Divider, Button,\n  Dialog, DialogTitle, DialogContent, DialogContentText, DialogActions\n} from '@mui/material';\n\n// Import Tab Components\nimport StatsTab from '../Components/CharacterSheet/Stats';\nimport InventoryTab from '../Components/CharacterSheet/Inventory';\nimport SpellsTab from '../Components/CharacterSheet/Spells';\nimport PersonalityTab from '../Components/CharacterSheet/Personality';\nimport ActionsTab from '../Components/CharacterSheet/Actions';\n\nfunction CharacterSheet() {\n  const { id } = useParams();\n  const navigate = useNavigate();\n  const [character, setCharacter] = useState(null);\n  const [loading, setLoading] = useState(true);\n  const [error, setError] = useState(null);\n  const [tabValue, setTabValue] = useState(0);\n  const [openDeleteDialog, setOpenDeleteDialog] = useState(false);\n\n  useEffect(() => {\n    const fetchCharacter = async () => {\n      try {\n        const response = await fetch(`/api/character/${id}`);\n        \n        if (!response.ok) {\n          throw new Error(`Error: ${response.status}`);\n        }\n        \n        const data = await response.json();\n        setCharacter(data);\n      } catch (err) {\n        console.error('Error fetching character:', err);\n        setError('Failed to load character data');\n      } finally {\n        setLoading(false);\n      }\n    };\n    \n    fetchCharacter();\n  }, [id]);\n\n  const handleTabChange = (event, newValue) => {\n    setTabValue(newValue);\n  };\n\n  const handleUpdateCharacter = async (updates) => {\n    try {\n      const response = await fetch(`/api/character/${id}`, {\n        method: 'PATCH',\n        headers: {\n          'Content-Type': 'application/json',\n        },\n        body: JSON.stringify(updates),\n      });\n      \n      if (!response.ok) {\n        throw new Error(`Error: ${response.status}`);\n      }\n      \n      const updatedCharacter = await response.json();\n      setCharacter(prevChar => ({\n        ...prevChar,\n        ...updatedCharacter\n      }));\n    } catch (err) {\n      console.error('Error updating character:', err);\n      // You could add error handling UI here\n    }\n  };\n\n  const handleDeleteCharacter = async () => {\n    try {\n      const response = await fetch(`/api/character/${id}`, {\n        method: 'DELETE',\n      });\n      \n      if (!response.ok) {\n        throw new Error(`Error: ${response.status}`);\n      }\n      \n      // Redirect to character list\n      navigate('/dashboard');\n    } catch (err) {\n      console.error('Error deleting character:', err);\n      // Add error handling UI here\n    }\n  };\n\n  const renderTabContent = () => {\n    switch (tabValue) {\n      case 0:\n        return <StatsTab character={character} onUpdateCharacter={handleUpdateCharacter} />;\n      case 1:\n        return <ActionsTab character={character} onUpdateCharacter={handleUpdateCharacter} />;\n      case 2:\n        return <InventoryTab character={character} onUpdateCharacter={handleUpdateCharacter} />;\n      case 3:\n        return <SpellsTab character={character} onUpdateCharacter={handleUpdateCharacter} />;\n      case 4:\n        return <PersonalityTab character={character} onUpdateCharacter={handleUpdateCharacter} />;\n      default:\n        return null;\n    }\n  };\n\n  if (loading) {\n    return (\n      <Box sx={{ display: 'flex', justifyContent: 'center', alignItems: 'center', height: '80vh' }}>\n        <CircularProgress />\n      </Box>\n    );\n  }\n\n  if (error || !character) {\n    return (\n      <Box sx={{ display: 'flex', justifyContent: 'center', alignItems: 'center', height: '80vh' }}>\n        <Typography variant=\"h5\" color=\"error\">{error || 'Character not found'}</Typography>\n      </Box>\n    );\n  }\n\n  return (\n    <Box sx={{ maxWidth: 1200, mx: 'auto', p: { xs: 1, sm: 2, md: 3 } }}>\n      <Box sx={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', mb: 3 }}>\n        <Typography variant=\"h4\">{character.name}</Typography>\n        <Button \n          variant=\"outlined\" \n          color=\"error\"\n          onClick={() => setOpenDeleteDialog(true)}\n        >\n          Delete Character\n        </Button>\n      </Box>\n      \n      <Paper sx={{ mb: 3, p: 2 }}>\n        <Grid container spacing={2}>\n          <Grid item xs={12} sm={4}>\n            <Typography variant=\"subtitle2\" color=\"text.secondary\">Race</Typography>\n            <Typography variant=\"body1\">{character.race}</Typography>\n          </Grid>\n          <Grid item xs={12} sm={4}>\n            <Typography variant=\"subtitle2\" color=\"text.secondary\">Class</Typography>\n            <Typography variant=\"body1\">{character.characterClass} (Level {character.level})</Typography>\n          </Grid>\n          <Grid item xs={12} sm={4}>\n            <Typography variant=\"subtitle2\" color=\"text.secondary\">Background</Typography>\n            <Typography variant=\"body1\">{character.background || 'None'}</Typography>\n          </Grid>\n        </Grid>\n      </Paper>\n      \n      <Paper sx={{ mb: 3 }}>\n        <Tabs\n          value={tabValue}\n          onChange={handleTabChange}\n          variant=\"scrollable\"\n          scrollButtons=\"auto\"\n        >\n          <Tab label=\"Stats\" />\n          <Tab label=\"Actions\" />\n          <Tab label=\"Inventory\" />\n          <Tab label=\"Spells\" />\n          <Tab label=\"Background\" />\n        </Tabs>\n        <Divider />\n        {renderTabContent()}\n      </Paper>\n\n      {/* Delete Confirmation Dialog */}\n      <Dialog\n        open={openDeleteDialog}\n        onClose={() => setOpenDeleteDialog(false)}\n      >\n        <DialogTitle>Delete Character</DialogTitle>\n        <DialogContent>\n          <DialogContentText>\n            Are you sure you want to delete {character.name}? This action cannot be undone.\n          </DialogContentText>\n        </DialogContent>\n        <DialogActions>\n          <Button onClick={() => setOpenDeleteDialog(false)}>Cancel</Button>\n          <Button onClick={handleDeleteCharacter} color=\"error\" autoFocus>\n            Delete\n          </Button>\n        </DialogActions>\n      </Dialog>\n    </Box>\n  );\n}\n\nexport default CharacterSheet;\n\u0000/ Nuke.\n    public async Task InitialiseAsync(TestContext test, TestExecutionConfig config)\n    {\n        // When executing directly from Nuke, use the command line arguments.\n        // Otherwise, if executing from Rider/Resharper, get config from TESTHOST parameters, which we set via the Task Runner\n        if (config.ExecutionModes.Count == 0)\n        {\n            ParseConfig(test, Environment.GetCommandLineArgs());\n        }\n\n        await Task.CompletedTask;\n    }\n\n    private void ParseConfig(TestContext test, string[] args)\n    {\n        var parsedArgs = ArgumentParser.Parse(args);\n\n        if (parsedArgs.TryGetValue(\"TESTHOST\", out var testhost) && !string.IsNullOrEmpty(testhost))\n        {\n            var argsFile = Path.GetFullPath(testhost);\n            try\n            {\n                var testhostArgs = File.ReadAllLines(argsFile);\n                parsedArgs = ArgumentParser.Parse(testhostArgs);\n            }\n            catch\n            {\n                test.WriteLine(\"Error reading TESTHOST args file\");\n            }\n        }\n\n        _executablePath = GetArgValue(parsedArgs, nameof(ExecutablePath), string.Empty);\n        _executionMode = parsedArgs.TryGetValue(nameof(ExecutionMode), out var execution) && Enum.TryParse(execution, true, out ExecutionMode mode)\n            ? mode\n            : ExecutionMode.ProfilerCore;\n\n        _execId = parsedArgs.TryGetValue(nameof(ExecId), out var execId) ? execId : Environment.MachineName;\n        _repoFolder = GetArgValue(parsedArgs, nameof(RepoFolder), null);\n        _pryingEyesFolder = GetArgValue(parsedArgs, nameof(PryingEyesFolder), null);\n        _siteConfigFolder = GetArgValue(parsedArgs, nameof(SiteConfigFolder), null);\n        _pryingEyesServer = GetArgValue(parsedArgs, nameof(PryingEyesServer), null);\n        _pryingEyesDatabase = GetArgValue(parsedArgs, nameof(PryingEyesDatabase), null);\n        _pryingEyesUsername = GetArgValue(parsedArgs, nameof(PryingEyesUsername), null);\n        _pryingEyesPassword = GetArgValue(parsedArgs, nameof(PryingEyesPassword), null);\n\n        test.WriteLine(\n            $\"Parsed Execution Mode: {_executionMode}, ExecId: {_execId}, ExecutablePath: {_executablePath}, Repo: {_repoFolder}, PryingEyesFolder: {_pryingEyesFolder}\");\n    }\n\n    private static string GetArgValue(Dictionary<string, string> parsedArgs, string name, string defaultValue = null)\n    {\n        return parsedArgs.TryGetValue(name, out var value) && !string.IsNullOrEmpty(value) ? value : defaultValue;\n    }\n\n    /// <summary>\n    /// Create a UI Tester wrapper for the given test.\n    /// </summary>\n    public IUITester Create(TestContext test)\n    {\n        switch (_executionMode)\n        {\n            case ExecutionMode.RegressionTest:\n                var regressionTester = new PryingEyesTester(test, _execId);\n                regressionTester.Init(_pryingEyesFolder, _pryingEyesServer, _pryingEyesDatabase, _pryingEyesUsername, _pryingEyesPassword);\n                return regressionTester;\n            case ExecutionMode.ProfilerCore:\n                return new NoxTester(test, _executablePath, _repoFolder, _siteConfigFolder);\n            case ExecutionMode.Screenshot:\n                return new ScreenshotTester(test, _executablePath);\n            default:\n                return new NoxTester(test, _executablePath, _repoFolder, _siteConfigFolder);\n        }\n    }\n}\u0005End File\u0006# maikhaihuy/nox\n# src/Nox.Integration.Tests/Base/TestExecutionConfig.cs\nusing System.Collections.Immutable;\nusing System.Text.Json;\nusing System.Text.Json.Serialization;\n\nnamespace Nox.Integration.Tests.Base;\n\npublic record TestExecutionConfig\n{\n    public IList<ExecutionMode> ExecutionModes { get; init; } = new List<ExecutionMode>();\n    public Dictionary<string, string> Options { get; init; } = new Dictionary<string, string>();\n    public Dictionary<string, TestParams> TestParameters { get; init; } = new Dictionary<string, TestParams>();\n\n    public class JsonConverter : JsonConverter<TestExecutionConfig>\n    {\n        public override TestExecutionConfig Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)\n        {\n            var doc = JsonDocument.ParseValue(ref reader);\n            var root = doc.RootElement;\n\n            var executionMode = root.TryGetProperty(\"ExecutionMode\", out var emElement)\n                ? emElement.ValueKind == JsonValueKind.Array\n                    ? JsonSerializer.Deserialize<List<ExecutionMode>>(emElement.GetRawText(), options) ?? new List<ExecutionMode>()\n                    : emElement.TryGetString() is { } modeStr && Enum.TryParse<ExecutionMode>(modeStr, true, out var modeEnum)\n                        ? new List<ExecutionMode> { modeEnum }\n                        : new List<ExecutionMode>()\n                : new List<ExecutionMode>();\n\n            var executionModes = root.TryGetProperty(\"ExecutionModes\", out var emsElement)\n                ? JsonSerializer.Deserialize<List<ExecutionMode>>(emsElement.GetRawText(), options) ?? new List<ExecutionMode>()\n                : new List<ExecutionMode>();\n\n            executionModes.AddRange(executionMode);\n\n            if (!executionModes.Any())\n            {\n                // Add defaults\n                executionModes = new List<ExecutionMode> { ExecutionMode.ProfilerCore };\n            }\n\n            var testParams = root.TryGetProperty(\"TestParameters\", out var testParamsElement)\n                ? JsonSerializer.Deserialize<Dictionary<string, TestParams>>(testParamsElement.GetRawText(), options) ?? new Dictionary<string, TestParams>()\n                : new Dictionary<string, TestParams>();\n\n            var options = root.TryGetProperty(\"Options\", out var optionsElement)\n                ? JsonSerializer.Deserialize<Dictionary<string, string>>(optionsElement.GetRawText(), options) ?? new Dictionary<string, string>()\n                : new Dictionary<string, string>();\n\n            return new TestExecutionConfig\n            {\n                ExecutionModes = executionModes,\n                TestParameters = testParams,\n                Options = options\n            };\n        }\n\n        public override void Write(Utf8JsonWriter writer, TestExecutionConfig value, JsonSerializerOptions options)\n        {\n            writer.WriteStartObject();\n\n            writer.WritePropertyName(\"ExecutionModes\");\n            JsonSerializer.Serialize(writer, value.ExecutionModes, options);\n\n            writer.WritePropertyName(\"Options\");\n            JsonSerializer.Serialize(writer, value.Options, options);\n\n            writer.WritePropertyName(\"TestParameters\");\n            JsonSerializer.Serialize(writer, value.TestParameters, options);\n\n            writer.WriteEndObject();\n        }\n    }\n}\n\npublic static class JsonExtensions\n{\n    public static string? TryGetString(this JsonElement element)\n    {\n        if (element.ValueKind == JsonValueKind.String)\n        {\n            return element.GetString();\n        }\n\n        return null;\n    }\n}\n\npublic record TestParams\n{\n    public Dictionary<string, string> Values { get; init; } = new Dictionary<string, string>();\n}\n\npublic enum ExecutionMode\n{\n    ProfilerCore,\n    Screenshot,\n    RegressionTest\n}\u0005End File\u0006# maikhaihuy/nox\n# src/Nox.Integration.Tests/Tests/AddressService.cs\n﻿using System.Net;\nusing System.Text;\nusing System.Text.Json;\nusing Nox.Integration.Tests.Base;\nusing Nox.Integration.Tests.UI;\nusing Xunit.Abstractions;\n\nnamespace Nox.Integration.Tests.Tests;\n\npublic class AddressServiceTestsFixture : ApiControllerBaseTestFixture\n{\n    public AddressServiceTestsFixture(ITestOutputHelper output) : base(output)\n    {\n    }\n\n    private async Task<List<PostalAddressDto>> GetAllItems(HttpClient httpClient)\n    {\n        var requestMessage = CreateApiRequestMessage(HttpMethod.Get, $\"/api/postalAddresses\");\n\n        var response = await httpClient.SendAsync(requestMessage);\n        var responseAsString = await response.Content.ReadAsStringAsync();\n        Assert.Equal(HttpStatusCode.OK, response.StatusCode);\n\n        var jsonOptions = new JsonSerializerOptions\n        {\n            PropertyNameCaseInsensitive = true,\n        };\n\n        var items = JsonSerializer.Deserialize<List<PostalAddressDto>>(responseAsString, jsonOptions);\n        Assert.NotNull(items);\n        return items;\n    }\n\n    public async Task<List<PostalAddressDto>> CreateItems(HttpClient httpClient, int countToCreate)\n    {\n        var returnedItems = new List<PostalAddressDto>();\n\n        for (var i = 0; i < countToCreate; i++)\n        {\n            var item = new PostalAddressDto\n            {\n                AddressLine1 = $\"LineOne{i + 1}\",\n                AddressLine2 = i % 2 == 0 ? $\"LineTwo{i + 1}\" : null,\n                City = $\"city{i + 1}\",\n                ZipCode = $\"{1000 + i}\"\n            };\n\n            var jsonItem = JsonSerializer.Serialize(item);\n\n            var requestMessage = CreateApiRequestMessage(HttpMethod.Post, $\"/api/postalAddresses\");\n            requestMessage.Content = new StringContent(jsonItem, Encoding.UTF8, \"application/json\");\n\n            var response = await httpClient.SendAsync(requestMessage);\n            var responseAsString = await response.Content.ReadAsStringAsync();\n            Assert.Equal(HttpStatusCode.Created, response.StatusCode);\n\n            var jsonOptions = new JsonSerializerOptions\n            {\n                PropertyNameCaseInsensitive = true,\n            };\n\n            var createdItem = JsonSerializer.Deserialize<PostalAddressDto>(responseAsString, jsonOptions);\n            Assert.NotNull(createdItem);\n\n            returnedItems.Add(createdItem);\n        }\n\n        return returnedItems;\n    }\n\n    public async Task DeleteItem(HttpClient httpClient, PostalAddressDto item)\n    {\n        var requestMessage = CreateApiRequestMessage(HttpMethod.Delete, $\"/api/postalAddresses/{item.Id}\");\n\n        var response = await httpClient.SendAsync(requestMessage);\n        Assert.Equal(HttpStatusCode.NoContent, response.StatusCode);\n    }\n\n    [Fact]\n    public async Task Test_Address_Service()\n    {\n        // Arrange\n        var httpClient = CreateClient();\n        var items = await GetAllItems(httpClient);\n        var count = items.Count;\n\n        var itemsToCreate = await CreateItems(httpClient, 3);\n\n        // Act - Get all items again\n        items = await GetAllItems(httpClient);\n\n        // Assert\n        Assert.Equal(count + 3, items.Count);\n\n        // Delete items\n        foreach (var item in itemsToCreate)\n        {\n            await DeleteItem(httpClient, item);\n        }\n\n        // Get all items again\n        items = await GetAllItems(httpClient);\n\n        // Assert\n        Assert.Equal(count, items.Count);\n    }\n}\n\npublic record PostalAddressDto\n{\n    public string Id { get; set; } = null!;\n    public string? AddressLine1 { get; set; }\n    public string? AddressLine2 { get; set; }\n    public string? City { get; set; }\n    public string? ZipCode { get; set; }\n}\u0005End File\u0006# src/Nox.Cli/Abstractions/Tasks/ProcessTask.cs\n// ReSharper disable once CheckNamespace\nnamespace Nox.Cli.Abstractions;\n\npublic abstract class ProcessTask : NoxCliAction\n{\n    /// <summary>\n    /// Default Constructor\n    /// </summary>\n    protected ProcessTask(string taskId, string? parentTaskId, \n        TaskClassification classification, WorkflowTask workflowTask, \n        ISecretsProvider? secretsProvider = null, \n        IStepConsoleWriter? consoleWriter = null, \n        IExecutionContext? executionContext = null)\n        : base(taskId, parentTaskId, classification, workflowTask, secretsProvider, consoleWriter, executionContext)\n    {\n    }\n\n    protected abstract ProcessTaskResult Execute();\n\n    protected override ValidationResult OnValidate()\n    {\n        return ValidationResult.Success();\n    }\n\n    protected override TaskResult OnExecute()\n    {\n        var result = Execute();\n\n        if (result.ExitCode != 0)\n        {\n            return TaskResult.FailureResult($\"Process returned non-zero exit code: {result.ExitCode}\");\n        }\n\n        var stdout = result.StdOut;\n        var stderr = result.StdErr;\n\n        var stepOutputs = new Dictionary<string, object>();\n\n        if (stdout?.Length > 0)\n        {\n            ConsoleWriter.WriteMutedLine(stdout);\n            stepOutputs.Add(\"stdout\", stdout);\n        }\n\n        if (stderr?.Length > 0)\n        {\n            if (result.ExitCode != 0)\n            {\n                ConsoleWriter.WriteErrorLine(stderr);\n            }\n            else\n            {\n                ConsoleWriter.WriteWarningLine(stderr);\n            }\n\n            stepOutputs.Add(\"stderr\", stderr);\n        }\n\n        stepOutputs.Add(\"exitCode\", result.ExitCode);\n\n        return TaskResult.SuccessResult(stepOutputs);\n    }\n\n    public struct ProcessTaskResult\n    {\n        public int ExitCode { get; set; }\n        public string? StdOut { get; set; }\n        public string? StdErr { get; set; }\n\n        public static ProcessTaskResult SuccessResult()\n        {\n            return new ProcessTaskResult\n            {\n                ExitCode = 0\n            };\n        }\n\n        public static ProcessTaskResult SuccessResult(string? stdOut, string? stdErr = null)\n        {\n            return new ProcessTaskResult\n            {\n                ExitCode = 0,\n                StdOut = stdOut,\n                StdErr = stdErr\n            };\n        }\n\n        public static ProcessTaskResult FailureResult(int exitCode, string? stdOut = null, string? stdErr = null)\n        {\n            return new ProcessTaskResult\n            {\n                ExitCode = exitCode,\n                StdOut = stdOut,\n                StdErr = stdErr\n            };\n        }\n    }\n}\u0005End File\u0006// ReSharper disable once CheckNamespace\nnamespace Nox.Cli.Abstractions;\n\n/// <summary>\n/// Base class for all custom Nox CLI tasks\n/// </summary>\npublic abstract class NoxCliAction\n{\n    #region Properties and Constructor\n\n    /// <summary>\n    /// Task ID\n    /// </summary>\n    public string TaskId { get; }\n\n    /// <summary>\n    /// Parent Task ID\n    /// </summary>\n    public string? ParentTaskId { get; }\n    \n    /// <summary>\n    /// Task Classification\n    /// </summary>\n    public TaskClassification Classification { get; }\n    \n    /// <summary>\n    /// Workflow Task\n    /// </summary>\n    public WorkflowTask Task { get; }\n    \n    /// <summary>\n    /// Secrets Provider\n    /// </summary>\n    protected readonly ISecretsProvider? SecretsProvider;\n    \n    /// <summary>\n    /// Console Writer\n    /// </summary>\n    protected readonly IStepConsoleWriter ConsoleWriter;\n    \n    /// <summary>\n    /// Execution Context\n    /// </summary>\n    protected readonly IExecutionContext? ExecutionContext;\n    \n    /// <summary>\n    /// Default Constructor\n    /// </summary>\n    protected NoxCliAction(string taskId, string? parentTaskId, \n        TaskClassification classification, WorkflowTask workflowTask, \n        ISecretsProvider? secretsProvider = null, \n        IStepConsoleWriter? consoleWriter = null, \n        IExecutionContext? executionContext = null)\n    {\n        TaskId = taskId;\n        ParentTaskId = parentTaskId;\n        Classification = classification;\n        Task = workflowTask;\n        SecretsProvider = secretsProvider;\n        ConsoleWriter = consoleWriter ?? new StepConsoleWriter(taskId);\n        ExecutionContext = executionContext;\n    }\n\n    #endregion\n    \n    #region Virtual Methods\n\n    /// <summary>\n    /// Called to validate the task\n    /// </summary>\n    /// <returns>ValidationResult</returns>\n    protected virtual ValidationResult OnValidate()\n    {\n        return ValidationResult.Success();\n    }\n\n    /// <summary>\n    /// Override this method to provide a custom validation for the task\n    /// </summary>\n    /// <returns>ValidationResult</returns>\n    protected virtual ValidationResult ValidateXml()\n    {\n        return ValidationResult.Success();\n    }\n\n    /// <summary>\n    /// Called to execute the task\n    /// </summary>\n    /// <returns>TaskResult</returns>\n    protected abstract TaskResult OnExecute();\n\n    #endregion\n\n    #region Public Methods\n\n    /// <summary>\n    /// Validate the task\n    /// </summary>\n    /// <returns>ValidationResult</returns>\n    public ValidationResult Validate()\n    {\n        var result = OnValidate();\n        if (!result.Success)\n        {\n            return result;\n        }\n\n        return ValidateXml();\n    }\n\n    /// <summary>\n    /// Execute the task\n    /// </summary>\n    /// <returns>TaskResult</returns>\n    public TaskResult Execute()\n    {\n        var result = OnExecute();\n        return result;\n    }\n\n    #endregion\n}\u0005End File\u0006# maikhaihuy/nox\n# src/Nox.Cli/Setup/NoxCliAppCommandExtensions.cs\nusing Nox.Cli.Variables;\nusing Spectre.Console.Cli;\n\nnamespace Nox.Cli.Setup;\n\npublic static class NoxCliAppCommandExtensions\n{\n    public static ICliAppSettings Configure(this IConfigurator configurator)\n    {\n        var settings = CliAppSettings.Initialize();\n        settings.Configure(configurator);\n\n        return settings;\n    }\n\n    public static IVariableDictionary GetConfigVariableDictionary(this CommandSettings settings, CommandContext? context = null)\n    {\n        var configPath = GetConfigPath(settings);\n        if (string.IsNullOrEmpty(configPath)) return new VariableDictionary();\n\n        var configValues = YamlVariablesLoader.LoadYamlVariablesFromFile(configPath);\n        \n        // If provided with context, add the path to the dictionary (needed for json schema validation)\n        if (context != null)\n        {\n            var configFileDir = Path.GetDirectoryName(Path.GetFullPath(configPath));\n            if (configFileDir != null)\n                configValues.AddVariable(\"nox-cwd\", configFileDir);\n        }\n        \n        return configValues;\n    }\n\n    private static string GetConfigPath(CommandSettings settings)\n    {\n        if (settings is BaseCommandSettings baseSettings)\n        {\n            return baseSettings.ConfigPath;\n        }\n        return string.Empty;\n    }\n\n    public static IVariableDictionary GetEnvVariableDictionary(this CommandSettings settings)\n    {\n        return new VariableDictionary()\n            .AddVariable(\"nox-home\", NoxHelper.GetNoxHome())\n            .AddVariable(\"nox-temp\", NoxHelper.GetNoxTemp())\n            .AddVariable(\"nox-cache\", NoxHelper.GetNoxCache())\n            .AddVariable(\"nox-bin\", NoxHelper.GetNoxBin())\n            .AddVariable(\"nox-workflows\", NoxHelper.GetNoxWorkflows())\n            .AddVariable(\"nox-manifest\", NoxHelper.GetNoxManifest())\n            .AddVariable(\"nox-dir\", NoxHelper.GetNoxInstallDir());\n    }\n\n    public static IVariableDictionary GetSystemVariableDictionary(this CommandSettings settings)\n    {\n        return new VariableDictionary()\n            .AddVariable(\"user-name\", Environment.UserName)\n            .AddVariable(\"home-dir\", Environment.GetFolderPath(Environment.SpecialFolder.UserProfile))\n            .AddVariable(\"host-name\", Environment.MachineName)\n            .AddVariable(\"platform\", GetPlatform())\n            .AddVariable(\"os-name\", GetOsName())\n            .AddVariable(\"os-version\", GetOsVersion());\n    }\n\n    private static string GetPlatform()\n    {\n        if (OperatingSystem.IsWindows())\n        {\n            return \"windows\";\n        }\n        if (OperatingSystem.IsLinux())\n        {\n            return \"linux\";\n        }\n        if (OperatingSystem.IsMacOS())\n        {\n            return \"macos\";\n        }\n        return \"unknown\";\n    }\n\n    private static string GetOsName()\n    {\n        if (OperatingSystem.IsWindows())\n        {\n            return \"windows\";\n        }\n        if (OperatingSystem.IsLinux())\n        {\n            return Environment.GetEnvironmentVariable(\"NAME\") ?? \"linux\";\n        }\n        if (OperatingSystem.IsMacOS())\n        {\n            return \"macos\";\n        }\n        return \"unknown\";\n    }\n\n    private static string GetOsVersion()\n    {\n        return Environment.OSVersion.VersionString;\n    }\n}\u0005End File\u0006using System.Reflection;\nusing Microsoft.Extensions.Configuration;\nusing Microsoft.Extensions.DependencyInjection;\nusing Microsoft.Extensions.Logging;\nusing Nox.Cli.Abstractions;\nusing Nox.Cli.Abstractions.Caching;\nusing Nox.Cli.Abstractions.Exceptions;\nusing Nox.Cli.Abstractions.Helpers;\nusing Nox.Cli.Actions;\nusing Nox.Cli.Actions.Loaders;\nusing Nox.Cli.Authentication;\nusing Nox.Cli.Configuration;\nusing Nox.Cli.Constants;\nusing Nox.Cli.Extensions;\nusing Nox.Cli.Helpers;\nusing Nox.Cli.Helpers.Json;\nusing Nox.Cli.Helpers.Xml;\nusing Nox.Cli.Plugin;\nusing Nox.Cli.Secrets;\nusing Nox.Cli.Services;\nusing Nox.Cli.Services.Caching;\nusing Nox.Cli.Services.Extensions;\nusing Spectre.Console.Cli;\n\nnamespace Nox.Cli.Setup;\n\npublic class CliAppSettings : ICliAppSettings\n{\n    private IServiceCollection? _services;\n    private TypeRegistrar? _registrar;\n\n    public static ICliAppSettings Initialize()\n    {\n        var settings = new CliAppSettings();\n        \n        settings._services = new ServiceCollection();\n        settings._registrar = new TypeRegistrar(settings._services);\n        \n        var currentAssembly = Assembly.GetExecutingAssembly();\n\n        // Add logging\n        settings.Services.AddLogging(configure => configure.AddConsole().SetMinimumLevel(LogLevel.Information));\n        \n        // Add services\n        settings.Services.AddSingleton<IExecutionContextAccessor, ExecutionContextAccessor>();\n        settings.Services.AddSingleton<IStepConsoleWriter, StepConsoleWriter>();\n        settings.Services.AddSingleton<ICacheService, CacheService>();\n        \n        // Register HttpClientFactory and Default Client\n        settings.Services.AddHttpClient();\n        settings.Services.AddHttpClient(HttpClientNames.Default, client =>\n        {\n            client.DefaultRequestHeaders.Add(\"User-Agent\", \"nox-cli\");\n        });\n        \n        // Register Json Helper\n        settings.Services.AddSingleton<IJsonValidator, JsonValidator>();\n        \n        // Register Xml Helper\n        settings.Services.AddSingleton<IXmlValidator, XmlValidator>();\n        \n        // Register Configuration\n        var configBuilder = new ConfigurationBuilder();\n        configBuilder.AddJsonFile(Path.Combine(NoxHelper.GetNoxHome(), \"cli-settings.json\"), true);\n        configBuilder.AddJsonFile(Path.Combine(NoxHelper.GetNoxHome(), \"credentials.json\"), true);\n        var configuration = configBuilder.Build();\n        settings.Services.AddSingleton<IConfiguration>(configuration);\n        \n        // Register Action Resolver\n        settings.Services.RegisterActionResolver(currentAssembly);\n        \n        // Register Resolvers\n        settings.Services.AddSingleton<IExecutionContextResolver, ExecutionContextResolver>();\n        \n        // Register Authentication\n        settings.Services.AddSingleton<INoxCliAuthenticationProvider, NoxCliAuthenticationProvider>();\n        \n        // Register Helpers and utils\n        settings.Services.AddSingleton<IFileSystem, FileSystem>();\n        settings.Services.AddSingleton<IProcessHelper, ProcessHelper>();\n        settings.Services.AddSingleton<INoxWorkflow, NoxWorkflow>();\n        settings.Services.AddSingleton<ICacheHelper, CacheHelper>();\n        settings.Services.AddSingleton<IJsonHelper, JsonHelper>();\n        settings.Services.AddSingleton<IProcessWrapper, ProcessWrapper>();\n        \n        // Register plugin helpers\n        settings.Services.AddSingleton<IPluginLoader, PluginLoader>();\n        settings.Services.AddSingleton<IPluginResolver, PluginResolver>();\n        \n        // Register authentication helpers\n        settings.Services.AddSingleton<ICredentialManager, CredentialManager>();\n        \n        // Register secrets provider\n        settings.Services.AddSingleton<ISecretsProvider, SecretsProvider>();\n        \n        return settings;\n    }\n\n    public IServiceCollection Services => _services ?? throw new ConfigurationException($\"Configuration has not been properly initialized\");\n    \n    public ITypeRegistrar Registrar => _registrar ?? throw new ConfigurationException($\"Configuration has not been properly initialized\");\n    \n    public void Configure(IConfigurator configurator)\n    {\n        // Nothing to do here currently\n    }\n}\u0005End File\u0006# maikhaihuy/nox\nusing System.Reflection;\nusing Newtonsoft.Json;\nusing Nox.Cli.Actions;\nusing Nox.Cli.Abstractions;\nusing Nox.Cli.Abstractions.Exceptions;\nusing Nox.Cli.Extensions;\nusing Nox.Cli.Plugin;\nusing Nox.Cli.Setup;\nusing Nox.Cli.Variables;\nusing Spectre.Console;\nusing Spectre.Console.Cli;\n\nnamespace Nox.Cli.Commands;\n\npublic class RunSettings : BaseWorkflowCommandSettings\n{\n    [CommandArgument(0, \"[project-id]\")]\n    [DefaultValue(\"\")]\n    public string ProjectId { get; set; } = string.Empty;\n\n    public bool IsProjectDefined => !string.IsNullOrEmpty(ProjectId);\n}\n\npublic class RunCommand : AsyncCommand<RunSettings>\n{\n    private readonly IExecutionContextAccessor _executionContextAccessor;\n    private readonly IPluginLoader _pluginLoader;\n\n    public RunCommand(IExecutionContextAccessor executionContextAccessor, IPluginLoader pluginLoader)\n    {\n        _executionContextAccessor = executionContextAccessor;\n        _pluginLoader = pluginLoader;\n    }\n\n    public override async Task<int> ExecuteAsync(CommandContext context, RunSettings settings)\n    {\n        AnsiConsole.Write(new Rule(\"Nox Cli Workflow\"));\n        \n        var configVars = settings.GetConfigVariableDictionary(context);\n        var envVars = settings.GetEnvVariableDictionary();\n        var systemVars = settings.GetSystemVariableDictionary();\n        \n        var variables = new List<IVariableDictionary>\n        {\n            systemVars,\n            envVars,\n            configVars\n        };\n        \n        AnsiConsole.MarkupLine(\"[yellow]Using the following variable lookups (last in list wins):[/]\");\n        AnsiConsole.MarkupLine($\"[yellow]- Environment Variables: {systemVars.Keys.Count} keys[/]\");\n        AnsiConsole.MarkupLine($\"[yellow]- System Variables: {envVars.Keys.Count} keys[/]\");\n        AnsiConsole.MarkupLine($\"[yellow]- Config Variables: {configVars.Keys.Count} keys[/]\");\n        \n        var workflowPath = GetWorkflowPath(settings, configVars);\n        AnsiConsole.MarkupLine($\"[yellow]Using workflow:[/] {workflowPath}\");\n        AnsiConsole.WriteLine();\n        \n        try\n        {\n            if (settings.RequiresInteractiveFlag)\n            {\n                AnsiConsole.MarkupLine(\"[red]This command requires user interaction.[/]\");\n                AnsiConsole.MarkupLine(\"[yellow]Please use the --interactive flag to run this command.[/]\");\n                return 1;\n            }\n            \n            if (settings.IsInteractive && settings.IsProjectDefined)\n            {\n                variables.Add(CreateInteractiveVariable(settings));\n            }\n            \n            // Load plugins\n            LoadPlugins(settings);\n            \n            // Get current directory\n            var currentDirectory = Directory.GetCurrentDirectory();\n            \n            var workflow = new NoxWorkflow(workflowPath, variables, settings.IsInteractive, settings.JsonSchema, settings.YamlSchema);\n            var executor = new NoxTaskExecutor(_executionContextAccessor);\n            \n            var result = await executor.ExecuteWorkflowAsync(workflow);\n            if (result.Status == TaskResultStatus.Failed)\n            {\n                Console.WriteLine();\n                AnsiConsole.MarkupLine($\"[red]{result.Message}[/]\");\n                Console.WriteLine();\n                return 1;\n            }\n            \n            Console.WriteLine();\n            return 0;\n        }\n        catch (FileNotFoundException ex)\n        {\n            Console.WriteLine();\n            AnsiConsole.MarkupLine($\"[red]Unable to find workflow path: {ex.Message}[/]\");\n            Console.WriteLine();\n            return 1;\n        }\n        catch (WorkflowException ex)\n        {\n            Console.WriteLine();\n            AnsiConsole.MarkupLine($\"[red]{ex.Message}[/]\");\n            Console.WriteLine();\n            return 1;\n        }\n        catch (Exception ex)\n        {\n            Console.WriteLine();\n            AnsiConsole.MarkupLine($\"[red]An error occurred: {ex.Message}[/]\");\n            Console.WriteLine();\n            return 1;\n        }\n    }\n\n    private string GetWorkflowPath(RunSettings settings, IVariableDictionary configVars)\n    {\n        // If projectId is provided, look for project in configVars\n        if (settings.IsProjectDefined)\n        {\n            var projectKey = $\"projects.{settings.ProjectId}.workflow\";\n            if (configVars.TryGetValue(projectKey, out var workflowFromConfig))\n            {\n                return workflowFromConfig.ToString()!;\n            }\n            \n            throw new FileNotFoundException($\"Project '{settings.ProjectId}' not found in config file\");\n        }\n        \n        // Return workflow path from settings if provided\n        if (!string.IsNullOrEmpty(settings.WorkflowPath))\n        {\n            return settings.WorkflowPath;\n        }\n        \n        // Check for workflow in current directory\n        var currentDirWorkflow = Path.Combine(Directory.GetCurrentDirectory(), \"nox.yaml\");\n        if (File.Exists(currentDirWorkflow))\n        {\n            return currentDirWorkflow;\n        }\n        \n        throw new FileNotFoundException(\"No workflow specified and no nox.yaml found in current directory\");\n    }\n\n    private void LoadPlugins(RunSettings settings)\n    {\n        if (string.IsNullOrEmpty(settings.PluginPath))\n        {\n            return;\n        }\n        \n        try\n        {\n            _pluginLoader.LoadPlugins(settings.PluginPath);\n        }\n        catch (PluginException ex)\n        {\n            AnsiConsole.MarkupLine($\"[red]Error loading plugins: {ex.Message}[/]\");\n        }\n    }\n\n    private IVariableDictionary CreateInteractiveVariable(RunSettings settings)\n    {\n        var result = new VariableDictionary();\n        \n        // Add project ID from settings\n        result.AddVariable(\"project-id\", settings.ProjectId);\n        \n        // Return interactive variable dictionary\n        return result;\n    }\n}\u0005End File\u0006# src/Nox.Cli/Commands/ProjectListCommand.cs\nusing Nox.Cli.Abstractions.Exceptions;\nusing Nox.Cli.Configuration;\nusing Nox.Cli.Setup;\nusing Nox.Cli.Variables;\nusing Spectre.Console;\nusing Spectre.Console.Cli;\nusing YamlDotNet.Core;\n\nnamespace Nox.Cli.Commands;\n\npublic class ProjectListSettings : BaseCommandSettings\n{\n    [CommandOption(\"-d|--details\")]\n    [DefaultValue(false)]\n    public bool ShowDetails { get; set; }\n}\n\npublic class ProjectListCommand : Command<ProjectListSettings>\n{\n    public override int Execute(CommandContext context, ProjectListSettings settings)\n    {\n        AnsiConsole.Write(new Rule(\"Nox CLI Project List\"));\n        try\n        {\n            var configVars = settings.GetConfigVariableDictionary();\n            \n            // Get projects from config\n            var projects = GetProjects(configVars);\n            \n            if (projects.Count == 0)\n            {\n                AnsiConsole.MarkupLine(\"[yellow]No projects found in the configuration file.[/]\");\n                return 0;\n            }\n            \n            // Display projects\n            var table = new Table()\n                .Border(TableBorder.Rounded)\n                .BorderColor(Color.Grey)\n                .Title(\"[yellow]Projects[/]\");\n            \n            // Add columns\n            table.AddColumn(new TableColumn(\"[green]Project ID[/]\").Centered());\n            \n            if (settings.ShowDetails)\n            {\n                table.AddColumn(new TableColumn(\"[green]Workflow Path[/]\").Centered());\n                table.AddColumn(new TableColumn(\"[green]Description[/]\"));\n            }\n            \n            // Add rows\n            foreach (var project in projects)\n            {\n                if (settings.ShowDetails)\n                {\n                    table.AddRow(\n                        project.Id,\n                        project.Workflow ?? \"N/A\",\n                        project.Description ?? \"N/A\"\n                    );\n                }\n                else\n                {\n                    table.AddRow(project.Id);\n                }\n            }\n            \n            AnsiConsole.Write(table);\n            \n            return 0;\n        }\n        catch (YamlException ex)\n        {\n            AnsiConsole.MarkupLine($\"[red]Invalid YAML in config file: {ex.Message}[/]\");\n            return 1;\n        }\n        catch (ConfigurationException ex)\n        {\n            AnsiConsole.MarkupLine($\"[red]{ex.Message}[/]\");\n            return 1;\n        }\n        catch (Exception ex)\n        {\n            AnsiConsole.MarkupLine($\"[red]An error occurred: {ex.Message}[/]\");\n            return 1;\n        }\n    }\n\n    private List<ProjectInfo> GetProjects(IVariableDictionary configVars)\n    {\n        var projects = new List<ProjectInfo>();\n        \n        // Try to get the projects section from config\n        if (!configVars.TryGetNode(\"projects\", out var projectsNode) || projectsNode == null)\n        {\n            return projects;\n        }\n        \n        // Get projects\n        foreach (var projectNode in projectsNode.Children)\n        {\n            var projectId = projectNode.Key;\n            var projectWorkflow = projectNode.Value.GetNestedValueOrDefault(\"workflow\", string.Empty);\n            var projectDescription = projectNode.Value.GetNestedValueOrDefault(\"description\", string.Empty);\n            \n            projects.Add(new ProjectInfo\n            {\n                Id = projectId,\n                Workflow = projectWorkflow,\n                Description = projectDescription\n            });\n        }\n        \n        return projects;\n    }\n    \n    private class ProjectInfo\n    {\n        public string Id { get; set; } = string.Empty;\n        public string? Workflow { get; set; }\n        public string? Description { get; set; }\n    }\n}\u0005End File\u0006using System.Reflection;\nusing Nox.Cli.Plugin;\nusing Spectre.Console;\nusing Spectre.Console.Cli;\n\nnamespace Nox.Cli.Commands;\n\npublic class PluginListSettings : CommandSettings\n{\n    [CommandOption(\"-p|--plugin-path\")]\n    [DefaultValue(\"\")]\n    public string PluginPath { get; set; } = string.Empty;\n\n    [CommandOption(\"-d|--details\")]\n    [DefaultValue(false)]\n    public bool ShowDetails { get; set; }\n}\n\npublic class PluginListCommand : Command<PluginListSettings>\n{\n    private readonly IPluginLoader _pluginLoader;\n\n    public PluginListCommand(IPluginLoader pluginLoader)\n    {\n        _pluginLoader = pluginLoader;\n    }\n\n    public override int Execute(CommandContext context, PluginListSettings settings)\n    {\n        AnsiConsole.Write(new Rule(\"Nox CLI Plugins\"));\n\n        // Find plugin folder\n        var pluginPath = GetPluginPath(settings);\n        if (string.IsNullOrEmpty(pluginPath) || !Directory.Exists(pluginPath))\n        {\n            AnsiConsole.MarkupLine(\"[yellow]No plugin folder found.[/]\");\n            return 0;\n        }\n\n        AnsiConsole.MarkupLine($\"[yellow]Loading plugins from:[/] {pluginPath}\");\n        \n        try\n        {\n            var plugins = _pluginLoader.LoadPlugins(pluginPath);\n            \n            if (plugins.Count == 0)\n            {\n                AnsiConsole.MarkupLine(\"[yellow]No plugins found.[/]\");\n                return 0;\n            }\n            \n            // Display plugins\n            var table = new Table()\n                .Border(TableBorder.Rounded)\n                .BorderColor(Color.Grey)\n                .Title(\"[yellow]Loaded Plugins[/]\");\n            \n            // Add columns\n            table.AddColumn(new TableColumn(\"[green]Plugin Name[/]\").Centered());\n            table.AddColumn(new TableColumn(\"[green]Version[/]\").Centered());\n            \n            if (settings.ShowDetails)\n            {\n                table.AddColumn(new TableColumn(\"[green]Actions[/]\"));\n            }\n            \n            // Add rows\n            foreach (var plugin in plugins)\n            {\n                var assemblyName = plugin.Assembly.GetName();\n                var version = assemblyName.Version?.ToString() ?? \"Unknown\";\n                \n                if (settings.ShowDetails)\n                {\n                    var actionNames = GetPluginActionNames(plugin.Assembly);\n                    table.AddRow(\n                        assemblyName.Name ?? \"Unknown\",\n                        version,\n                        string.Join(\", \", actionNames)\n                    );\n                }\n                else\n                {\n                    table.AddRow(\n                        assemblyName.Name ?? \"Unknown\",\n                        version\n                    );\n                }\n            }\n            \n            AnsiConsole.Write(table);\n            \n            return 0;\n        }\n        catch (Exception ex)\n        {\n            AnsiConsole.MarkupLine($\"[red]Error loading plugins: {ex.Message}[/]\");\n            return 1;\n        }\n    }\n\n    private string GetPluginPath(PluginListSettings settings)\n    {\n        if (!string.IsNullOrEmpty(settings.PluginPath))\n        {\n            return settings.PluginPath;\n        }\n        \n        // Check if we have a \"plugins\" folder in the current directory\n        var currentDirPlugins = Path.Combine(Directory.GetCurrentDirectory(), \"plugins\");\n        if (Directory.Exists(currentDirPlugins))\n        {\n            return currentDirPlugins;\n        }\n        \n        // Check for the Nox CLI plugins folder\n        var noxCliPlugins = Path.Combine(NoxHelper.GetNoxHome(), \"plugins\");\n        if (Directory.Exists(noxCliPlugins))\n        {\n            return noxCliPlugins;\n        }\n        \n        return string.Empty;\n    }\n\n    private List<string> GetPluginActionNames(Assembly assembly)\n    {\n        var actionNames = new List<string>();\n        \n        var types = assembly.GetExportedTypes()\n            .Where(t => !t.IsAbstract && t.Name.EndsWith(\"Action\") && !t.Name.StartsWith(\"<\"))\n            .ToList();\n        \n        foreach (var type in types)\n        {\n            actionNames.Add(type.Name);\n        }\n        \n        return actionNames;\n    }\n}\u0005End File\u0006# maikhaihuy/nox\nusing Nox.Cli.Setup;\nusing Nox.Cli.Variables;\nusing Spectre.Console;\nusing Spectre.Console.Cli;\nusing Spectre.Console.Json;\n\nnamespace Nox.Cli.Commands;\n\npublic class ConfigListSettings : BaseCommandSettings\n{\n    [CommandOption(\"-j|--json\")]\n    [DefaultValue(false)]\n    public bool Json { get; set; }\n}\n\npublic class ConfigListCommand : Command<ConfigListSettings>\n{\n    public override int Execute(CommandContext context, ConfigListSettings settings)\n    {\n        AnsiConsole.Write(new Rule(\"Nox CLI Configuration\"));\n        \n        try\n        {\n            var configVars = settings.GetConfigVariableDictionary();\n            var envVars = settings.GetEnvVariableDictionary();\n            var systemVars = settings.GetSystemVariableDictionary();\n            \n            if (settings.Json)\n            {\n                // Display as JSON\n                AnsiConsole.Write(new Markup(\"[yellow]Configuration Variables:[/]\\n\"));\n                AnsiConsole.Write(new JsonText(configVars.ToJson()));\n                \n                AnsiConsole.WriteLine();\n                AnsiConsole.Write(new Markup(\"[yellow]Environment Variables:[/]\\n\"));\n                AnsiConsole.Write(new JsonText(envVars.ToJson()));\n                \n                AnsiConsole.WriteLine();\n                AnsiConsole.Write(new Markup(\"[yellow]System Variables:[/]\\n\"));\n                AnsiConsole.Write(new JsonText(systemVars.ToJson()));\n            }\n            else\n            {\n                // Display in tables\n                DisplayVarTable(\"Configuration Variables\", configVars);\n                DisplayVarTable(\"Environment Variables\", envVars);\n                DisplayVarTable(\"System Variables\", systemVars);\n            }\n            \n            return 0;\n        }\n        catch (Exception ex)\n        {\n            AnsiConsole.MarkupLine($\"[red]An error occurred: {ex.Message}[/]\");\n            return 1;\n        }\n    }\n\n    private void DisplayVarTable(string title, IVariableDictionary vars)\n    {\n        var table = new Table()\n            .Border(TableBorder.Rounded)\n            .BorderColor(Color.Grey)\n            .Title($\"[yellow]{title}[/]\");\n        \n        table.AddColumn(new TableColumn(\"[green]Key[/]\"));\n        table.AddColumn(new TableColumn(\"[green]Value[/]\"));\n        \n        // Add all variables from dictionary\n        var flattenedVars = vars.GetFlattenedVariables();\n        \n        foreach (var key in flattenedVars.Keys.OrderBy(k => k))\n        {\n            var value = flattenedVars[key]?.ToString() ?? \"null\";\n            \n            // Truncate long values\n            if (value.Length > 50)\n            {\n                value = value.Substring(0, 47) + \"...\";\n            }\n            \n            table.AddRow(key, value);\n        }\n        \n        AnsiConsole.Write(table);\n        AnsiConsole.WriteLine();\n    }\n}\u0005End File\u0006# maikhaihuy/nox\nusing Spectre.Console;\nusing Spectre.Console.Cli;\nusing System.Reflection;\nusing Nox.Cli.Constants;\nusing Nox.Cli.Extensions;\nusing Nox.Cli.Helpers;\nusing Nox.Cli.Setup;\n\nnamespace Nox.Cli.Commands;\n\npublic class UpdateSettings : CommandSettings\n{\n    [CommandOption(\"-p|--pre-release\")]\n    [DefaultValue(false)]\n    public bool PreRelease { get; set; }\n}\n\npublic class UpdateCommand : AsyncCommand<UpdateSettings>\n{\n    private readonly IHttpClientFactory _httpClientFactory;\n\n    public UpdateCommand(IHttpClientFactory httpClientFactory)\n    {\n        _httpClientFactory = httpClientFactory;\n    }\n    \n    public override async Task<int> ExecuteAsync(CommandContext context, UpdateSettings settings)\n    {\n        AnsiConsole.Write(new Rule(\"Nox CLI Update\"));\n        \n        try\n        {\n            var currentVersion = Assembly.GetExecutingAssembly().GetName().Version;\n            if (currentVersion == null)\n            {\n                AnsiConsole.MarkupLine(\"[red]Could not determine current version.[/]\");\n                return 1;\n            }\n            \n            AnsiConsole.MarkupLine($\"[yellow]Current version:[/] {currentVersion}\");\n            \n            if (settings.PreRelease)\n            {\n                AnsiConsole.MarkupLine(\"[yellow]Looking for pre-release versions[/]\");\n            }\n            \n            // Check for updates\n            AnsiConsole.MarkupLine(\"[yellow]Checking for updates...[/]\");\n            \n            // Create HTTP client\n            var httpClient = _httpClientFactory.CreateClient(HttpClientNames.Default);\n            \n            // Get latest release\n            var releases = await GitHubReleaseHelper.GetGitHubReleasesAsync(httpClient, \"niels9001/nox-cli\", settings.PreRelease);\n            if (releases == null || releases.Count == 0)\n            {\n                AnsiConsole.MarkupLine(\"[red]Could not fetch releases from GitHub.[/]\");\n                return 1;\n            }\n            \n            var latestRelease = releases[0];\n            \n            // Parse version\n            if (!Version.TryParse(latestRelease.TagName.TrimStart('v'), out var latestVersion))\n            {\n                AnsiConsole.MarkupLine(\"[red]Could not parse latest version.[/]\");\n                return 1;\n            }\n            \n            // Compare versions\n            if (latestVersion <= currentVersion)\n            {\n                AnsiConsole.MarkupLine(\"[green]You are already running the latest version.[/]\");\n                return 0;\n            }\n            \n            // Prompt for update\n            var shouldUpdate = AnsiConsole.Prompt(\n                new SelectionPrompt<string>()\n                    .Title($\"[yellow]New version available:[/] {latestVersion}\")\n                    .AddChoices(new[] { \"Update\", \"Cancel\" }));\n            \n            if (shouldUpdate == \"Cancel\")\n            {\n                AnsiConsole.MarkupLine(\"[yellow]Update cancelled.[/]\");\n                return 0;\n            }\n            \n            // Get the download URL based on platform\n            string? downloadUrl = null;\n            foreach (var asset in latestRelease.Assets)\n            {\n                if (PlatformHelper.IsWindows() && asset.Name.EndsWith(\".msi\"))\n                {\n                    downloadUrl = asset.BrowserDownloadUrl;\n                    break;\n                }\n                \n                if (PlatformHelper.IsMacOS() && asset.Name.EndsWith(\".pkg\"))\n                {\n                    downloadUrl = asset.BrowserDownloadUrl;\n                    break;\n                }\n                \n                if (PlatformHelper.IsLinux() && asset.Name.EndsWith(\".deb\"))\n                {\n                    downloadUrl = asset.BrowserDownloadUrl;\n                    break;\n                }\n            }\n            \n            if (downloadUrl == null)\n            {\n                AnsiConsole.MarkupLine(\"[red]Could not find a download for your platform.[/]\");\n                return 1;\n            }\n            \n            // Download the installer\n            var tempFile = Path.Combine(Path.GetTempPath(), Path.GetFileName(downloadUrl));\n            \n            await AnsiConsole.Status()\n                .StartAsync(\"Downloading update...\", async ctx =>\n                {\n                    await DownloadFileAsync(httpClient, downloadUrl, tempFile);\n                });\n            \n            // Run the installer\n            AnsiConsole.MarkupLine(\"[yellow]Starting installer...[/]\");\n            \n            if (PlatformHelper.IsWindows())\n            {\n                // Run MSI\n                System.Diagnostics.Process.Start(new System.Diagnostics.ProcessStartInfo\n                {\n                    FileName = \"msiexec\",\n                    Arguments = $\"/i \\\"{tempFile}\\\"\",\n                    UseShellExecute = true\n                });\n            }\n            else if (PlatformHelper.IsMacOS())\n            {\n                // Run PKG\n                System.Diagnostics.Process.Start(new System.Diagnostics.ProcessStartInfo\n                {\n                    FileName = \"open\",\n                    Arguments = $\"\\\"{tempFile}\\\"\",\n                    UseShellExecute = true\n                });\n            }\n            else if (PlatformHelper.IsLinux())\n            {\n                // Run DEB\n                System.Diagnostics.Process.Start(new System.Diagnostics.ProcessStartInfo\n                {\n                    FileName = \"sudo\",\n                    Arguments = $\"dpkg -i \\\"{tempFile}\\\"\",\n                    UseShellExecute = true\n                });\n            }\n            \n            AnsiConsole.MarkupLine(\"[green]Update started. Please complete the installation process.[/]\");\n            return 0;\n        }\n        catch (Exception ex)\n        {\n            AnsiConsole.MarkupLine($\"[red]Error: {ex.Message}[/]\");\n            return 1;\n        }\n    }\n\n    private async Task DownloadFileAsync(HttpClient client, string url, string filePath)\n    {\n        using var response = await client.GetAsync(url, HttpCompletionOption.ResponseHeadersRead);\n        response.EnsureSuccessStatusCode();\n        \n        using var fileStream = new FileStream(filePath, FileMode.Create, FileAccess.Write, FileShare.None);\n        await response.Content.CopyToAsync(fileStream);\n    }\n}\u0005End File\u0006# maikhaihuy/nox\nusing System.Diagnostics;\nusing Nox.Cli.Abstractions.Helpers;\n\nnamespace Nox.Cli.Helpers;\n\n/// <summary>\n/// Helper class for running processes\n/// </summary>\npublic class ProcessHelper : IProcessHelper\n{\n    private readonly IProcessWrapper _processWrapper;\n\n    public ProcessHelper(IProcessWrapper processWrapper)\n    {\n        _processWrapper = processWrapper;\n    }\n\n    /// <summary>\n    /// Get full path for executable file if it exists\n    /// </summary>\n    /// <param name=\"executableName\">Executable name or full path</param>\n    /// <returns>Full path or null if not found</returns>\n    public string? GetFullPath(string executableName)\n    {\n        if (Path.IsPathRooted(executableName) && File.Exists(executableName))\n        {\n            return executableName;\n        }\n        \n        // Check if executable exists in PATH\n        var paths = Environment.GetEnvironmentVariable(\"PATH\")?.Split(Path.PathSeparator) ?? Array.Empty<string>();\n        var extensions = OperatingSystem.IsWindows()\n            ? Environment.GetEnvironmentVariable(\"PATHEXT\")?.Split(Path.PathSeparator) ?? new[] { \".exe\", \".cmd\", \".bat\" }\n            : new[] { string.Empty };\n\n        foreach (var path in paths)\n        {\n            foreach (var extension in extensions)\n            {\n                var fullPath = Path.Combine(path, executableName + extension);\n                if (File.Exists(fullPath))\n                {\n                    return fullPath;\n                }\n            }\n        }\n        \n        // Try to see if it's in the Nox bin folder\n        var noxBinFolder = NoxHelper.GetNoxBin();\n        foreach (var extension in extensions)\n        {\n            var fullPath = Path.Combine(noxBinFolder, executableName + extension);\n            if (File.Exists(fullPath))\n            {\n                return fullPath;\n            }\n        }\n\n        return null;\n    }\n\n    /// <summary>\n    /// Run a process and return its output\n    /// </summary>\n    /// <param name=\"executable\">Executable path</param>\n    /// <param name=\"arguments\">Arguments</param>\n    /// <param name=\"workingDirectory\">Working directory</param>\n    /// <param name=\"environmentVariables\">Environment variables</param>\n    /// <param name=\"timeout\">Timeout in milliseconds (default: 60000)</param>\n    /// <returns>Exit code, stdout, and stderr</returns>\n    public (int exitCode, string stdout, string stderr) RunProcess(\n        string executable,\n        string arguments,\n        string? workingDirectory = null,\n        IDictionary<string, string>? environmentVariables = null,\n        int timeout = 60000)\n    {\n        var startInfo = new ProcessStartInfo\n        {\n            FileName = executable,\n            Arguments = arguments,\n            UseShellExecute = false,\n            RedirectStandardOutput = true,\n            RedirectStandardError = true,\n            CreateNoWindow = true,\n            WorkingDirectory = workingDirectory ?? Directory.GetCurrentDirectory()\n        };\n        \n        // Add environment variables\n        if (environmentVariables != null)\n        {\n            foreach (var kvp in environmentVariables)\n            {\n                startInfo.EnvironmentVariables[kvp.Key] = kvp.Value;\n            }\n        }\n\n        var stdout = new System.Text.StringBuilder();\n        var stderr = new System.Text.StringBuilder();\n        \n        var process = _processWrapper.Start(startInfo);\n        if (process == null)\n        {\n            return (1, string.Empty, $\"Failed to start process: {executable}\");\n        }\n        \n        process.OutputDataReceived += (_, e) =>\n        {\n            if (e.Data != null)\n            {\n                stdout.AppendLine(e.Data);\n            }\n        };\n        \n        process.ErrorDataReceived += (_, e) =>\n        {\n            if (e.Data != null)\n            {\n                stderr.AppendLine(e.Data);\n            }\n        };\n        \n        process.BeginOutputReadLine();\n        process.BeginErrorReadLine();\n        \n        if (process.WaitForExit(timeout))\n        {\n            return (process.ExitCode, stdout.ToString(), stderr.ToString());\n        }\n        \n        try\n        {\n            process.Kill();\n        }\n        catch\n        {\n            // Ignore errors when killing the process\n        }\n        \n        return (1, stdout.ToString(), $\"Process timed out after {timeout}ms\");\n    }\n}\n\npublic interface IProcessWrapper\n{\n    Process? Start(ProcessStartInfo startInfo);\n}\n\npublic class ProcessWrapper : IProcessWrapper\n{\n    public Process? Start(ProcessStartInfo startInfo)\n    {\n        return Process.Start(startInfo);\n    }\n}\u0005End File\u0006# maikhaihuy/nox\nusing System.Text.Json;\nusing Nox.Cli.Abstractions.Extensions;\nusing Nox.Cli.Constants;\n\nnamespace Nox.Cli.Helpers;\n\n/// <summary>\n/// Helper class for GitHub release operations\n/// </summary>\npublic static class GitHubReleaseHelper\n{\n    /// <summary>\n    /// Gets the list of GitHub releases for a repository\n    /// </summary>\n    /// <param name=\"httpClient\">HttpClient instance</param>\n    /// <param name=\"repo\">Repository in format \"owner/repo\"</param>\n    /// <param name=\"includePrerelease\">Whether to include prerelease versions</param>\n    /// <returns>List of GitHub releases</returns>\n    public static async Task<List<GitHubRelease>?> GetGitHubReleasesAsync(HttpClient httpClient, string repo, bool includePrerelease = false)\n    {\n        var url = $\"{GitHubConstants.ApiBaseUrl}/repos/{repo}/releases\";\n        var response = await httpClient.GetAsync(url);\n        \n        if (!response.IsSuccessStatusCode)\n        {\n            return null;\n        }\n        \n        var content = await response.Content.ReadAsStringAsync();\n        var releases = JsonSerializer.Deserialize<List<GitHubRelease>>(content, new JsonSerializerOptions\n        {\n            PropertyNameCaseInsensitive = true\n        });\n        \n        if (releases == null)\n        {\n            return null;\n        }\n        \n        // Filter out prerelease versions if not requested\n        if (!includePrerelease)\n        {\n            releases = releases.Where(r => !r.Prerelease).ToList();\n        }\n        \n        // Sort by version, not by publish date\n        releases = releases.OrderByDescending(r => \n        {\n            if (Version.TryParse(r.TagName.TrimStart('v'), out var version))\n            {\n                return version;\n            }\n            return new Version(0, 0, 0);\n        }).ToList();\n        \n        return releases;\n    }\n}\n\n/// <summary>\n/// Represents a GitHub release\n/// </summary>\npublic class GitHubRelease\n{\n    public string Url { get; set; } = string.Empty;\n    public string AssetsUrl { get; set; } = string.Empty;\n    public string HtmlUrl { get; set; } = string.Empty;\n    public int Id { get; set; }\n    public string TagName { get; set; } = string.Empty;\n    public string Name { get; set; } = string.Empty;\n    public bool Draft { get; set; }\n    public bool Prerelease { get; set; }\n    public DateTime CreatedAt { get; set; }\n    public DateTime PublishedAt { get; set; }\n    public List<GitHubAsset> Assets { get; set; } = new();\n    public string Body { get; set; } = string.Empty;\n}\n\n/// <summary>\n/// Represents a GitHub asset\n/// </summary>\npublic class GitHubAsset\n{\n    public string Url { get; set; } = string.Empty;\n    public int Id { get; set; }\n    public string Name { get; set; } = string.Empty;\n    public string ContentType { get; set; } = string.Empty;\n    public long Size { get; set; }\n    public string BrowserDownloadUrl { get; set; } = string.Empty;\n}\u0005End File\u0006using System.Text.Json;\nusing System.Text.Json.Nodes;\nusing System.Text.Json.Serialization;\nusing Nox.Cli.Abstractions.Helpers;\n\nnamespace Nox.Cli.Helpers.Json;\n\npublic class JsonHelper : IJsonHelper\n{\n    /// <summary>\n    /// Merges JSON nodes with the base taking precedence in case of conflicts\n    /// </summary>\n    /// <param name=\"baseNode\">Base JSON node</param>\n    /// <param name=\"overrideNode\">Override JSON node</param>\n    /// <returns>Merged JSON node</returns>\n    public JsonNode? MergeJsonNodes(JsonNode? baseNode, JsonNode? overrideNode)\n    {\n        if (baseNode == null)\n        {\n            return overrideNode?.DeepClone();\n        }\n\n        if (overrideNode == null)\n        {\n            return baseNode.DeepClone();\n        }\n\n        // Handle different node types\n        return (baseNode, overrideNode) switch\n        {\n            (JsonObject baseObj, JsonObject overrideObj) => MergeJsonObjects(baseObj, overrideObj),\n            (JsonArray baseArray, JsonArray overrideArray) => MergeJsonArrays(baseArray, overrideArray),\n            _ => baseNode.DeepClone() // For value types, base takes precedence\n        };\n    }\n\n    /// <summary>\n    /// Merges JSON objects with base taking precedence in case of conflicts\n    /// </summary>\n    /// <param name=\"baseObj\">Base JSON object</param>\n    /// <param name=\"overrideObj\">Override JSON object</param>\n    /// <returns>Merged JSON object</returns>\n    private JsonObject MergeJsonObjects(JsonObject baseObj, JsonObject overrideObj)\n    {\n        var resultObj = new JsonObject();\n\n        // Add properties from override object\n        foreach (var property in overrideObj)\n        {\n            resultObj.Add(property.Key, property.Value?.DeepClone());\n        }\n\n        // Add or replace properties from base object (base takes precedence)\n        foreach (var property in baseObj)\n        {\n            if (resultObj.ContainsKey(property.Key))\n            {\n                // If property exists in both, merge them\n                resultObj[property.Key] = MergeJsonNodes(property.Value, resultObj[property.Key]);\n            }\n            else\n            {\n                resultObj.Add(property.Key, property.Value?.DeepClone());\n            }\n        }\n\n        return resultObj;\n    }\n\n    /// <summary>\n    /// Merges JSON arrays with base taking precedence in case of conflicts\n    /// </summary>\n    /// <param name=\"baseArray\">Base JSON array</param>\n    /// <param name=\"overrideArray\">Override JSON array</param>\n    /// <returns>Merged JSON array</returns>\n    private JsonArray MergeJsonArrays(JsonArray baseArray, JsonArray overrideArray)\n    {\n        // For arrays, we'll use base array as the result\n        // This behavior could be modified if needed for different array merging strategies\n        return baseArray.DeepClone() as JsonArray ?? new JsonArray();\n    }\n\n    /// <summary>\n    /// Deserializes a JSON string to a strongly typed object\n    /// </summary>\n    /// <typeparam name=\"T\">Type to deserialize to</typeparam>\n    /// <param name=\"json\">JSON string</param>\n    /// <returns>Deserialized object</returns>\n    public T? DeserializeObject<T>(string json)\n    {\n        var options = GetDefaultJsonSerializerOptions();\n        return JsonSerializer.Deserialize<T>(json, options);\n    }\n\n    /// <summary>\n    /// Serializes an object to a JSON string\n    /// </summary>\n    /// <param name=\"obj\">Object to serialize</param>\n    /// <returns>JSON string</returns>\n    public string SerializeObject(object obj)\n    {\n        var options = GetDefaultJsonSerializerOptions();\n        return JsonSerializer.Serialize(obj, options);\n    }\n\n    /// <summary>\n    /// Gets the default JSON serializer options\n    /// </summary>\n    /// <returns>JsonSerializerOptions</returns>\n    private JsonSerializerOptions GetDefaultJsonSerializerOptions()\n    {\n        return new JsonSerializerOptions\n        {\n            PropertyNameCaseInsensitive = true,\n            DefaultIgnoreCondition = JsonIgnoreCondition.WhenWritingNull,\n            WriteIndented = true\n        };\n    }\n}\u0005End File\u0006# maikhaihuy/nox\nusing System.ComponentModel.DataAnnotations;\nusing System.Text.Json;\nusing System.Text.Json.Nodes;\nusing Json.Schema;\nusing Nox.Cli.Abstractions.Exceptions;\nusing Nox.Cli.Abstractions.Helpers;\n\nnamespace Nox.Cli.Helpers.Json;\n\npublic class JsonValidator : IJsonValidator\n{\n    /// <summary>\n    /// Validates a JSON string against a JSON schema\n    /// </summary>\n    /// <param name=\"json\">JSON string to validate</param>\n    /// <param name=\"schema\">JSON schema to validate against</param>\n    /// <returns>True if validation succeeds, false otherwise</returns>\n    public bool Validate(string json, string schema)\n    {\n        try\n        {\n            var jsonDocument = JsonDocument.Parse(json);\n            var jsonSchema = JsonSchema.FromText(schema);\n            \n            var validationResult = jsonSchema.Evaluate(jsonDocument);\n            return validationResult.IsValid;\n        }\n        catch (Exception ex)\n        {\n            throw new JsonValidationException(\"Failed to validate JSON\", ex);\n        }\n    }\n\n    /// <summary>\n    /// Validates a JSON string against a JSON schema file\n    /// </summary>\n    /// <param name=\"json\">JSON string to validate</param>\n    /// <param name=\"schemaPath\">Path to the JSON schema file</param>\n    /// <returns>True if validation succeeds, false otherwise</returns>\n    public bool ValidateAgainstFile(string json, string schemaPath)\n    {\n        try\n        {\n            var schema = File.ReadAllText(schemaPath);\n            return Validate(json, schema);\n        }\n        catch (Exception ex)\n        {\n            throw new JsonValidationException($\"Failed to validate JSON against schema file: {schemaPath}\", ex);\n        }\n    }\n\n    /// <summary>\n    /// Gets detailed validation errors for a JSON string against a JSON schema\n    /// </summary>\n    /// <param name=\"json\">JSON string to validate</param>\n    /// <param name=\"schema\">JSON schema to validate against</param>\n    /// <returns>List of validation errors</returns>\n    public List<string> GetValidationErrors(string json, string schema)\n    {\n        try\n        {\n            var jsonDocument = JsonDocument.Parse(json);\n            var jsonSchema = JsonSchema.FromText(schema);\n            \n            var validationResult = jsonSchema.Evaluate(jsonDocument);\n            \n            if (validationResult.IsValid)\n            {\n                return new List<string>();\n            }\n            \n            return validationResult.Errors\n                .Select(kvp => $\"{kvp.Key}: {kvp.Value}\")\n                .ToList();\n        }\n        catch (Exception ex)\n        {\n            throw new JsonValidationException(\"Failed to validate JSON\", ex);\n        }\n    }\n\n    /// <summary>\n    /// Gets detailed validation errors for a JSON string against a JSON schema file\n    /// </summary>\n    /// <param name=\"json\">JSON string to validate</param>\n    /// <param name=\"schemaPath\">Path to the JSON schema file</param>\n    /// <returns>List of validation errors</returns>\n    public List<string> GetValidationErrorsAgainstFile(string json, string schemaPath)\n    {\n        try\n        {\n            var schema = File.ReadAllText(schemaPath);\n            return GetValidationErrors(json, schema);\n        }\n        catch (Exception ex)\n        {\n            throw new JsonValidationException($\"Failed to validate JSON against schema file: {schemaPath}\", ex);\n        }\n    }\n}\u0005End File\u0006# src/Nox.Cli/Actions/NoxWorkflow.cs\nusing System.Text.Json;\nusing Nox.Cli.Abstractions;\nusing Nox.Cli.Abstractions.Exceptions;\nusing Nox.Cli.Helpers.Json;\nusing Nox.Cli.Helpers.Xml;\nusing Nox.Cli.Variables;\nusing YamlDotNet.Core;\nusing YamlDotNet.Core.Events;\nusing YamlDotNet.Serialization;\n\nnamespace Nox.Cli.Actions;\n\npublic class NoxWorkflow : INoxWorkflow\n{\n    private readonly IVariableDictionary _variables;\n    private readonly Dictionary<string, WorkflowTask> _tasks = new();\n    private readonly Dictionary<string, WorkflowOutput> _outputs = new();\n    private readonly List<ValidationResult> _validationResults = new();\n    private readonly HashSet<string> _processedVariables = new();\n    private readonly bool _isInteractive;\n    private readonly string? _jsonSchemaPath;\n    private readonly string? _yamlSchemaPath;\n    private readonly string _workflowPath;\n    private bool _validateSchema = false;\n    private string? _name;\n    private string? _description;\n    private List<string>? _validationErrors;\n\n    public NoxWorkflow(string workflowPath, \n        IEnumerable<IVariableDictionary> variables, \n        bool isInteractive, \n        string? jsonSchemaPath = null, \n        string? yamlSchemaPath = null)\n    {\n        _workflowPath = workflowPath;\n        _isInteractive = isInteractive;\n        _jsonSchemaPath = jsonSchemaPath;\n        _yamlSchemaPath = yamlSchemaPath;\n        \n        // Create a combined variable dictionary\n        _variables = VariableDictionary.MergeVariableDictionaries(variables);\n        \n        // Load and parse the workflow file\n        LoadWorkflow();\n    }\n\n    public string Name => _name ?? \"Unnamed Workflow\";\n    public string Description => _description ?? string.Empty;\n    \n    private List<string> ValidationErrors => _validationErrors ??= new List<string>();\n    \n    public bool HasValidationErrors => ValidationErrors.Count > 0;\n    \n    public string GetValidationErrorsAsString()\n    {\n        return string.Join(Environment.NewLine, ValidationErrors);\n    }\n    \n    public IReadOnlyDictionary<string, WorkflowTask> Tasks => _tasks;\n    \n    public IReadOnlyDictionary<string, WorkflowOutput> Outputs => _outputs;\n\n    /// <summary>\n    /// Load and parse the workflow file\n    /// </summary>\n    /// <exception cref=\"WorkflowException\"></exception>\n    private void LoadWorkflow()\n    {\n        if (!File.Exists(_workflowPath))\n        {\n            throw new WorkflowException($\"Workflow file not found: {_workflowPath}\");\n        }\n        \n        string workflowContent;\n        \n        try\n        {\n            workflowContent = File.ReadAllText(_workflowPath);\n        }\n        catch (Exception ex)\n        {\n            throw new WorkflowException($\"Failed to read workflow file: {ex.Message}\");\n        }\n        \n        // Check if we need to validate against schema\n        _validateSchema = (!string.IsNullOrEmpty(_jsonSchemaPath) && File.Exists(_jsonSchemaPath)) || \n                          (!string.IsNullOrEmpty(_yamlSchemaPath) && File.Exists(_yamlSchemaPath));\n        \n        if (_validateSchema)\n        {\n            ValidateWorkflowAgainstSchema(workflowContent);\n        }\n        \n        // Process the workflow\n        ParseWorkflow(workflowContent);\n    }\n\n    /// <summary>\n    /// Validate the workflow against a schema\n    /// </summary>\n    /// <param name=\"workflowContent\">Workflow content</param>\n    /// <exception cref=\"WorkflowException\"></exception>\n    private void ValidateWorkflowAgainstSchema(string workflowContent)\n    {\n        // Check if JSON schema validation is needed\n        if (!string.IsNullOrEmpty(_jsonSchemaPath) && File.Exists(_jsonSchemaPath))\n        {\n            try\n            {\n                // Convert YAML to JSON for validation\n                var deserializer = new DeserializerBuilder().Build();\n                var yamlObject = deserializer.Deserialize<object>(workflowContent);\n                \n                var serializer = new JsonHelper();\n                var jsonContent = serializer.SerializeObject(yamlObject);\n                \n                // Validate JSON against schema\n                var validator = new JsonValidator();\n                var isValid = validator.ValidateAgainstFile(jsonContent, _jsonSchemaPath);\n                \n                if (!isValid)\n                {\n                    var errors = validator.GetValidationErrorsAgainstFile(jsonContent, _jsonSchemaPath);\n                    _validationErrors = errors;\n                    throw new WorkflowException($\"Workflow validation failed:{Environment.NewLine}{string.Join(Environment.NewLine, errors)}\");\n                }\n            }\n            catch (YamlException ex)\n            {\n                throw new WorkflowException($\"YAML parsing error: {ex.Message}\");\n            }\n            catch (WorkflowException)\n            {\n                throw; // Re-throw workflow exceptions\n            }\n            catch (Exception ex)\n            {\n                throw new WorkflowException($\"Schema validation error: {ex.Message}\");\n            }\n        }\n        \n        // Check if YAML schema validation is needed\n        if (!string.IsNullOrEmpty(_yamlSchemaPath) && File.Exists(_yamlSchemaPath))\n        {\n            try\n            {\n                // Validate YAML against schema\n                var validator = new XmlValidator();\n                var schemaContent = File.ReadAllText(_yamlSchemaPath);\n                var isValid = validator.ValidateYaml(workflowContent, schemaContent);\n                \n                if (!isValid)\n                {\n                    var errors = validator.GetYamlValidationErrors(workflowContent, schemaContent);\n                    _validationErrors = errors;\n                    throw new WorkflowException($\"Workflow validation failed:{Environment.NewLine}{string.Join(Environment.NewLine, errors)}\");\n                }\n            }\n            catch (Exception ex)\n            {\n                throw new WorkflowException($\"Schema validation error: {ex.Message}\");\n            }\n        }\n    }\n\n    private void ParseWorkflow(string workflowContent)\n    {\n        try\n        {\n            // Deserialize the YAML content\n            var deserializer = new DeserializerBuilder().Build();\n            var yamlObject = deserializer.Deserialize<Dictionary<string, object>>(workflowContent);\n            \n            // Extract workflow metadata\n            if (yamlObject.TryGetValue(\"name\", out var name))\n            {\n                _name = name.ToString();\n            }\n            \n            if (yamlObject.TryGetValue(\"description\", out var description))\n            {\n                _description = description.ToString();\n            }\n            \n            // Extract tasks\n            if (yamlObject.TryGetValue(\"tasks\", out var tasksObj) && tasksObj is Dictionary<object, object> tasksDict)\n            {\n                foreach (var taskEntry in tasksDict)\n                {\n                    var taskId = taskEntry.Key.ToString() ?? string.Empty;\n                    \n                    if (string.IsNullOrEmpty(taskId))\n                    {\n                        _validationResults.Add(ValidationResult.Error(\"Task ID cannot be empty\"));\n                        continue;\n                    }\n                    \n                    if (taskEntry.Value is Dictionary<object, object> taskDict)\n                    {\n                        var task = new WorkflowTask { Id = taskId };\n                        \n                        if (taskDict.TryGetValue(\"action\", out var actionObj))\n                        {\n                            task.Action = actionObj.ToString();\n                        }\n                        \n                        if (taskDict.TryGetValue(\"description\", out var descObj))\n                        {\n                            task.Description = descObj.ToString();\n                        }\n                        \n                        if (taskDict.TryGetValue(\"if\", out var ifObj))\n                        {\n                            task.Condition = ifObj.ToString();\n                        }\n                        \n                        if (taskDict.TryGetValue(\"foreach\", out var forEachObj))\n                        {\n                            task.ForEach = forEachObj.ToString();\n                        }\n                        \n                        if (taskDict.TryGetValue(\"timeout\", out var timeoutObj) && int.TryParse(timeoutObj.ToString(), out var timeout))\n                        {\n                            task.Timeout = timeout;\n                        }\n                        \n                        if (taskDict.TryGetValue(\"continue_on_error\", out var continueOnErrorObj) && bool.TryParse(continueOnErrorObj.ToString(), out var continueOnError))\n                        {\n                            task.ContinueOnError = continueOnError;\n                        }\n                        \n                        if (taskDict.TryGetValue(\"interactive\", out var interactiveObj) && bool.TryParse(interactiveObj.ToString(), out var interactive))\n                        {\n                            task.Interactive = interactive;\n                        }\n                        \n                        if (taskDict.TryGetValue(\"inputs\", out var inputsObj) && inputsObj is Dictionary<object, object> inputsDict)\n                        {\n                            task.Inputs = new Dictionary<string, string>();\n                            \n                            foreach (var inputEntry in inputsDict)\n                            {\n                                var inputKey = inputEntry.Key.ToString() ?? string.Empty;\n                                var inputValue = inputEntry.Value?.ToString() ?? string.Empty;\n                                \n                                if (string.IsNullOrEmpty(inputKey))\n                                {\n                                    _validationResults.Add(ValidationResult.Error($\"Input key cannot be empty in task '{taskId}'\"));\n                                    continue;\n                                }\n                                \n                                task.Inputs[inputKey] = ProcessVariablesInString(inputValue);\n                            }\n                        }\n                        \n                        _tasks[taskId] = task;\n                    }\n                    else\n                    {\n                        _validationResults.Add(ValidationResult.Error($\"Invalid task definition for '{taskId}'\"));\n                    }\n                }\n            }\n            \n            // Extract outputs\n            if (yamlObject.TryGetValue(\"outputs\", out var outputsObj) && outputsObj is Dictionary<object, object> outputsDict)\n            {\n                foreach (var outputEntry in outputsDict)\n                {\n                    var outputId = outputEntry.Key.ToString() ?? string.Empty;\n                    \n                    if (string.IsNullOrEmpty(outputId))\n                    {\n                        _validationResults.Add(ValidationResult.Error(\"Output ID cannot be empty\"));\n                        continue;\n                    }\n                    \n                    if (outputEntry.Value is Dictionary<object, object> outputDict)\n                    {\n                        var output = new WorkflowOutput { Id = outputId };\n                        \n                        if (outputDict.TryGetValue(\"value\", out var valueObj))\n                        {\n                            output.Value = ProcessVariablesInString(valueObj.ToString() ?? string.Empty);\n                        }\n                        \n                        if (outputDict.TryGetValue(\"description\", out var descObj))\n                        {\n                            output.Description = descObj.ToString();\n                        }\n                        \n                        _outputs[outputId] = output;\n                    }\n                    else if (outputEntry.Value != null)\n                    {\n                        // Simple output definition\n                        _outputs[outputId] = new WorkflowOutput\n                        {\n                            Id = outputId,\n                            Value = ProcessVariablesInString(outputEntry.Value.ToString() ?? string.Empty)\n                        };\n                    }\n                    else\n                    {\n                        _validationResults.Add(ValidationResult.Error($\"Invalid output definition for '{outputId}'\"));\n                    }\n                }\n            }\n        }\n        catch (YamlException ex)\n        {\n            // Collect detailed YAML parsing errors\n            var errorDetails = $\"Line {ex.Start.Line}, Column {ex.Start.Column}: {ex.Message}\";\n            _validationResults.Add(ValidationResult.Error($\"YAML parsing error: {errorDetails}\"));\n        }\n        catch (Exception ex)\n        {\n            _validationResults.Add(ValidationResult.Error($\"Failed to parse workflow: {ex.Message}\"));\n        }\n    }\n\n    /// <summary>\n    /// Process variables in a string\n    /// </summary>\n    /// <param name=\"input\">Input string</param>\n    /// <returns>Processed string</returns>\n    private string ProcessVariablesInString(string input)\n    {\n        if (string.IsNullOrEmpty(input))\n        {\n            return input;\n        }\n        \n        // Find all ${...} expressions in the input\n        var startIndex = 0;\n        while ((startIndex = input.IndexOf(\"${\", startIndex)) >= 0)\n        {\n            var endIndex = input.IndexOf(\"}\", startIndex);\n            if (endIndex < 0)\n            {\n                break; // No closing bracket found\n            }\n            \n            var varExpression = input.Substring(startIndex + 2, endIndex - startIndex - 2).Trim();\n            \n            // Add to processed variables set\n            _processedVariables.Add(varExpression);\n            \n            startIndex = endIndex + 1;\n        }\n        \n        return input;\n    }\n    \n    /// <summary>\n    /// Determines if a task requires interactive mode\n    /// </summary>\n    /// <param name=\"task\">The task to check</param>\n    /// <returns>True if the task requires interactive mode</returns>\n    public bool RequiresInteractive(WorkflowTask task)\n    {\n        return task.Interactive && !_isInteractive;\n    }\n}\u0005End File\u0006# maikhaihuy/nox\nusing Nox.Cli.Abstractions;\nusing Nox.Cli.Abstractions.Extensions;\nusing Nox.Cli.Extensions;\nusing Nox.Cli.Plugin;\nusing Spectre.Console;\n\nnamespace Nox.Cli.Actions;\n\npublic class NoxTaskExecutor\n{\n    private readonly IExecutionContextAccessor _executionContextAccessor;\n    private readonly Dictionary<string, object> _stepOutputs = new();\n    private readonly HashSet<string> _completedTasks = new();\n    private readonly Dictionary<string, List<string>> _taskGroups = new();\n    private int _indent = 0;\n    \n    public NoxTaskExecutor(IExecutionContextAccessor executionContextAccessor)\n    {\n        _executionContextAccessor = executionContextAccessor;\n    }\n    \n    private void ResetState()\n    {\n        _stepOutputs.Clear();\n        _completedTasks.Clear();\n        _taskGroups.Clear();\n        _indent = 0;\n    }\n    \n    /// <summary>\n    /// Execute a workflow and all its tasks\n    /// </summary>\n    /// <param name=\"workflow\">The workflow to execute</param>\n    /// <returns>Task result</returns>\n    public async Task<TaskResult> ExecuteWorkflowAsync(INoxWorkflow workflow)\n    {\n        ResetState();\n        \n        try\n        {\n            // Create a new execution context\n            var executionContext = new ExecutionContext();\n            _executionContextAccessor.ExecutionContext = executionContext;\n            \n            // Check for validation errors in the workflow\n            if (workflow.HasValidationErrors)\n            {\n                return TaskResult.FailureResult($\"Workflow validation failed:{Environment.NewLine}{workflow.GetValidationErrorsAsString()}\");\n            }\n            \n            // Execute all tasks in the workflow\n            var result = await ExecuteTasksAsync(workflow, executionContext);\n            if (result.Status == TaskResultStatus.Failed)\n            {\n                return result;\n            }\n            \n            // Process outputs\n            foreach (var output in workflow.Outputs.Values)\n            {\n                var resolvedValue = executionContext.EvaluateExpression(output.Value, _stepOutputs);\n                AnsiConsole.MarkupLine($\"[green]Output[/] [blue]{output.Id}[/]: {resolvedValue}\");\n            }\n            \n            return TaskResult.SuccessResult(\"Workflow completed successfully\");\n        }\n        catch (Exception ex)\n        {\n            return TaskResult.FailureResult($\"Workflow execution failed: {ex.Message}\");\n        }\n    }\n    \n    /// <summary>\n    /// Execute all tasks in the workflow\n    /// </summary>\n    /// <param name=\"workflow\">The workflow to execute</param>\n    /// <param name=\"executionContext\">The execution context</param>\n    /// <returns>Task result</returns>\n    private async Task<TaskResult> ExecuteTasksAsync(INoxWorkflow workflow, ExecutionContext executionContext)\n    {\n        var tasks = workflow.Tasks.Values.ToList();\n        \n        // Group tasks by ID prefix for better logging\n        foreach (var task in tasks)\n        {\n            var parts = task.Id.Split('.');\n            if (parts.Length > 1)\n            {\n                var groupId = parts[0];\n                if (!_taskGroups.ContainsKey(groupId))\n                {\n                    _taskGroups[groupId] = new List<string>();\n                }\n                _taskGroups[groupId].Add(task.Id);\n            }\n        }\n        \n        // Execute tasks in order\n        foreach (var task in tasks)\n        {\n            // Skip tasks that have already been executed (e.g., as part of a foreach loop)\n            if (_completedTasks.Contains(task.Id))\n            {\n                continue;\n            }\n            \n            // Check if this task starts a new group\n            var isGroupStart = IsGroupStart(task.Id);\n            if (isGroupStart)\n            {\n                // Increase indent for this group\n                _indent++;\n            }\n            \n            // Evaluate condition if present\n            var conditionResult = true;\n            if (!string.IsNullOrEmpty(task.Condition))\n            {\n                conditionResult = executionContext.EvaluateCondition(task.Condition, _stepOutputs);\n            }\n            \n            // Skip task if condition is false\n            if (!conditionResult)\n            {\n                LogTaskSkipped(task);\n                continue;\n            }\n            \n            // Check if task requires interactive mode\n            if (workflow.RequiresInteractive(task))\n            {\n                LogTaskInteractive(task);\n                continue;\n            }\n            \n            // Check if task has a foreach loop\n            if (!string.IsNullOrEmpty(task.ForEach))\n            {\n                var result = await ExecuteForEachTaskAsync(workflow, task, executionContext);\n                if (result.Status == TaskResultStatus.Failed && !task.ContinueOnError)\n                {\n                    return result;\n                }\n            }\n            else\n            {\n                // Execute task normally\n                var result = await ExecuteTaskAsync(task, executionContext);\n                \n                // Store task outputs\n                if (result.Status == TaskResultStatus.Success && result.Outputs != null)\n                {\n                    foreach (var (key, value) in result.Outputs)\n                    {\n                        var outputKey = $\"{task.Id}.{key}\";\n                        _stepOutputs[outputKey] = value;\n                    }\n                    \n                    // Also store the raw output under the task ID\n                    _stepOutputs[task.Id] = result.Outputs;\n                }\n                \n                // Mark task as completed\n                _completedTasks.Add(task.Id);\n                \n                // Return failure if task failed and continue_on_error is false\n                if (result.Status == TaskResultStatus.Failed && !task.ContinueOnError)\n                {\n                    return result;\n                }\n            }\n            \n            // Check if this task is the last in its group\n            var isGroupEnd = IsGroupEnd(task.Id);\n            if (isGroupEnd)\n            {\n                // Decrease indent for next tasks\n                _indent--;\n            }\n        }\n        \n        return TaskResult.SuccessResult(\"All tasks completed successfully\");\n    }\n    \n    /// <summary>\n    /// Execute a foreach task\n    /// </summary>\n    /// <param name=\"workflow\">The workflow containing the task</param>\n    /// <param name=\"task\">The task to execute</param>\n    /// <param name=\"executionContext\">The execution context</param>\n    /// <returns>Task result</returns>\n    private async Task<TaskResult> ExecuteForEachTaskAsync(INoxWorkflow workflow, WorkflowTask task, ExecutionContext executionContext)\n    {\n        // Evaluate the foreach expression\n        var items = executionContext.EvaluateForEach(task.ForEach, _stepOutputs);\n        \n        if (items == null || !items.Any())\n        {\n            LogTaskMessage(task, \"[yellow]No items to iterate over[/]\");\n            return TaskResult.SuccessResult(\"No items to iterate over\");\n        }\n        \n        // Log the start of the foreach loop\n        LogTaskMessage(task, $\"[blue]Starting foreach loop with [green]{items.Count}[/] items[/]\");\n        \n        var index = 0;\n        foreach (var item in items)\n        {\n            // Create a context for this iteration\n            var iterationContext = new Dictionary<string, object>\n            {\n                { \"item\", item },\n                { \"index\", index }\n            };\n            \n            // Generate a unique task ID for this iteration\n            var iterationTaskId = $\"{task.Id}.{index}\";\n            \n            // Create a copy of the task for this iteration\n            var iterationTask = new WorkflowTask\n            {\n                Id = iterationTaskId,\n                Action = task.Action,\n                Description = $\"{task.Description} (item {index + 1}/{items.Count})\",\n                Condition = task.Condition,\n                Timeout = task.Timeout,\n                ContinueOnError = task.ContinueOnError,\n                Inputs = task.Inputs != null ? new Dictionary<string, string>(task.Inputs) : new Dictionary<string, string>()\n            };\n            \n            // Process inputs with the iteration context\n            if (iterationTask.Inputs != null)\n            {\n                foreach (var key in iterationTask.Inputs.Keys.ToList())\n                {\n                    var value = iterationTask.Inputs[key];\n                    iterationTask.Inputs[key] = executionContext.EvaluateExpression(value, _stepOutputs, iterationContext);\n                }\n            }\n            \n            // Execute the iteration task\n            var result = await ExecuteTaskAsync(iterationTask, executionContext, iterationContext);\n            \n            // Store task outputs\n            if (result.Status == TaskResultStatus.Success && result.Outputs != null)\n            {\n                foreach (var (key, value) in result.Outputs)\n                {\n                    var outputKey = $\"{iterationTaskId}.{key}\";\n                    _stepOutputs[outputKey] = value;\n                }\n                \n                // Also store the raw output under the task ID\n                _stepOutputs[iterationTaskId] = result.Outputs;\n            }\n            \n            // Mark this iteration as completed\n            _completedTasks.Add(iterationTaskId);\n            \n            // Return failure if iteration failed and continue_on_error is false\n            if (result.Status == TaskResultStatus.Failed && !task.ContinueOnError)\n            {\n                return result;\n            }\n            \n            index++;\n        }\n        \n        // Mark the parent foreach task as completed\n        _completedTasks.Add(task.Id);\n        \n        // Create a combined result for all iterations\n        var combinedOutputs = new Dictionary<string, object>();\n        for (var i = 0; i < items.Count; i++)\n        {\n            var iterationTaskId = $\"{task.Id}.{i}\";\n            if (_stepOutputs.TryGetValue(iterationTaskId, out var output) && output is Dictionary<string, object> outputDict)\n            {\n                combinedOutputs[$\"iteration{i}\"] = outputDict;\n            }\n        }\n        \n        // Store the combined outputs\n        _stepOutputs[task.Id] = combinedOutputs;\n        \n        return TaskResult.SuccessResult(\"Foreach loop completed successfully\");\n    }\n    \n    /// <summary>\n    /// Execute a single task\n    /// </summary>\n    /// <param name=\"task\">The task to execute</param>\n    /// <param name=\"executionContext\">The execution context</param>\n    /// <param name=\"additionalContext\">Additional context variables</param>\n    /// <returns>Task result</returns>\n    private async Task<TaskResult> ExecuteTaskAsync(\n        WorkflowTask task, \n        ExecutionContext executionContext,\n        Dictionary<string, object>? additionalContext = null)\n    {\n        // Log task start\n        LogTaskStart(task);\n        \n        // Resolve and instantiate the action\n        var actionResolver = new ActionResolver(_executionContextAccessor);\n        var pluginResolver = new PluginResolver(_executionContextAccessor);\n        \n        try\n        {\n            // Try to resolve the action\n            NoxCliAction? action;\n            \n            // First try to resolve from plugins\n            action = pluginResolver.ResolvePluginAction(task.Id, null, task, task.Action);\n            \n            // If not found in plugins, try built-in actions\n            if (action == null)\n            {\n                action = actionResolver.ResolveAction(task.Id, null, task, task.Action);\n            }\n            \n            if (action == null)\n            {\n                LogTaskFailed(task, $\"Action '{task.Action}' not found\");\n                return TaskResult.FailureResult($\"Action '{task.Action}' not found\");\n            }\n            \n            // Process inputs with expression evaluation\n            if (task.Inputs != null)\n            {\n                foreach (var key in task.Inputs.Keys.ToList())\n                {\n                    var value = task.Inputs[key];\n                    task.Inputs[key] = executionContext.EvaluateExpression(value, _stepOutputs, additionalContext);\n                }\n            }\n            \n            // Validate the action\n            var validationResult = action.Validate();\n            if (!validationResult.Success)\n            {\n                LogTaskFailed(task, validationResult.Message);\n                return TaskResult.FailureResult(validationResult.Message);\n            }\n            \n            // Execute the action\n            var result = action.Execute();\n            \n            if (result.Status == TaskResultStatus.Success)\n            {\n                LogTaskSuccess(task);\n            }\n            else\n            {\n                LogTaskFailed(task, result.Message);\n            }\n            \n            return result;\n        }\n        catch (Exception ex)\n        {\n            LogTaskFailed(task, ex.Message);\n            return TaskResult.FailureResult(ex.Message);\n        }\n    }\n    \n    #region Logging Methods\n    \n    private void LogTaskStart(WorkflowTask task)\n    {\n        var indentStr = new string(' ', _indent * 2);\n        AnsiConsole.MarkupLine($\"{indentStr}[blue]Task[/] [green]{task.Id}[/]: {task.Description}\");\n    }\n    \n    private void LogTaskSuccess(WorkflowTask task)\n    {\n        var indentStr = new string(' ', _indent * 2);\n        AnsiConsole.MarkupLine($\"{indentStr}[blue]✓[/] [green]{task.Id}[/] completed successfully\");\n    }\n    \n    private void LogTaskFailed(WorkflowTask task, string message)\n    {\n        var indentStr = new string(' ', _indent * 2);\n        AnsiConsole.MarkupLine($\"{indentStr}[red]✗[/] [green]{task.Id}[/] failed: {message}\");\n    }\n    \n    private void LogTaskSkipped(WorkflowTask task)\n    {\n        var indentStr = new string(' ', _indent * 2);\n        AnsiConsole.MarkupLine($\"{indentStr}[yellow]→[/] [green]{task.Id}[/] skipped (condition not met)\");\n    }\n    \n    private void LogTaskInteractive(WorkflowTask task)\n    {\n        var indentStr = new string(' ', _indent * 2);\n        AnsiConsole.MarkupLine($\"{indentStr}[yellow]→[/] [green]{task.Id}[/] skipped (requires interactive mode)\");\n    }\n    \n    private void LogTaskMessage(WorkflowTask task, string message)\n    {\n        var indentStr = new string(' ', _indent * 2);\n        AnsiConsole.MarkupLine($\"{indentStr}[blue]Task[/] [green]{task.Id}[/]: {message}\");\n    }\n    \n    #endregion\n    \n    #region Helper Methods\n    \n    private bool IsGroupStart(string taskId)\n    {\n        var parts = taskId.Split('.');\n        if (parts.Length > 1)\n        {\n            var groupId = parts[0];\n            return _taskGroups.ContainsKey(groupId) && _taskGroups[groupId].First() == taskId;\n        }\n        return false;\n    }\n    \n    private bool IsGroupEnd(string taskId)\n    {\n        var parts = taskId.Split('.');\n        if (parts.Length > 1)\n        {\n            var groupId = parts[0];\n            return _taskGroups.ContainsKey(groupId) && _taskGroups[groupId].Last() == taskId;\n        }\n        return false;\n    }\n    \n    #endregion\n}\u0005End File\u0006# maikhaihuy/nox\n# src/Nox.Cli/Actions/StepConsoleWriter.cs\nusing Nox.Cli.Abstractions;\nusing Spectre.Console;\n\nnamespace Nox.Cli.Actions;\n\n/// <summary>\n/// Console writer for steps\n/// </summary>\npublic class StepConsoleWriter : IStepConsoleWriter\n{\n    private readonly string _stepId;\n    private readonly int _indent = 0;\n    \n    /// <summary>\n    /// Constructor\n    /// </summary>\n    /// <param name=\"stepId\">Step ID</param>\n    public StepConsoleWriter(string stepId)\n    {\n        _stepId = stepId;\n        \n        // Calculate indent based on step ID\n        var parts = stepId.Split('.');\n        _indent = parts.Length - 1;\n        if (_indent < 0) _indent = 0;\n    }\n    \n    /// <summary>\n    /// Write a line to the console\n    /// </summary>\n    /// <param name=\"text\">Text to write</param>\n    public void WriteLine(string text)\n    {\n        var indentStr = new string(' ', _indent * 2);\n        Console.WriteLine($\"{indentStr}{text}\");\n    }\n    \n    /// <summary>\n    /// Write a line with markup to the console\n    /// </summary>\n    /// <param name=\"text\">Text with markup</param>\n    public void WriteMarkupLine(string text)\n    {\n        var indentStr = new string(' ', _indent * 2);\n        AnsiConsole.MarkupLine($\"{indentStr}{text}\");\n    }\n    \n    /// <summary>\n    /// Write a success line to the console\n    /// </summary>\n    /// <param name=\"text\">Text to write</param>\n    public void WriteSuccessLine(string text)\n    {\n        var indentStr = new string(' ', _indent * 2);\n        AnsiConsole.MarkupLine($\"{indentStr}[green]{text}[/]\");\n    }\n    \n    /// <summary>\n    /// Write an error line to the console\n    /// </summary>\n    /// <param name=\"text\">Text to write</param>\n    public void WriteErrorLine(string text)\n    {\n        var indentStr = new string(' ', _indent * 2);\n        AnsiConsole.MarkupLine($\"{indentStr}[red]{text}[/]\");\n    }\n    \n    /// <summary>\n    /// Write a warning line to the console\n    /// </summary>\n    /// <param name=\"text\">Text to write</param>\n    public void WriteWarningLine(string text)\n    {\n        var indentStr = new string(' ', _indent * 2);\n        AnsiConsole.MarkupLine($\"{indentStr}[yellow]{text}[/]\");\n    }\n    \n    /// <summary>\n    /// Write a muted line to the console\n    /// </summary>\n    /// <param name=\"text\">Text to write</param>\n    public void WriteMutedLine(string text)\n    {\n        var indentStr = new string(' ', _indent * 2);\n        AnsiConsole.MarkupLine($\"{indentStr}[grey]{text}[/]\");\n    }\n    \n    /// <summary>\n    /// Write a line with a step prefix to the console\n    /// </summary>\n    /// <param name=\"text\">Text to write</param>\n    public void WriteStepLine(string text)\n    {\n        var indentStr = new string(' ', _indent * 2);\n        AnsiConsole.MarkupLine($\"{indentStr}[blue]Step[/] [green]{_stepId}[/]: {text}\");\n    }\n}\u0005End File\u0006# maikhaihuy/nox\nusing System.Reflection;\nusing Microsoft.Extensions.DependencyInjection;\nusing Nox.Cli.Abstractions;\nusing Nox.Cli.Abstractions.Exceptions;\nusing Nox.Cli.Abstractions.Helpers;\nusing Nox.Cli.Actions.Loaders;\n\nnamespace Nox.Cli.Actions;\n\npublic class ActionResolver : IActionResolver\n{\n    private readonly IExecutionContextAccessor _executionContextAccessor;\n    private readonly Dictionary<string, Type> _actionTypes = new(StringComparer.OrdinalIgnoreCase);\n    \n    public ActionResolver(IExecutionContextAccessor executionContextAccessor)\n    {\n        _executionContextAccessor = executionContextAccessor;\n        LoadActionTypes();\n    }\n    \n    private void LoadActionTypes()\n    {\n        // Get the current assembly\n        var assembly = Assembly.GetExecutingAssembly();\n        \n        // Load all types that implement IAction\n        var actionTypes = assembly.GetTypes()\n            .Where(type => typeof(NoxCliAction).IsAssignableFrom(type) && !type.IsAbstract);\n        \n        foreach (var actionType in actionTypes)\n        {\n            var fullName = actionType.FullName ?? string.Empty;\n            var shortName = actionType.Name;\n            \n            // Add both full name and short name\n            _actionTypes[fullName] = actionType;\n            _actionTypes[shortName] = actionType;\n            \n            // Try to get action name without \"Action\" suffix\n            if (shortName.EndsWith(\"Action\"))\n            {\n                var baseName = shortName.Substring(0, shortName.Length - \"Action\".Length);\n                _actionTypes[baseName] = actionType;\n            }\n        }\n    }\n    \n    /// <summary>\n    /// Resolve an action instance\n    /// </summary>\n    /// <param name=\"taskId\">Task ID</param>\n    /// <param name=\"parentTaskId\">Parent task ID</param>\n    /// <param name=\"task\">Task definition</param>\n    /// <param name=\"actionName\">Action name</param>\n    /// <returns>Action instance</returns>\n    public NoxCliAction? ResolveAction(string taskId, string? parentTaskId, WorkflowTask task, string actionName)\n    {\n        if (!_actionTypes.TryGetValue(actionName, out var actionType))\n        {\n            return null;\n        }\n        \n        return InstantiateAction(actionType, taskId, parentTaskId, task);\n    }\n    \n    /// <summary>\n    /// Get the classification for an action type\n    /// </summary>\n    /// <param name=\"actionType\">Action type</param>\n    /// <returns>Action classification</returns>\n    private TaskClassification GetActionClassification(Type actionType)\n    {\n        // Get classification based on namespace\n        var ns = actionType.Namespace ?? string.Empty;\n        \n        if (ns.Contains(\"Process\"))\n        {\n            return TaskClassification.Process;\n        }\n        \n        if (ns.Contains(\"File\"))\n        {\n            return TaskClassification.File;\n        }\n        \n        if (ns.Contains(\"Api\"))\n        {\n            return TaskClassification.Api;\n        }\n        \n        if (ns.Contains(\"Script\"))\n        {\n            return TaskClassification.Script;\n        }\n        \n        if (ns.Contains(\"Utility\"))\n        {\n            return TaskClassification.Utility;\n        }\n        \n        return TaskClassification.General;\n    }\n    \n    /// <summary>\n    /// Instantiate an action\n    /// </summary>\n    /// <param name=\"actionType\">Action type</param>\n    /// <param name=\"taskId\">Task ID</param>\n    /// <param name=\"parentTaskId\">Parent task ID</param>\n    /// <param name=\"task\">Task definition</param>\n    /// <returns>Action instance</returns>\n    private NoxCliAction InstantiateAction(Type actionType, string taskId, string? parentTaskId, WorkflowTask task)\n    {\n        try\n        {\n            // Get service provider from context\n            var serviceProvider = _executionContextAccessor.ExecutionContext?.ServiceProvider;\n            if (serviceProvider == null)\n            {\n                throw new ActionResolverException(\"Service provider not available in execution context\");\n            }\n            \n            // Get action classification\n            var classification = GetActionClassification(actionType);\n            \n            // Try to resolve services required by the constructor\n            var resolvers = new Dictionary<Type, Func<object>>\n            {\n                { typeof(string), () => taskId },\n                { typeof(string), () => parentTaskId! },\n                { typeof(TaskClassification), () => classification },\n                { typeof(WorkflowTask), () => task },\n                { typeof(ISecretsProvider), () => serviceProvider.GetService<ISecretsProvider>() ?? throw new ActionResolverException($\"Service not available: {nameof(ISecretsProvider)}\") },\n                { typeof(IStepConsoleWriter), () => new StepConsoleWriter(taskId) },\n                { typeof(IExecutionContext), () => _executionContextAccessor.ExecutionContext! }\n            };\n            \n            var constructors = actionType.GetConstructors();\n            if (constructors.Length == 0)\n            {\n                throw new ActionResolverException($\"No public constructors found for action type: {actionType.Name}\");\n            }\n            \n            // Sort by parameter count (descending) to use the most specific constructor\n            var constructor = constructors.OrderByDescending(c => c.GetParameters().Length).First();\n            var parameters = constructor.GetParameters();\n            \n            // Prepare parameter values\n            var parameterValues = new object?[parameters.Length];\n            for (var i = 0; i < parameters.Length; i++)\n            {\n                var parameter = parameters[i];\n                var parameterType = parameter.ParameterType;\n                \n                // Special handling for string parameters\n                if (parameterType == typeof(string))\n                {\n                    if (parameter.Name == \"taskId\")\n                    {\n                        parameterValues[i] = taskId;\n                    }\n                    else if (parameter.Name == \"parentTaskId\")\n                    {\n                        parameterValues[i] = parentTaskId;\n                    }\n                    else\n                    {\n                        parameterValues[i] = null;\n                    }\n                }\n                // Other parameter types\n                else if (parameterType == typeof(TaskClassification))\n                {\n                    parameterValues[i] = classification;\n                }\n                else if (parameterType == typeof(WorkflowTask))\n                {\n                    parameterValues[i] = task;\n                }\n                else\n                {\n                    // Try to get service from service provider\n                    parameterValues[i] = serviceProvider.GetService(parameterType);\n                }\n            }\n            \n            // Create action instance\n            var action = (NoxCliAction)constructor.Invoke(parameterValues);\n            return action;\n        }\n        catch (Exception ex)\n        {\n            throw new ActionResolverException($\"Failed to instantiate action {actionType.Name}: {ex.Message}\", ex);\n        }\n    }\n}\u0005End File\u0006# maikhaihuy/nox\nusing System.Dynamic;\nusing System.Text.RegularExpressions;\nusing Nox.Cli.Abstractions;\nusing Nox.Cli.Abstractions.Exceptions;\nusing Nox.Cli.Extensions;\n\nnamespace Nox.Cli.Actions;\n\npublic class ExecutionContext : IExecutionContext\n{\n    private readonly Regex _expressionRegex = new(@\"\\$\\{([^}]+)\\}\", RegexOptions.Compiled);\n    \n    // Stores outputs from previous steps\n    private readonly Dictionary<string, object> _stepOutputs = new();\n    \n    public ExecutionContext()\n    {\n        ServiceProvider = ServiceProviderHelper.GetServiceProvider();\n    }\n    \n    public IServiceProvider ServiceProvider { get; }\n    \n    /// <summary>\n    /// Evaluate a string expression containing ${...} expressions\n    /// </summary>\n    /// <param name=\"expression\">The expression to evaluate</param>\n    /// <param name=\"stepOutputs\">Dictionary of step outputs</param>\n    /// <param name=\"additionalContext\">Additional context variables</param>\n    /// <returns>The evaluated string</returns>\n    public string EvaluateExpression(string expression, Dictionary<string, object> stepOutputs, Dictionary<string, object>? additionalContext = null)\n    {\n        if (string.IsNullOrEmpty(expression))\n        {\n            return expression;\n        }\n        \n        // Store step outputs for reference in expressions\n        foreach (var (key, value) in stepOutputs)\n        {\n            _stepOutputs[key] = value;\n        }\n        \n        // If the expression is a plain variable reference (e.g., \"${varname}\"), evaluate directly\n        if (_expressionRegex.IsMatch(expression) && expression.Trim().StartsWith(\"${\") && expression.Trim().EndsWith(\"}\"))\n        {\n            var varName = expression.Trim().Substring(2, expression.Trim().Length - 3).Trim();\n            var value = EvaluateVariable(varName, additionalContext);\n            \n            // If the value is null, return empty string to avoid \"null\" literals\n            if (value == null)\n            {\n                return string.Empty;\n            }\n            \n            // Convert to string representation\n            return value.ToString() ?? string.Empty;\n        }\n        \n        // Replace all ${...} expressions in the string\n        return _expressionRegex.Replace(expression, match =>\n        {\n            var varName = match.Groups[1].Value.Trim();\n            var value = EvaluateVariable(varName, additionalContext);\n            \n            // If the value is null, return empty string to avoid \"null\" literals\n            if (value == null)\n            {\n                return string.Empty;\n            }\n            \n            // Convert to string representation\n            return value.ToString() ?? string.Empty;\n        });\n    }\n    \n    /// <summary>\n    /// Evaluate a condition expression\n    /// </summary>\n    /// <param name=\"condition\">The condition to evaluate</param>\n    /// <param name=\"stepOutputs\">Dictionary of step outputs</param>\n    /// <returns>True if the condition evaluates to true, false otherwise</returns>\n    public bool EvaluateCondition(string condition, Dictionary<string, object> stepOutputs)\n    {\n        if (string.IsNullOrEmpty(condition))\n        {\n            return true;\n        }\n        \n        // Store step outputs for reference in expressions\n        foreach (var (key, value) in stepOutputs)\n        {\n            _stepOutputs[key] = value;\n        }\n        \n        // Replace all ${...} expressions in the condition\n        var evaluatedCondition = _expressionRegex.Replace(condition, match =>\n        {\n            var varName = match.Groups[1].Value.Trim();\n            var value = EvaluateVariable(varName);\n            \n            // Convert to string representation\n            return value?.ToString() ?? \"null\";\n        });\n        \n        // Handle simple boolean values\n        if (bool.TryParse(evaluatedCondition, out var boolResult))\n        {\n            return boolResult;\n        }\n        \n        // Handle simple equality checks\n        if (evaluatedCondition.Contains(\"==\"))\n        {\n            var parts = evaluatedCondition.Split(\"==\", 2);\n            var left = parts[0].Trim();\n            var right = parts[1].Trim();\n            \n            // Remove quotes for string comparisons\n            left = RemoveQuotes(left);\n            right = RemoveQuotes(right);\n            \n            return string.Equals(left, right, StringComparison.OrdinalIgnoreCase);\n        }\n        \n        // Handle simple inequality checks\n        if (evaluatedCondition.Contains(\"!=\"))\n        {\n            var parts = evaluatedCondition.Split(\"!=\", 2);\n            var left = parts[0]."
}
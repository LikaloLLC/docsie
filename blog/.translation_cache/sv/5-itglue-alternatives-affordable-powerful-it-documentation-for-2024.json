{
    "__metadata__": {
        "original_categories": [
            "Product Documentation",
            "Product Management",
            "Documentation Portals",
            "Product Updates",
            "Technical Writing"
        ],
        "author_name": "Tal F",
        "author_email": "tal@docsie.io",
        "author_info": "VP of Customer Success @ Docsie",
        "author_image": "https://cdn.docsie.io/workspace_8D5W1pxgb7Jq3oZO7/doc_QpDdxIGnXpT0d02oQ/file_38oWfLzhNu07HmBo8/boo_XGfvRm3TVTFbV6HET/6596307b-9a82-1281-67e8-c73bc6339fcfUntitled_1_min_1_2_3_4_5_6_7_8_9_10_11_12.jpg",
        "header_image": "https://cdn.docsie.io/workspace_PfNzfGj3YfKKtTO4T/doc_QiqgSuNoJpspcExF3/file_jC5jhtdIGA1uDXSu7/banner_45_c5769eaa-cf8b-917a-a613-40e2f50bfc72.jpg",
        "timestamp": "2023-01-07T22:15:51+00:00",
        "status": 1
    },
    "5-itglue-alternatives-affordable-powerfu|title": "5 ITglue-alternativ: Prisvärd och kraftfull IT-dokumentation för 2024",
    "5-itglue-alternatives-affordable-powerfu|summary": "Vi har kategoriserat programvaran baserat på fyra kriterier som är viktigast för MSP:er.",
    "5-itglue-alternatives-affordable-powerfu|markdown": "# ITglue-alternativ: Topp 5 alternativ för MSP:er 2024\n\nTjänsteleverantörer och team behöver en samarbetsplattform för att effektivt spåra enheter, effektivisera arbetsflöden och förbättra samarbete. Även om ITglue har etablerat sig som en pålitlig molnbaserad dokumentationsplattform har flera alternativ dykt upp under de senaste åren.\n\n## Topp 5 ITglue-alternativ för MSP:er\n\n1. Docsie.ai - Bäst för kunskapsdatabashantering\n2. Hudu - Bästa direkta alternativet till ITglue\n3. Confluence - Bäst för stora team och organisationer\n4. IT Portal - Bäst för små team\n5. DokuWiki - Bästa gratisalternativet\n\nDessa ITglue-alternativ tillgodoser olika behov hos små företag och större verksamheter och erbjuder IT-tjänstehanteringslösningar. Vissa erbjuder även fjärrövervakning, kommunikationsplattformar och kommentarsfunktioner, tillsammans med optimerade arbetsflöden.\n\nMen det är inte allt, ITglue-användare har också problem med:\n\n![](https://cdn.docsie.io/workspace_PfNzfGj3YfKKtTO4T/doc_QiqgSuNoJpspcExF3/file_LhlkkZChyPTKTOglF/itglue_users_seek_alternatives_because_c72476d8-711d-bff9-f262-69628e791434.png)\n\nDålig kundsupport\n\n-   Höga kostnader för mindre team\n    \n-   Brist på dokumentationsverktyg\n    \n\nVi har granskat 15 MSP-verktyg och hittat de 5 bästa ITglue-alternativen baserat på dessa kriterier.\n\nHär är vårt utlåtande.\n\n![](https://lh7-us.googleusercontent.com/y8Gt1MD0Hyvh2gqO7iW6cgvUoDYRJSrg2Dt2yr76di0sAlEoWrzQkhXT7zuk5Zi-hzwc8tebMsbaF-Y-ASSUfdmnOn6bKY8sZD_D5hxUfYwkhNgapRxOBh6BVOMpojHlA4wJeiEz9t1NhsVbG_xqXCk)\n\n## Köpguide - Viktigast för MSP:er\n\n![](https://cdn.docsie.io/workspace_PfNzfGj3YfKKtTO4T/doc_QiqgSuNoJpspcExF3/file_nnYHoaSQE6EziPMGg/four_criteria__most_important_for_msps_acbe4771-4ae6-1601-2ec8-9b632cb364fb.png)\n\nVi har kategoriserat programvaran baserat på fyra kriterier som är viktigast för MSP:er.\n\nAnvändarvänlighet: visar hur snabbt du lär dig att använda appen. Om den är för svår att använda eller tar för lång tid att lära sig kommer den att minska teamets produktivitet istället för att förbättra den.\n\nKundservice: problem är oundvikliga när du kopplar ihop många olika appar. Därför är kvaliteten på kundservice en avgörande faktor för många MSP:er.\n\nKunskapsdatabasfunktioner: Kan appen hantera stora kunskapsdatabaser? Erbjuder den redigeringsverktyg för att skapa funktionella dokument? Kan du samarbeta mellan team och tredjepartsappar? Du vill inte byta programvara bara för att upptäcka att den begränsar dig på något sätt.\n\nValuta för pengarna: Kommer verktyget att växa med dig eller behöver du byta igen när du växer? Ett bra verktyg stödjer dig på alla nivåer och introducerar bara funktioner du behöver.\n\n### Är låga poäng alltid dåligt?\n\nInte alls.\n\nTill exempel får ett verktyg med integrerad projekthantering högre värdepoäng eftersom du kommer att ha nytta av det om du inte redan använder en projekthanteringsapp. Men om du redan gör det, lägger dessa funktioner bara till komplexitet, vilket i slutändan minskar värdet.\n\nPå samma sätt kan få funktioner betyda att de befintliga funktionerna håller högre kvalitet. Det är fallet med specialiserade verktyg som Docsie: det kan inte hantera lösenord eller enheter, men det är den bästa kunskapsdatabasplattformen som finns.\n\nPS. Vill du bygga stora kunskapsdatabaser utan att behöva oroa dig för stabilitet, säkerhet eller skalbarhet? Registrera dig för [Docsies Startup-plan](https://www.docsie.io/pricing/) och skapa obegränsad dokumentation – gratis för alltid!\n\n## 1. Docsie.ai - Bästa appen för kunskapsdatabashantering\n\n![](https://lh7-us.googleusercontent.com/KBJr69HeNCohCpeyKp4ffipfCAGtKw2yFFZcm84tbja1ATllKgTCWhbGBRdl_-3V1ivQR7q6vhSYxGa9KMpLpSc-VjmM5ekdDnTxJEvA9RP30Q6exomG8OpOk5lp5_qBZXhxVkGH2FlO_MxSMlPyNds)\n\n### Funktioner och fördelar\n\n[Docsie](https://www.docsie.io/) är det bästa kunskapsdatabashanteringsverktyget som finns.\n\nDet är specialiserat på omfattande IT-dokumentation, datahantering över organisationer och teamsamarbete. Docsie är mycket lätt att installera och kan integreras med vilken teknikstack som helst.\n\nToppfunktioner i Docsie:\n\n● Automatisk översättning\n\n● Anpassning av användargränssnitt\n\n● Publiceringsalternativ\n\n● Kraftfulla redigeringsverktyg\n\n● Dokumentationsanalys\n\n● Driftsättningshantering\n\n● Interaktiva kunskapsportaler\n\n● Intuitiv organisationsstruktur\n\n● Internt och externt samarbete\n\nHär är [ett exempel](https://portals.docsie.io/organization_14776/workspace_14776/welcome-to-docsie-red-beta-snead/welcome-to-docsieio/deployment_EmlWqzYM4A1oC5jcF/?doc=/welcome-to-docsieio/) på Docsies dokumentation publicerad på webben.\n\nDocsies byggstenar är böcker och hyllor.\n\nHyllorna placeras på vänster sida. När du öppnar dem visas en lista med böcker.\n\n![](https://lh7-us.googleusercontent.com/AWeebyHyaQlHzBU2H-UkDdynFNofHzxSupc09DIXNzn5Km0yq4VqZS80kn7R027Laq9fMo2Z1Fp7KmYPJu_5swRT8oitCE81EKpNRqKPV805YJKCi1lc0cx_pRCuCmjOdTdhKWqn9zOHL22eM2aHSg0)\n\nDu kan gruppera böcker i sektioner, precis som i ett riktigt bibliotek.\n\nNär du klickar på en bok kommer du till redigeraren. Här kan du skapa artiklar och till och med översätta dem automatiskt till olika språk. I redigeraren hanterar du också versioner, synlighet och publicering för varje artikel.\n\n![](https://lh7-us.googleusercontent.com/zUxA-hZ1Aah-y3iKMvQXrVQJyrgRcJi3I2rIrdAUxY0-pFbeB-rH4TCwPihXCOTbkHf0MZ2ku10AhTA2cmZcnwwrncwzVYnBMumSPrTmNY5rimY1jKp_kFEp6u0MqHTDgzBlswNNVrIQaMQOL96fH0w)\n\nDu kan bädda in multimediainnehåll i artiklar, vilket gör att du kan skapa alla typer av dokument – interna SOP:er, introduktionsguider och externa wikier eller hjälpcenter. För att behålla säkerheten erbjuder Docsie också robust åtkomstkontroll.\n\nNär det gäller publicering kan du publicera hela hyllor eller enskilda böcker.\n\n**Molnportal**\n\nDu kan använda Docsies moln för att publicera ditt dokument på webben.\n\n![](https://lh7-us.googleusercontent.com/mIfrNqnvSZsFJlyfUn2-pYHp8b2GOv4Z64j2f4ySUwpEZrI-TC0eWHVCD4eWYpxbrnKgwPijb3DPd33AA7OBK1oGquEwycSOAQbMX-S7Z8SRjgutxVvPnIJJ2q4mMvdT9AchC4YhT9jMRrfJidStSLU)\n\nDetta skapar en webblänk som du kan dela med vem du vill.\n\nDet betyder att dina läsare inte behöver ett Docsie-konto för att komma åt dina kunskapsdatabaser.\n\n### Webbinbäddning\n\nDu kan också bädda in en Docsie-kunskapsportal på en befintlig webbplats.\n\nDet betyder att du kan skapa och hantera hjälpcenter, guider, bloggar och produktdokumentation, och göra dem offentliga på din webbplats.\n\nFör att ta reda på hela omfattningen av Docsies funktioner, kolla in vår [Youtube-kanal](https://www.youtube.com/channel/UCnQm591jTzvHwb003Y8e1XA/videos). Vi har massor av videor som förklarar hur det fungerar. Det är så enkelt att du kan lära dig det på en eftermiddag och ha det igång vid dagens slut.\n\n### Prissättning\n\nDocsies \"startup\"-plan är gratis.\n\nDen innehåller alla funktioner du behöver för att skapa och hantera din kunskapsdatabas, så att du kan få en bra uppfattning om hur det fungerar innan du förbinder dig till det. Högre planer har fler funktioner enligt nedan:\n\n![](https://lh7-us.googleusercontent.com/TPoQN4tFdBonDFYlMN_dq34-d3r7LSvdPiN7Wn63fVj-MwlzyFprE8rdsaNW23PtERunsywHHwN8H4ndKbXhFGHv1Qofgad6gJf4abt3JxPmQ9GT_DsVPPpk25uvoI5KleA1LSf2wHBoJTUNH6OM1yk)\n\nDet är värt att nämna att vem som helst kan se de kunskapsdatabaser du skapar, så länge du gör dem offentliga. Det betyder att du inte behöver ett teamkonto för varje användare som vill ha tillgång till dokumenten.\n\n### Summering\n\nDocsie är en dokumentationsspecialist.\n\nOm du vill utöka din teknikstack med en förstklassig kunskapsdatabas... eller om du inte behöver komplexiteten hos en allmän MSP-programvara som ITglue... då är Docsie den bästa lösningen.\n\nTrött på att uppgradera planer för att ditt team ska kunna komma åt dokument? Prova Docsies kunskapsportaler och gör dina dokument tillgängliga för alla! [Registrera dig här](https://app.docsie.io/onboarding/#/account) för att få Docsie gratis!\n\n## 2. Hudu - Bästa direkta alternativet till ITglue\n\n![](https://lh7-us.googleusercontent.com/-B5uKBy2wbIFGt4VALzlZ4_YKUD1S-yBwfVZmAK5P1DKixCxU18iv5o-8MVwsdzKmDgX5K7wv5FAEWPSJXo_To5yPYjYv91Nu9gyl1vrpGyaDBvi3HGrWyeq8fGz5kdbW4umW52qYe0QFOjKj_BluZI)\n\n### Funktioner och fördelar\n\n[Hudu](https://www.hudu.com/) är nykomlingen inom MSP-området som alla pratar om. Det är en direkt konkurrent till ITglue, så det kommer att passa dig perfekt om du är en ITglue-veteran.\n\n**Toppfunktioner i Hudu:**\n\n● Anpassade tillgångar\n\n● Utgångsdatumspårning\n\n● Webbplatsövervakning\n\n● Intelligent rapportering\n\n● Kunskapsbevarande\n\n● Medarbetaransvar\n\n● Fungerar som lösenordsvalv\n\n● Säker informationsdelning\n\n● Inbyggd processhantering\n\nTill skillnad från ITglue är Hudu självhostat, så din datasäkerhet ligger i dina händer istället för hos en tredje part.\n\nEn annan anledning till att Hudu tog marknaden med storm är deras kundservice. Många användare rapporterar snabbare svarstider och bättre problemlösning än vad ITglue erbjuder.\n\n![](https://lh7-us.googleusercontent.com/riN0aS3gmo3Lreu6wCD669X9TU8R01rz7QT8DRW7bCawfm6qaDuwIeMZNP9eXcHMaZhPSiqUNuk8IFmmt_qhkm_be5o1cjk6PnlMzZ-SfC-n4vMrHvQVniokBa6e5IqD3mNAJouh29-9bdQXuarlUlo)\n\nKolla in [denna demo](https://www.youtube.com/watch?v=qzkf25_e-2g&ab_channel=Hudu) om du vill få en bättre känsla för Hudu och dess funktioner.\n\n### Där Hudu kommer till korta\n\nOm du byter från ITglue bör du veta att Hudu inte är lika funktionsrikt. Utvecklingsteamet har dock en snabb lanseringscykel och hinner ikapp snabbt. Särskilt eftersom Hudu lyssnar på kundernas feedback mycket mer än vad ITglue gör.\n\nEn annan sak att tänka på är den nuvarande bristen på en hostingtjänst, som fortfarande är under utveckling.\n\n### Prissättning\n\n[Hudus prissättning](https://www.hudu.com/pricing.html) är enkel.\n\n31 USD/månad för 3 användare + 15 USD/användare/månad för ytterligare användare.\n\nDe erbjuder en 14-dagars gratis provperiod utan installationsavgifter eller kontrakt. Årsplaner kommer med 10 % rabatt.\n\n### Summering\n\nMånga missnöjda ITglue-kunder har strömmat till Hudu sedan det lanserades.\n\nDet är det bästa alternativet om du letar efter ett billigare alternativ till ITglue men inte vill kompromissa med funktionaliteten.\n\nDet är också värt att nämna att jämfört med Docsie är både Hudu och ITglue dyrare, och deras kunskapsdatabas- och dokumentationsfunktioner är inte lika avancerade.\n\n## 3. Confluence - Bäst för stora team och organisationer\n\n![](https://lh7-us.googleusercontent.com/IIgzOFbfwdSYBqW5_5KEK194nUyPD9DO9mn2oSOqiA-P6Buiar_B7ET75pWSavr4AP8gB6dL9nDVpAJPNpIybKdOdliWjEDjei19bjIe60QI4SdVbUOFUPfDBr0d6NUU4b4Q-m7q6jt7KV85hrKq6zw)\n\n### Funktioner och fördelar\n\n[Confluence](https://www.atlassian.com/software/confluence) är ett samarbetsverktyg från Atlassian.\n\nDet låter dig skapa projektplaner, schemalägga uppgifter, skriva mötesanteckningar, diskutera arbete och lämna in projektkrav i en samarbetsmiljö. Det erbjuder också dokumenthantering och skapande av interna wikier. Genom att synkronisera dokument kan du samarbeta online för att skapa dokument.\n\nToppfunktioner i Confluence:\n\n● Analys\n\n● Atlassian-integrationer\n\n● Robust kundsupport\n\n● Obegränsade utrymmen och sidor\n\n● Team- och projekthantering\n\n● Internt och externt samarbete\n\n● Kraftfull behörighetshantering\n\nConfluence hyllas som en stabil produkt och möjliggör enkel integration med agila processer.\n\nHär är [en handledning](https://www.youtube.com/watch?v=IZJmdvoXeQs&ab_channel=RCVAcademy) om du är intresserad av hur Confluence fungerar.\n\n### Där Confluence kommer till korta\n\nConfluence är ett komplext program.\n\nFör nya användare är syntaxen förvirrande och det tar ett tag att lära sig hur man navigerar i programmet. Confluence är också sämst på denna lista när det gäller kunskapsdatabashantering.\n\n### Prissättning\n\nConfluence har en generös gratisversion. Den inkluderar alla väsentliga dokumentationsfunktioner – inklusive obegränsade sidor och utrymmen – för ett team på 10 användare.\n\nConfluence är också den billigaste betalda produkten på denna lista. Det är dock värt att nämna att avancerade funktioner endast är tillgängliga som betalda tillägg som snabbt kan öka kostnaden.\n\n![](https://lh7-us.googleusercontent.com/nAGh9lkA5K9Pp-l8MW7kh-tTz4wwN0FN2LF6vC-xRx5s4eGaSh4zW6aYQ34zb0ce_vL2WZxyRjOJIGW1i_3Xxg71e5qnNO-LMlC5-bIpx6m5kClLuHn78Cxf5-OaUak-Ru0hQ3sZxVrSEvjmIQu9thg)\n\n### Summering\n\nConfluence är ett självklart val om du redan använder andra Atlassian-appar som Jira. Det är också det bästa valet för stora team eftersom basproduktens prisplaner är mycket skalbara.\n\nDen stora nackdelen är de medelmåttiga dokumentationsfunktionerna, som blir krångliga om du hanterar stora kunskapsdatabaser.\n\nOm du letar efter ett kraftfullt kunskapsdatabashanteringsverktyg, kolla in [Docsie.io](https://www.docsie.io/) och prova det gratis så länge du vill!\n\n## 4. IT Portal - Bäst för små team\n\n![](https://lh7-us.googleusercontent.com/aIOX2wu2Cx0fqSHg6SjLJGkbBcXiHyQSoeAPsnqDZePBzQmj6Up4TCQ_9-Cp39FDD0mnjErPaZ84fs9YTfbgsD7gSVLEUJS0-c1AqHbWhkKpV48d_dmHbmXDjOk-7HKgoWuaQYH8xB6qwLCV3QMlkYY)\n\n### Funktioner och fördelar\n\n[IT Portal](https://www.it-portal.com/v4/) är en flexibel programvara för tillgångshantering. Du kan använda den för att hålla koll på kunskapsdatabaser, dokument, lösenord, personer och konfigurationer som kan köras i deras moln eller ditt eget.\n\nJämfört med ITglue är IT Portal enklare att använda och mer anpassningsbar. Den är responsiv, snabb och stabil. All information är tillgänglig via webbläsartillägget.\n\nAnmärkningsvärda IT Portal-funktioner:\n\n● Mobilapp\n\n● Resultattavla\n\n● Portalexport\n\n● Enhetsimport\n\n● Nätverksimport\n\n● Integrerade filredigerare\n\n● Lösenordshanterare och webbläsartillägg\n\nIT Portal är känt för att ha bättre kundsupport än ITglue: snabba att svara och snabba att agera.\n\nIntegrationsfunktionen är också imponerande. Den integreras med olika vanliga programvaror som RMM, Office365, ärendehantering etc., vilket ytterligare berikar värdet av din teknikstack.\n\n### Där IT Portal kommer till korta\n\nNär det gäller funktioner är båda produkterna mycket lika. Men IT Portals användargränssnitt är krångligt och känns föråldrat jämfört med ITglue.\n\n### Prissättning\n\nIT Portal prissätts per antal användare – ju fler användare, desto mindre per användare behöver du betala.\n\n![](https://lh7-us.googleusercontent.com/68IdffOwqEnqtVAxL7yPkQKSEY3eRCmXrbOwH574nSRHlGjSD0zki9nrjzjOCZWvyux8ZRDoeM_86EbiToAMJOLCh_-Dx_nCNf5i2-v7BVdnKESz8pgFKvhrNisZeK165A-yFF85CEWoK2lLayGe0sw)\n\nDe erbjuder också hosting på plats.\n\n![](https://lh7-us.googleusercontent.com/pkT_e1dNPXZZux_hDBrsabtiFeKq70aGnpbyHM5dfMnfL2lHpBKR90EBAZjn38lNBx4edUWQ_unwsUub_TRYUwq9Ygz1lbS1IfkhZ-5zF7ExdN653slCd1tS1cdDrZfFLFFJEiBlKZJwrg1ajwsOaVI)\n\nOm du köper en årsplan erbjuder de 10 % rabatt för upp till 9 användare och 20 % rabatt över det.\n\nDe erbjuder också en 30-dagars pengarna-tillbaka-garanti om du vill testa det.\n\n### Summering\n\nIT Portal är ett billigt alternativ till ITglue för små team, men kostnaderna ökar snabbt för större team om du inte hostar det själv. Det är ett bra ITglue-alternativ om det föråldrade användargränssnittet inte stör dig.\n\nJämfört med Hudu: Om priset är en viktig faktor för dig, välj Hudu. Annars – om du inte bryr dig om användargränssnittet – handlar det om integrationerna. Vi rekommenderar att du tittar på vilka integrationer du vill ha och väljer baserat på det.\n\n## 5. DokuWiki - Bästa gratisalternativet\n\n![](https://lh7-us.googleusercontent.com/EF3oNfhArZ1xOSR3yOTzcL90kjj_kTgurUjlNb8WQtatcJmzvifYrADZYpuGRzJaNrXCzBxKwLEmk4949ET9_oACELqZ7koCxez51upAIKM_oU3DO0p8oVOEbsEYGkGgfTS25W1KWkjh3c0uYi1ZHwQ)\n\n### Funktioner och fördelar\n\n[DokuWiki](https://www.dokuwiki.org/dokuwiki) är en enkel att använda och mångsidig wiki-programvara med öppen källkod.\n\nDen har en ren och lättläst syntax. Som namnet antyder är DokuWiki gjord för dokumentation, manualer och beskrivningar. Det är möjligt att skapa snyggt formaterad och lättläst dokumentation med dess redigeringsverktyg.\n\nAnmärkningsvärda DokuWiki-funktioner:\n\n● Säkerhetskopiering och integration\n\n● Inbyggd åtkomstkontroll\n\n● Versionskontroll\n\n● Autentiseringsanslutningar\n\n● Integreras med din webbplats\n\nDokuWiki låter dig skapa egna eller gemenskapsskapade plugins för att lägga till vilken funktion du vill. De många plugins som bidragits av dess gemenskap möjliggör ett brett spektrum av användningsområden utöver dem i en typisk wiki.\n\n### Där DokuWiki kommer till korta\n\nDokuWiki släpptes 2004 och har inte uppdaterats sedan dess.\n\nPå grund av det ser den inte lika ren ut som moderna appar. Den har också säkerhetsrisker som kan minskas med rätt nätverksåtkomstkonfiguration.\n\nDe ursprungliga skaparna erbjuder inte heller någon officiell kundsupport, även om många organisationer erbjuder [officiellt erkända tredjepartssupporttjänster](https://www.dokuwiki.org/faq:support) i DokuWikis ekosystem.\n\n### Prissättning\n\nDokuWiki är gratis.\n\n### Summering\n\nDokuWiki är ett bra val om du är okej med det äldre utseendet och inte har någon budget att lägga på andra alternativ. Säkerhet är dock ett problem, så det är klokt att uppgradera till ett betalt verktyg när ditt företag växer.\n\nOm du letar efter ett toppmodernt kunskapsdatabasverktyg som erbjuder förstklassig säkerhet och tillgänglighet är Docsie.io den perfekta samarbetsmiljön. Registrera dig för gratisversionen [här!](https://www.docsie.io/pricing/)\n\n## Slutligt utlåtande: Vilket ITglue-alternativ bör du välja?\n\nDet kommer att vara olika för varje team eller MSP, men alla produkter erbjuder en gratis provperiod som låter dig testa vad som är bäst för dig utan risk.\n\nMen om du frågar oss, om du letar efter ett:\n\nkraftfullt databashanteringsverktyg som inte motarbetar dig: [Docsie.io](https://www.docsie.io/),\n\nbilligare ITglue-alternativ med bättre kundsupport: [Hudu](https://www.hudu.com/),\n\ngratis databasalternativ: [DokuWiki](https://www.dokuwiki.org/dokuwiki).\n\n**Vanliga frågor**\n\n**1. Varför bör du överväga att byta till alternativ från ITglue?**\n\n**Svar**: Tjänsteleverantörer och team kan söka alternativ till ITglue av olika skäl, såsom dålig kundsupport, höga kostnader för mindre team och brist på specifika dokumentationsverktyg. Att utforska alternativa lösningar för deras behov kan leda till förbättrat samarbete, arbetsflöden och IT-tjänstehantering.\n\n**2. Vilka kriterier användes för att granska och välja de bästa ITglue-alternativen?**\n\n**Svar**: Urvalet av de bästa ITglue-alternativen baserades på fyra nyckelkriterier som är avgörande för Managed Service Providers (MSP:er): användarvänlighet, kvalitet på kundservice, kunskapsdatabasfunktioner och valuta för pengarna. Varje alternativ utvärderades mot dessa kriterier för att säkerställa att det uppfyllde tjänsteleverantörers och teams krav.\n\n**3. Hur hanterar dessa alternativ vanliga utmaningar som ITglue-användare möter?**\n\n**Svar**: Förutom att erbjuda funktioner som fjärrövervakning, kommunikationsplattformar och optimerade arbetsflöden, hanterar de granskade alternativen utmaningar som ITglue-användare upplever, inklusive dålig kundsupport, höga kostnader för mindre team och brist på dokumentationsverktyg. Alternativen syftar till att ge omfattande lösningar på dessa problem.\n\n**4. Är låga poäng alltid negativa i köpguiden?**\n\n**Svar**: Nej, låga poäng i köpguiden indikerar inte nödvändigtvis en negativ aspekt. Till exempel kan ett verktyg med integrerad projekthantering få en högre värdepoäng, men det beror på teamets specifika behov. Låga poäng kan helt enkelt framhäva att vissa funktioner inte är relevanta för ett specifikt användningsfall.\n\n**5. Hur kan användare avgöra vilket alternativ som passar bäst för deras behov?**\n\n**Svar**: Att välja det bästa alternativet beror på de unika kraven hos teamet eller MSP:n. De vanliga frågorna ger insikter om varje alternativs styrkor, såsom Docsie.ios specialisering inom kunskapsdatabashantering, Hudus direkta konkurrens med ITglue, Confluences lämplighet för stora team, IT Portals flexibilitet för små team och DokuWiki som ett gratisalternativ. Team uppmuntras att utforska gratis provperioder för att testa och identifiera det mest lämpliga alternativet för deras specifika behov.",
    "5-itglue-alternatives-affordable-powerfu|category|0": "Produktdokumentation\n\u0005End File\u0006# ericmelz/gemini-claude-chat-comparison\nHuman: Describe a step-by-step process for making traditional French baguettes at home, including ingredients, techniques, and timings.\n\nClaude Sonnet 3.5: # How to Make Traditional French Baguettes at Home\n\n## Ingredients\n- 500g (4 cups) bread flour or all-purpose flour\n- 10g (2 teaspoons) salt\n- 7g (2¼ teaspoons) active dry yeast or 5g instant yeast\n- 350-375ml (1½ cups) cool water\n- Cornmeal or semolina for dusting\n\n## Equipment\n- Large mixing bowl\n- Dough scraper\n- Baking stone or sheet pan\n- Kitchen towels\n- Spray bottle with water\n- Sharp knife or razor blade for scoring\n- Optional: stand mixer with dough hook\n\n## Day 1: Making the Dough (Evening)\n\n1. **Activate the yeast** (skip if using instant yeast)\n   - In a small bowl, mix the yeast with 50ml of the water (lukewarm, about 100°F/38°C)\n   - Let stand for 5-10 minutes until foamy\n\n2. **Mix the dry ingredients**\n   - In a large bowl, whisk together the flour and salt\n\n3. **Form the dough**\n   - Make a well in the center of the flour mixture\n   - Add the yeast mixture and remaining water\n   - Mix with your hands or a wooden spoon until no dry flour remains\n   - The dough will be quite sticky at this stage\n\n4. **Initial kneading (10 minutes)**\n   - Turn dough onto a lightly floured surface\n   - Knead for about 10 minutes until smooth and elastic\n   - If using a stand mixer: mix on low speed for 3 minutes, then medium speed for 5 minutes\n\n5. **First rise (1-2 hours)**\n   - Place the dough in a lightly oiled bowl\n   - Cover with plastic wrap or a damp towel\n   - Let rise at room temperature until doubled in size (about 1-2 hours)\n\n6. **Refrigerate overnight (8-12 hours)**\n   - Gently deflate the dough by folding it onto itself a few times\n   - Return to the bowl, cover, and refrigerate overnight\n   - This slow fermentation develops flavor and texture\n\n## Day 2: Shaping and Baking\n\n1. **Remove dough from refrigerator (1 hour before shaping)**\n   - Let the dough sit at room temperature for about an hour\n\n2. **Divide the dough**\n   - Turn the dough onto a lightly floured surface\n   - Divide into 3 equal pieces (about 250-300g each)\n   - Shape each piece into a rough rectangle\n\n3. **Pre-shape the baguettes**\n   - Gently stretch each piece into a rectangle (about 6×4 inches)\n   - Fold the top third down to the center, press lightly to seal\n   - Fold the bottom third up over the top, press lightly to seal\n   - Let rest, covered with a towel, for 15-20 minutes\n\n4. **Final shaping**\n   - Working with one piece at a time, flip the dough over (seam-side up)\n   - Gently stretch to about 12 inches long\n   - Fold in half lengthwise and seal the edges with the heel of your hand\n   - Roll and stretch the dough with both hands, moving from the center outward\n   - Continue until you reach about 14-16 inches in length\n   - The ends should be slightly tapered\n\n5. **Final proofing (45-60 minutes)**\n   - Place baguettes on a towel-lined baking sheet or in a baguette pan\n   - Create folds in the towel to support each baguette's shape\n   - Cover with another towel and let rise until puffy (45-60 minutes)\n\n6. **Preheat the oven (30 minutes before baking)**\n   - Place a baking stone or inverted baking sheet on the middle rack\n   - Place an empty metal pan on the bottom rack (for creating steam)\n   - Preheat to 475°F (245°C) for at least 30 minutes\n\n7. **Transfer and score**\n   - Dust a peel or parchment paper with cornmeal or semolina\n   - Carefully transfer the baguettes to the peel or parchment\n   - Using a sharp knife or razor blade, make 3-5 diagonal cuts along each baguette\n   - The cuts should be about ¼ inch deep at a 45-degree angle\n\n8. **Baking (20-25 minutes)**\n   - Slide the baguettes onto the preheated stone/sheet\n   - Pour 1 cup of hot water into the empty pan to create steam\n   - Spray the oven walls with water using a spray bottle\n   - Close the oven door quickly to trap steam\n   - After 5 minutes, spray the oven walls again\n   - Bake for a total of 20-25 minutes, until deeply golden\n\n9. **Cooling (at least 30 minutes)**\n   - Transfer baguettes to a wire rack\n   - Allow to cool for at least 30 minutes before slicing\n   - They should sound hollow when tapped on the bottom\n\n## Tips for Success\n\n- **Hydration**: French baguettes typically have high hydration (70-75%). The dough will be sticky but yields an open crumb.\n- **Temperature matters**: Cool water slows fermentation, developing better flavor.\n- **Steam is crucial**: It keeps the crust from hardening too quickly, allowing proper rise and creating that classic crispy crust.\n- **Practice makes perfect**: Shaping baguettes takes practice. Don't be discouraged if your first attempts aren't perfect.\n- **Flour quality**: For authentic results, use French-style flour (T55) if available, or bread flour.\n\nEnjoy your homemade French baguettes with butter, as sandwich bread, or simply torn and enjoyed with your favorite meals!",
    "5-itglue-alternatives-affordable-powerfu|category|1": "Produkthantering",
    "5-itglue-alternatives-affordable-powerfu|category|2": "Dokumentationsportaler",
    "5-itglue-alternatives-affordable-powerfu|category|3": "Produktuppdateringar\n\u0000# docs/src/main/tut/docs/algebra/typeclasses/foldable.md\n---\nlayout: docs\ntitle:  \"Foldable\"\nnumber: 8\nsource: \"shared/src/main/scala/cats/Foldable.scala\"\nscaladoc: \"#cats.Foldable\"\n---\n# Foldable\n\nFoldable type class instances can be defined for data structures that can be \nfolded to a summary value.\n\nIn the case of a collection (such as `List` or `Vector`), these methods will fold\ntogether (combine) the values contained in the collection to produce a single \nresult. Most collection types have `foldLeft` methods, which will usually be \nused by the associated `Foldable[_]` instance.\n\n`Foldable[F]` is implemented in terms of two basic methods:\n\n - `foldLeft(fa, b)(f)` eagerly folds `fa` from left-to-right.\n - `foldRight(fa, b)(f)` lazily folds `fa` from right-to-left.\n \nThis type class is useful when you want to use a data structure for folding over\nvalues. For example, with a `List[A]` you know you can fold over it (i.e. walk\nthrough it and fold(combine) the values in some way), whereas you can't fold\nover arbitrary types.\n\nThe advantage of using the `Foldable` abstraction is that your code is\nthen decoupled from the data structure used to contain the values, and \nthus your code can be used with any data structure that provides evidence\nof having a `Foldable` instance.\n\nMany data structures in Cats implement `Foldable`. If you are implementing a data\nstructure, and can implement `foldLeft` and `foldRight`, then you can mix\nin the `Foldable` trait for your structure, and get all of the\nfolding functions defined for free.\n\n```tut:silent\nimport cats._\nimport cats.implicits._\n```\n\nHere's what `Foldable` looks like for the built-in `List` collection:\n\n```tut:book\nval list = List(1, 2, 3)\nval sum: Int = list.foldLeft(0)(_ + _)\nval sum3: Int = Foldable[List].fold(List(1, 2, 3))\nval sumWithFoldr: Int = list.foldRight(0)(_ + _)\n```\n\nThat's not very interesting. But things get more interesting when we have a higher order type constructor like:\n\n```tut:book\nval ints = List(Vector(1, 2, 3), Vector(4, 5, 6))\n```\n\nLists and Vectors are both foldable, but we need to choose which Foldable instance we want to use:\n\n```tut:book\nval sum1: Int = ints.foldLeft(0)(_ + _.foldLeft(0)(_ + _))\nval sum2: Int = Foldable[List].foldLeft(ints, 0) { (sum, vec) =>\n  sum + Foldable[Vector].foldLeft(vec, 0)(_ + _)\n}\nval sum3: Int = (Foldable[List] compose Foldable[Vector]).foldLeft(ints, 0)(_ + _)\n```\n\nIn many cases, we can define more specific instances for more efficient\nfolding. For example, if we define a `Foldable` instance for `Option`,\nwe can do:\n\n```tut:book\nFoldable[Option].foldLeft(Some(1), 10)(_ * _)\nFoldable[Option].foldLeft(None, 10)(_ * _)\n```\n\nAnd for deeper nested folds:\n\n```tut:book\nval listOption = List(Some(1), None, Some(2))\n(Foldable[List] compose Foldable[Option]).fold(listOption)\n```\n\n`Foldable` is also tie in with `Eval` to provide lazy evaluation, and stack safety, \nas needed. Let's see that in action:\n\n```tut:book\nimport cats.Eval\nval lazyResult = Foldable[List].foldRight(list, Eval.now(0)) { (num, eval) =>\n  eval.map(_ + num)\n}\nlazyResult.value\n```\n\n## Using Foldable\n\nWe can use `Foldable` in several ways, including:\n\n - `fold` works like `foldLeft` except it uses the `Monoid` associated with the type contained\n    in the structure to combine elements. This allows to reduce the structure using the\n    `empty` and `combine` operations of the monoid.\n \n```tut:book\nFoldable[List].fold(List(\"a\", \"b\", \"c\"))\nFoldable[List].fold(List(1, 2, 3))\nFoldable[List].fold(List(true, false, true))\n```\n\n - `foldMap` is similar to `fold` but maps every `A` value into `B` and then \n   combines them using the given `Monoid[B]` instance.\n \n```tut:book\nFoldable[List].foldMap(List(1, 2, 3))(_.toString)\n```\n\n - `foldK` is similar to `fold` but uses the `MonoidK[G]` instance instead of the `Monoid[A]`.\n   Recall that `MonoidK` operates on type constructors of one parameter\n   (such as `F[_]`) rather than the values contained in the structure.\n \n```tut:book\nFoldable[List].foldK(List(List(1, 2), List(3, 4, 5)))\nFoldable[List].foldK(List(Option(1), Option(2), Option(3)))\nFoldable[List].foldK(List(None, Option(2), Option(3)))\n```\n\n - `find` enables us to check a predicate against the elements inside the structure\n   and to find the first element matching it. \n \n```tut:book\nFoldable[List].find(List(1, 2, 3))(_ > 2)\nFoldable[List].find(List(1, 2, 3))(_ > 5)\n```\n\n - `exists` checks whether at least one element satisfies the predicate.\n \n```tut:book\nFoldable[List].exists(List(1, 2, 3))(_ > 2)\nFoldable[List].exists(List(1, 2, 3))(_ > 5)\n```\n\n - `forall` checks whether all elements satisfy the predicate.\n \n```tut:book\nFoldable[List].forall(List(1, 2, 3))(_ > 0)\nFoldable[List].forall(List(1, 2, 3))(_ > 2)\n```\n\n - `toList` converts the structure to a list.\n \n```tut:book\nFoldable[List].toList(List(1, 2, 3))\nFoldable[Option].toList(Option(42))\nFoldable[Option].toList(None)\n```\n\n - `filter_` convert a `F[A]` value to a `List[A]`, filtering out any elements\n that don't satisfy a predicate.\n \n```tut:book\nFoldable[List].filter_(List(1, 2, 3))(_ < 3)\nFoldable[Option].filter_(Option(42))(_ != 42)\n```\n\n - `isEmpty` checks whether the structure is empty.\n \n```tut:book\nFoldable[List].isEmpty(List(1, 2))\nFoldable[Option].isEmpty(None)\n```\n\n - `nonEmpty` checks whether the structure is not empty.\n \n```tut:book\nFoldable[List].nonEmpty(List(1, 2))\nFoldable[Option].nonEmpty(None)\n```\n \n - `intercalate` inserts an element between adjacent elements of a structure, and\n    combines them using a `Monoid`.\n \n```tut:book\nFoldable[List].intercalate(List(\"a\", \"b\", \"c\"), \"-\")\nFoldable[List].intercalate(List(1, 2, 3), 0)\n```\n\nAnd many more:\n\n```tut:book\nFoldable[List].combineAll(List(1, 2, 3))\nFoldable[List].combineAll(List(\"a\", \"b\", \"c\"))\nFoldable[List].combineAll(List(true, false, true))\n```\n\nAll of these different implementations of `Foldable` operations are optimized for \nthe underlying structure. Therefore when implementing `Foldable`, you can focus \non just implementing the key methods (`foldLeft` and `foldRight`) and get the rest \nfor free.\n\u0000# qlik-oss/qlik-modifiers\n# src/aggregation/accumulation.js\n/**\n * Accumulation calculation\n * @module\n * @param {object} layout - The layout object from the generic object\n * @param {object} properties - The generic object properties\n * @param {object} field - The properties for this aggregation\n * @param {object} dimensionAndFieldList - List of dimensions and fields used by the hypercube\n * @param {object} aggr - Definition of the aggregation\n * @param {object} dataPages - QDataPages from the hypercube\n * @returns {object} The result of the calculation\n */\n\nimport extend from 'extend';\nimport accumulation from './accumulation/accumulation';\n\nconst INCLUDE_NULL = 1;\nconst SORT_ASCENDING = 1;\n\n/**\n * Add entries to dimensionAndFieldList that are required for accumulation to work.\n * 1. Find the dimension by label\n * 2. If sortcriterias is a field expression, add it\n * 3. If sortcriterias is a measure label, it already exists\n * @param {object} dimensionAndFieldList\n * @param {array} dimensions\n * @param {object} field\n * @param {object} hypercubeProperties\n */\nfunction addDimensionAndFields(dimensionAndFieldList, dimensions, field, hypercubeProperties) {\n  let measureIndex;\n  let dimension;\n  dimensions.forEach((dim, i) => {\n    // Find dimension by label\n    if (dim.qFallbackTitle === field.primaryDimension) {\n      dimension = dim;\n      dimensionAndFieldList.dimensions.push({\n        index: i,\n        label: dimension.qFallbackTitle\n      });\n    }\n    // Get measure index if that's what we're sorting by\n    if (dim.qFallbackTitle === field.sortByLabel) {\n      measureIndex = i;\n    }\n  });\n  // We want to sort by the field\n  if (field.sortByExpression && field.sortByExpression !== '') {\n    dimensionAndFieldList.fields.push({\n      isDimension: false,\n      qDef: {\n        qDef: field.sortByExpression,\n        qLabel: field.sortByLabel\n      }\n    });\n  } else if (measureIndex === undefined) {\n    // If it's not a field expression and we didn't find it in dimensions we might need to\n    // find it in measures to make sure it's calculated\n    (hypercubeProperties.qMeasures || []).forEach((measure, i) => {\n      if (measure.qDef.qLabel === field.sortByLabel) {\n        measureIndex = dimensions.length + i;\n      }\n    });\n  }\n  if (measureIndex !== undefined) {\n    dimensionAndFieldList.measureIndex = measureIndex;\n  }\n}\n\nfunction setPrimaryDimension(aggr, field, dimensions) {\n  if (aggr.qDef.primaryDimension) {\n    field.primaryDimension = aggr.qDef.primaryDimension; // eslint-disable-line no-param-reassign\n  } else {\n    field.primaryDimension = dimensions.length > 0 ? dimensions[0].qFallbackTitle : undefined; // eslint-disable-line no-param-reassign\n  }\n}\n\nfunction getSortByDef(aggr, field, layout) {\n  if (aggr.qDef.sortBy && aggr.qDef.sortBy.sortByDimension && aggr.qDef.sortBy.sortByExpression) {\n    // We have a dimension set to sort by and also an expression. Set both\n    field.sortByLabel = aggr.qDef.sortBy.sortByDimension; // eslint-disable-line no-param-reassign\n    field.sortByExpression = aggr.qDef.sortBy.sortByExpression; // eslint-disable-line no-param-reassign\n  } else if (aggr.qDef.sortBy && aggr.qDef.sortBy.sortByDimension && !aggr.qDef.sortBy.sortByExpression) {\n    // We have dimension to sort by. If the dimension exists in the hypercube, we should use it. Otherwise we need\n    // to add the field to dimensionAndFieldList\n    field.sortByLabel = aggr.qDef.sortBy.sortByDimension; // eslint-disable-line no-param-reassign\n    // Find the dimension to sort by. If it doesn't exist we need to calculate it\n    let sortByDimensionExists = false;\n    const dimensions = layout.qHyperCube.qDimensionInfo;\n    dimensions.forEach((dimension) => {\n      if (dimension.qFallbackTitle === field.sortByLabel) {\n        sortByDimensionExists = true;\n      }\n    });\n    if (!sortByDimensionExists) {\n      layout.qHyperCube.qMeasureInfo.forEach((measure) => {\n        if (measure.qFallbackTitle === field.sortByLabel) {\n          sortByDimensionExists = true;\n        }\n      });\n    }\n    if (!sortByDimensionExists) {\n      // We need to add a field expression that does a concatenate to extract this dimension\n      field.sortByExpression = `Concat(Distinct {<$Field={'${field.sortByLabel}'}>} $Field)`; // eslint-disable-line no-param-reassign\n    }\n  } else if (aggr.qDef.sortBy && aggr.qDef.sortBy.sortByExpression) {\n    // We have just an expression, add it and use that as a label as well\n    field.sortByLabel = 'sortByExpression'; // eslint-disable-line no-param-reassign\n    field.sortByExpression = aggr.qDef.sortBy.sortByExpression; // eslint-disable-line no-param-reassign\n  } else {\n    // Default to the first measure\n    field.sortByLabel = layout.qHyperCube.qMeasureInfo.length > 0 ? layout.qHyperCube.qMeasureInfo[0].qFallbackTitle : undefined; // eslint-disable-line no-param-reassign\n  }\n}\n\n/**\n * Get the properties for a crosstable with primaryDimension and the value to sort by\n * @param {object} field\n * @param {object} dimensionAndFieldList\n * @returns\n */\nfunction getCrossTableProperties(field, dimensionAndFieldList) {\n  const crossPropsDef = {\n    qDimensions: [],\n    qMeasures: [],\n    qInterColumnSortOrder: [0],\n    qSuppressZero: true,\n    qSuppressMissing: true\n  };\n  // Add primary dimension\n  dimensionAndFieldList.dimensions.forEach((dimension) => {\n    if (dimension.label === field.primaryDimension) {\n      crossPropsDef.qDimensions.push({\n        qLibraryId: '',\n        qDef: {\n          qGrouping: 'N',\n          qFieldDefs: [''],\n          qFieldLabels: ['']\n        },\n        qNullSuppression: true\n      });\n    }\n  });\n  // Add field\n  if (field.sortByExpression) {\n    crossPropsDef.qMeasures.push({\n      qDef: {\n        qDef: field.sortByExpression,\n        qLabel: field.sortByLabel\n      },\n      qSortBy: {\n        qSortByNumeric: SORT_ASCENDING\n      }\n    });\n  } else {\n    // Find the measure\n    dimensionAndFieldList.measures.forEach((measure) => {\n      if (measure.label === field.sortByLabel) {\n        crossPropsDef.qMeasures.push({\n          qDef: {\n            qDef: measure.qDef,\n            qLabel: measure.label\n          },\n          qSortBy: {\n            qSortByNumeric: SORT_ASCENDING\n          }\n        });\n      }\n    });\n  }\n  return crossPropsDef;\n}\n\n/**\n * When the field to sort by is not part of the hypercube, create a session object for it\n * @param {object} def\n * @param {object} app\n * @returns {Promise}\n */\nfunction getSortByDataFromHyperCube(def, app) {\n  return new Promise((resolve, reject) => {\n    app.createSessionObject(def).then((obj) => {\n      const requestPage = [{\n        qTop: 0,\n        qLeft: 0,\n        qWidth: 2,\n        qHeight: 1000\n      }];\n      obj.getHyperCubeData('/qHyperCubeDef', requestPage).then((pages) => {\n        resolve(pages);\n      });\n    }, (error) => {\n      reject(error);\n    });\n  });\n}\n\n/**\n * Extract dimensions and measures from the data\n * @param {array} dataPages\n * @param {number} dimensionInfoLength\n * @returns {object}\n */\nfunction getDataFromHyperCube(dataPages, dimensionInfoLength) {\n  const data = {\n    dimensions: [],\n    measures: []\n  };\n  dataPages.forEach((page) => {\n    page.qMatrix.forEach((row) => {\n      const dimensions = [];\n      const measures = [];\n      row.forEach((value, i) => {\n        if (i < dimensionInfoLength) {\n          dimensions.push(value.qText);\n        } else {\n          measures.push(value.qNum);\n        }\n      });\n      data.dimensions.push(dimensions);\n      data.measures.push(measures);\n    });\n  });\n  return data;\n}\n\n/**\n * Extract dimensions and field from the data\n * @param {array} dataPages\n * @returns {object}\n */\nfunction getSortByData(dataPages) {\n  const data = {\n    dimensions: [],\n    sortByValue: []\n  };\n  if (dataPages && dataPages[0]) {\n    dataPages[0].qMatrix.forEach((row) => {\n      data.dimensions.push(row[0].qText);\n      data.sortByValue.push(row[1].qNum);\n    });\n  }\n  return data;\n}\n\n/**\n * Get the index of all dimensions in the hypercube\n * @param {array} dimensions\n * @param {object} field\n * @returns {number}\n */\nfunction getDimensionIndex(dimensions, field) {\n  const dim = dimensions.filter(d => d.label === field.primaryDimension);\n  return dim.length > 0 ? dim[0].index : 0;\n}\n\n/**\n * Retrieve measureIndex for measure we are calculating\n * @param {object} dimensionAndFieldList\n * @param {string} qLabel\n * @returns {number}\n */\nfunction getMeasureIndex(dimensionAndFieldList, qLabel) {\n  const allMeasures = dimensionAndFieldList.measures || [];\n  const measure = allMeasures.filter(m => m.label === qLabel);\n  return measure.length > 0 ? measure[0].index : 0;\n}\n\n/**\n * Create hypercube definition for our own hypercube\n * @param {object} field\n * @param {object} dimensionAndFieldList\n * @returns {object}\n */\nfunction getHyperCubeDef(field, dimensionAndFieldList) {\n  const hyperCubeDef = {\n    qDimensions: [],\n    qMeasures: [],\n    qInitialDataFetch: [{\n      qTop: 0,\n      qLeft: 0,\n      qHeight: 100,\n      qWidth: 20\n    }],\n    qSuppressZero: false,\n    qSuppressMissing: false\n  };\n  // Add existing dimensions to our hypercube\n  dimensionAndFieldList.dimensions.forEach((dim) => {\n    hyperCubeDef.qDimensions.push(dim.qDef);\n  });\n  // Create our calculated dimension if needed\n  dimensionAndFieldList.fields.forEach((fieldItem) => {\n    // Only need to calculate sortByExpression\n    if (fieldItem.qDef.qLabel === field.sortByLabel && fieldItem.qDef.qDef === field.sortByExpression) {\n      hyperCubeDef.qMeasures.push({\n        qDef: {\n          qDef: field.sortByExpression,\n          qLabel: field.sortByLabel\n        }\n      });\n    }\n  });\n  hyperCubeDef.qInterColumnSortOrder = [getDimensionIndex(dimensionAndFieldList.dimensions, field)];\n  return hyperCubeDef;\n}\n\n/**\n * Build properties for a new session object\n * @param {object} field\n * @param {object} dimensionAndFieldList\n * @returns {object}\n */\nfunction buildProperties(field, dimensionAndFieldList) {\n  return {\n    qInfo: {\n      qType: 'table'\n    },\n    qHyperCubeDef: getHyperCubeDef(field, dimensionAndFieldList)\n  };\n}\n\n/**\n * Get data for the measure to sort by from the existing data pages\n * @param {object} field\n * @param {object} dimensionAndFieldList\n * @param {array} dataPages\n * @returns {object}\n */\nfunction getMeasureToSortByFromDataPages(field, dimensionAndFieldList, dataPages) {\n  const dimensionIndex = getDimensionIndex(dimensionAndFieldList.dimensions, field);\n  const measureIndex = field.measureIndex || dimensionAndFieldList.measureIndex || 0;\n  const data = {\n    dimensions: [],\n    sortByValue: []\n  };\n  dataPages.forEach((page) => {\n    page.qMatrix.forEach((row) => {\n      if (row[dimensionIndex].qText !== '') {\n        data.dimensions.push(row[dimensionIndex].qText);\n        data.sortByValue.push(row[measureIndex].qNum);\n      }\n    });\n  });\n  return data;\n}\n\n/**\n * Get sorted data for measures and dimensions to calculate accumulation\n * @param {object} field\n * @param {object} dimensionAndFieldList\n * @param {object} app\n * @param {array} dataPages\n * @returns {Promise}\n */\nfunction getSortedData(field, dimensionAndFieldList, app, dataPages) {\n  const resultData = {};\n  return new Promise((resolve) => {\n    if (field.sortByExpression && field.sortByExpression !== '') {\n      // We need to load this field to use it for sorting\n      const crossPropsDef = getCrossTableProperties(field, dimensionAndFieldList);\n      const crossPropsDefFull = {\n        qInfo: {\n          qType: 'accumulation'\n        },\n        qHyperCubeDef: crossPropsDef\n      };\n      getSortByDataFromHyperCube(crossPropsDefFull, app).then((pages) => {\n        const data = getSortByData(pages);\n        resultData.sortByDimension = data.dimensions;\n        resultData.sortByValue = data.sortByValue;\n        resolve(resultData);\n      });\n    } else {\n      // We have this measure already\n      const data = getMeasureToSortByFromDataPages(field, dimensionAndFieldList, dataPages);\n      resultData.sortByDimension = data.dimensions;\n      resultData.sortByValue = data.sortByValue;\n      resolve(resultData);\n    }\n  });\n}\n\n/**\n * Get data from the hypercube to use for calculations\n * @param {object} layout\n * @param {object} app\n * @param {object} properties\n * @param {object} field\n * @param {object} dimensionAndFieldList\n * @param {array} dataPages\n * @returns {Promise}\n */\nfunction getData(layout, app, properties, field, dimensionAndFieldList, dataPages) {\n  const modifiedDimensionAndFieldList = extend(true, {}, dimensionAndFieldList);\n  addDimensionAndFields(\n    modifiedDimensionAndFieldList,\n    layout.qHyperCube.qDimensionInfo,\n    field,\n    properties.qHyperCubeDef\n  );\n  return new Promise((resolve) => {\n    if (layout.qHyperCube.qMode === 'S') {\n      // Create our calculated hypercube with the required fields\n      getSortedData(field, modifiedDimensionAndFieldList, app, dataPages).then((data) => {\n        const dimensions = layout.qHyperCube.qDimensionInfo;\n        const dimensionIndex = getDimensionIndex(modifiedDimensionAndFieldList.dimensions, field);\n        const hcData = getDataFromHyperCube(dataPages, dimensions.length);\n        // Find the measure we are calculating on\n        const measureIndex = getMeasureIndex(modifiedDimensionAndFieldList, field.label);\n\n        resolve({\n          data: hcData.measures.map(m => m[measureIndex]),\n          sourceData: hcData.measures.map(m => m[measureIndex]),\n          sortBy: {\n            dimension: hcData.dimensions.map(d => d[dimensionIndex]),\n            value: data.sortByValue\n          }\n        });\n      });\n    } else {\n      // Create our calculated hypercube with the required fields\n      const def = buildProperties(field, modifiedDimensionAndFieldList);\n      app.createSessionObject(def).then((obj) => {\n        const requestPage = [{\n          qTop: 0,\n          qLeft: 0,\n          qWidth: 20,\n          qHeight: 1000,\n          qIncludeElementId: true\n        }];\n        obj.getHyperCubeData('/qHyperCubeDef', requestPage).then((pages) => {\n          const dimensionIndex = getDimensionIndex(modifiedDimensionAndFieldList.dimensions, field);\n          const measureIndex = getMeasureIndex(modifiedDimensionAndFieldList, field.label);\n          getSortedData(field, modifiedDimensionAndFieldList, app, dataPages).then((data) => {\n            // Get measure data from the real hypercube\n            const hcData = getDataFromHyperCube(dataPages, layout.qHyperCube.qDimensionInfo.length);\n            // Extract data to use in calculation\n            resolve({\n              data: hcData.measures.map(m => m[measureIndex - layout.qHyperCube.qDimensionInfo.length]),\n              sourceData: hcData.measures.map(m => m[measureIndex - layout.qHyperCube.qDimensionInfo.length]),\n              sortBy: {\n                dimension: hcData.dimensions.map(d => d[dimensionIndex]),\n                value: data.sortByValue\n              }\n            });\n          });\n        });\n      });\n    }\n  });\n}\n\n/**\n * Prepare for calculation by parsing properties\n * @param {object} layout\n * @param {object} app\n * @param {object} properties\n * @param {object} field\n * @param {object} dimensionAndFieldList\n * @param {object} aggr\n * @param {array} dataPages\n * @returns {Promise}\n */\nfunction calculate(layout, app, properties, field, dimensionAndFieldList, aggr, dataPages) {\n  if (!layout.qHyperCube.qDimensionInfo || !layout.qHyperCube.qDimensionInfo.length) {\n    return Promise.resolve({\n      values: [0],\n      sourceValues: [0]\n    });\n  }\n  // Get settings from properties\n  setPrimaryDimension(aggr, field, layout.qHyperCube.qDimensionInfo);\n  getSortByDef(aggr, field, layout);\n  // Add null option to include nulls in calculation\n  field.includeNull = aggr.qDef.includeNull || INCLUDE_NULL; // eslint-disable-line no-param-reassign\n  return new Promise((resolve) => {\n    getData(layout, app, properties, field, dimensionAndFieldList, dataPages).then((data) => {\n      const result = accumulation(data, field, aggr);\n      resolve(result);\n    });\n  });\n}\n\nexport default calculate;\nexport { getSortByDef, getDataFromHyperCube, getSortByData, getMeasureToSortByFromDataPages };\n\u0005End File\u0006# qlik-oss/qlik-modifiers\n/**\n * Difference calculation\n * @module\n * @param {object} layout - The layout object from the generic object\n * @param {object} properties - The generic object properties\n * @param {object} field - The properties for this aggregation\n * @param {object} dimensionAndFieldList - List of dimensions and fields used by the hypercube\n * @param {object} aggr - Definition of the aggregation\n * @param {object} dataPages - QDataPages from the hypercube\n * @returns {object} The result of the calculation\n */\n\nimport extend from 'extend';\nimport difference from './difference/difference';\n\nconst RELATIVE_TO_FIRST = 1;\nconst RELATIVE_TO_ALL = 2;\nconst RELATIVE_TO_SELECTED = 3;\n\n/**\n * Find the dimension by label\n * @param {array} dimensions\n * @param {string} dimensionLabel\n * @returns {object}\n */\nfunction findDimensionByLabel(dimensions, dimensionLabel) {\n  if (!dimensions) {\n    return undefined;\n  }\n  const dim = dimensions.filter(d => d.qFallbackTitle === dimensionLabel);\n  return dim.length > 0 ? dim[0] : undefined;\n}\n\n/**\n * Add dimensions to dimensionAndFieldList that are required for difference to work\n * @param {object} dimensionAndFieldList\n * @param {array} dimensions\n * @param {object} field\n */\nfunction addDimensionAndFields(dimensionAndFieldList, dimensions, field) {\n  if (field.primaryDimension) {\n    let dimension = findDimensionByLabel(dimensions, field.primaryDimension);\n    if (dimension) {\n      // Check if we already have this dimension in our field list\n      let found = false;\n      (dimensionAndFieldList.dimensions || []).forEach((dim) => {\n        if (dim.label === field.primaryDimension) {\n          found = true;\n        }\n      });\n      if (!found) {\n        dimensionAndFieldList.dimensions.push({\n          index: -1,\n          label: dimension.qFallbackTitle\n        });\n      }\n    }\n  }\n  if (field.relativeDimension) {\n    let dimension = findDimensionByLabel(dimensions, field.relativeDimension);\n    if (dimension) {\n      // Check if we already have this dimension in our field list\n      let found = false;\n      (dimensionAndFieldList.dimensions || []).forEach((dim) => {\n        if (dim.label === field.relativeDimension) {\n          found = true;\n        }\n      });\n      if (!found) {\n        dimensionAndFieldList.dimensions.push({\n          index: -1,\n          label: dimension.qFallbackTitle\n        });\n      }\n    }\n  }\n}\n\n/**\n * Set the primary dimension to use as X axis\n * @param {object} aggr\n * @param {object} field\n * @param {array} dimensions\n */\nfunction setPrimaryDimension(aggr, field, dimensions) {\n  if (aggr.qDef.primaryDimension) {\n    field.primaryDimension = aggr.qDef.primaryDimension; // eslint-disable-line no-param-reassign\n  } else {\n    field.primaryDimension = dimensions.length > 0 ? dimensions[0].qFallbackTitle : undefined; // eslint-disable-line no-param-reassign\n  }\n}\n\n/**\n * Set the dimension to use for reference value\n * @param {object} aggr\n * @param {object} field\n * @param {array} dimensions\n */\nfunction setRelativeDimension(aggr, field, dimensions) {\n  if (aggr.qDef.relativeTo === RELATIVE_TO_SELECTED && aggr.qDef.relativeDimension) {\n    field.relativeDimension = aggr.qDef.relativeDimension; // eslint-disable-line no-param-reassign\n  } else if (aggr.qDef.relativeTo === RELATIVE_TO_SELECTED && field.primaryDimension) {\n    field.relativeDimension = field.primaryDimension; // eslint-disable-line no-param-reassign\n  } else {\n    field.relativeDimension = dimensions.length > 0 ? dimensions[0].qFallbackTitle : undefined; // eslint-disable-line no-param-reassign\n  }\n  field.relativeTo = aggr.qDef.relativeTo || RELATIVE_TO_FIRST; // eslint-disable-line no-param-reassign\n}\n\n/**\n * Extract dimensions and measures from the data\n * @param {array} dataPages\n * @param {number} dimensionInfoLength\n * @returns {object}\n */\nfunction getDataFromHyperCube(dataPages, dimensionInfoLength) {\n  const data = {\n    dimensions: [],\n    measures: []\n  };\n  dataPages.forEach((page) => {\n    page.qMatrix.forEach((row) => {\n      const dimensions = [];\n      const measures = [];\n      row.forEach((value, i) => {\n        if (i < dimensionInfoLength) {\n          dimensions.push(value.qText);\n        } else {\n          measures.push(value.qNum);\n        }\n      });\n      data.dimensions.push(dimensions);\n      data.measures.push(measures);\n    });\n  });\n  return data;\n}\n\n/**\n * Get the index of the dimension in the layout\n * @param {array} qDimensionInfo\n * @param {string} dimensionLabel\n * @returns {number}\n */\nfunction getDimensionIndex(qDimensionInfo, dimensionLabel) {\n  let index = -1;\n  qDimensionInfo.forEach((dimension, i) => {\n    if (dimension.qFallbackTitle === dimensionLabel) {\n      index = i;\n    }\n  });\n  return index;\n}\n\n/**\n * Build a object with indices of the dimensions to use for the calculation\n * @param {array} dimensions\n * @param {object} field\n * @returns {object}\n */\nfunction getDimensionIndices(dimensions, field) {\n  return {\n    primaryDimension: getDimensionIndex(dimensions, field.primaryDimension),\n    relativeDimension: getDimensionIndex(dimensions, field.relativeDimension)\n  };\n}\n\n/**\n * Retrieve measureIndex for measure we are calculating\n * @param {object} dimensionAndFieldList\n * @param {string} qLabel\n * @returns {number}\n */\nfunction getMeasureIndex(dimensionAndFieldList, qLabel) {\n  const allMeasures = dimensionAndFieldList.measures || [];\n  const measure = allMeasures.filter(m => m.label === qLabel);\n  return measure.length > 0 ? measure[0].index : 0;\n}\n\n/**\n * Get data from the hypercube to use for calculations\n * @param {object} layout\n * @param {object} field\n * @param {object} dimensionAndFieldList\n * @param {array} dataPages\n * @returns {Promise}\n */\nfunction getData(layout, field, dimensionAndFieldList, dataPages) {\n  return new Promise((resolve) => {\n    const hcData = getDataFromHyperCube(dataPages, layout.qHyperCube.qDimensionInfo.length);\n    const dimensionIndices = getDimensionIndices(layout.qHyperCube.qDimensionInfo, field);\n    const measureIndex = getMeasureIndex(dimensionAndFieldList, field.label) - layout.qHyperCube.qDimensionInfo.length;\n    // Extract data to use in calculation\n    resolve({\n      sourceData: hcData.measures.map(m => m[measureIndex]),\n      primaryDimension: hcData.dimensions.map(d => d[dimensionIndices.primaryDimension]),\n      relativeDimension: hcData.dimensions.map(d => d[dimensionIndices.relativeDimension])\n    });\n  });\n}\n\n/**\n * Prepare for calculation by parsing properties\n * @param {object} layout\n * @param {object} app\n * @param {object} properties\n * @param {object} field\n * @param {object} dimensionAndFieldList\n * @param {object} aggr\n * @param {array} dataPages\n * @returns {Promise}\n */\nfunction calculate(layout, app, properties, field, dimensionAndFieldList, aggr, dataPages) {\n  if (!layout.qHyperCube.qDimensionInfo || !layout.qHyperCube.qDimensionInfo.length) {\n    return Promise.resolve({\n      values: [0],\n      sourceValues: [0]\n    });\n  }\n  // Get settings from properties\n  setPrimaryDimension(aggr, field, layout.qHyperCube.qDimensionInfo);\n  setRelativeDimension(aggr, field, layout.qHyperCube.qDimensionInfo);\n  // Add to dimensions and fields\n  const modifiedDimensionAndFieldList = extend(true, {}, dimensionAndFieldList);\n  addDimensionAndFields(\n    modifiedDimensionAndFieldList,\n    layout.qHyperCube.qDimensionInfo,\n    field\n  );\n  return new Promise((resolve) => {\n    getData(layout, field, modifiedDimensionAndFieldList, dataPages).then((data) => {\n      const result = difference(data, field, aggr);\n      resolve(result);\n    });\n  });\n}\n\nexport default calculate;\nexport { getDataFromHyperCube, getDimensionIndices };\n\u0005End File\u0006# qlik-oss/qlik-modifiers\n/**\n * Ranking calculation\n * @module\n * @param {object} layout - The layout object from the generic object\n * @param {object} properties - The generic object properties\n * @param {object} field - The properties for this aggregation\n * @param {object} dimensionAndFieldList - List of dimensions and fields used by the hypercube\n * @param {object} aggr - Definition of the aggregation\n * @param {object} dataPages - QDataPages from the hypercube\n * @returns {object} The result of the calculation\n */\n\nimport extend from 'extend';\nimport ranking from './ranking/ranking';\n\nconst FIRST_DIMENSION = 1;\nconst SELECTED_DIMENSION = 2;\n\n/**\n * Find the dimension by label\n * @param {array} dimensions\n * @param {string} dimensionLabel\n * @returns {object}\n */\nfunction findDimensionByLabel(dimensions, dimensionLabel) {\n  if (!dimensions) {\n    return undefined;\n  }\n  const dim = dimensions.filter(d => d.qFallbackTitle === dimensionLabel);\n  return dim.length > 0 ? dim[0] : undefined;\n}\n\n/**\n * Add dimensions to dimensionAndFieldList that are required for difference to work\n * @param {object} dimensionAndFieldList\n * @param {array} dimensions\n * @param {object} field\n */\nfunction addDimensionAndFields(dimensionAndFieldList, dimensions, field) {\n  if (field.primaryDimension) {\n    let dimension = findDimensionByLabel(dimensions, field.primaryDimension);\n    if (dimension) {\n      // Check if we already have this dimension in our field list\n      let found = false;\n      (dimensionAndFieldList.dimensions || []).forEach((dim) => {\n        if (dim.label === field.primaryDimension) {\n          found = true;\n        }\n      });\n      if (!found) {\n        dimensionAndFieldList.dimensions.push({\n          index: -1,\n          label: dimension.qFallbackTitle\n        });\n      }\n    }\n  }\n  if (field.dimensionToRank) {\n    let dimension = findDimensionByLabel(dimensions, field.dimensionToRank);\n    if (dimension) {\n      // Check if we already have this dimension in our field list\n      let found = false;\n      (dimensionAndFieldList.dimensions || []).forEach((dim) => {\n        if (dim.label === field.dimensionToRank) {\n          found = true;\n        }\n      });\n      if (!found) {\n        dimensionAndFieldList.dimensions.push({\n          index: -1,\n          label: dimension.qFallbackTitle\n        });\n      }\n    }\n  }\n}\n\n/**\n * Set the primary dimension to group by for ranking\n * @param {object} aggr\n * @param {object} field\n * @param {array} dimensions\n */\nfunction setPrimaryDimension(aggr, field, dimensions) {\n  if (aggr.qDef.groupDimension) {\n    field.primaryDimension = aggr.qDef.groupDimension; // eslint-disable-line no-param-reassign\n  } else {\n    field.primaryDimension = dimensions.length > 0 ? dimensions[0].qFallbackTitle : undefined; // eslint-disable-line no-param-reassign\n  }\n}\n\n/**\n * Set the dimension to rank\n * @param {object} aggr\n * @param {object} field\n * @param {array} dimensions\n */\nfunction setDimensionToRank(aggr, field, dimensions) {\n  if (aggr.qDef.dimensionToRank === SELECTED_DIMENSION && aggr.qDef.selectedDimension) {\n    field.dimensionToRank = aggr.qDef.selectedDimension; // eslint-disable-line no-param-reassign\n  } else if (aggr.qDef.dimensionToRank === SELECTED_DIMENSION && field.primaryDimension) {\n    field.dimensionToRank = field.primaryDimension; // eslint-disable-line no-param-reassign\n  } else {\n    field.dimensionToRank = dimensions.length > 0 ? dimensions[0].qFallbackTitle : undefined; // eslint-disable-line no-param-reassign\n  }\n  field.dimensionToRankCode = aggr.qDef.dimensionToRank || FIRST_DIMENSION; // eslint-disable-line no-param-reassign\n}\n\n/**\n * Extract dimensions and measures from the data\n * @param {array} dataPages\n * @param {number} dimensionInfoLength\n * @returns {object}\n */\nfunction getDataFromHyperCube(dataPages, dimensionInfoLength) {\n  const data = {\n    dimensions: [],\n    measures: []\n  };\n  dataPages.forEach((page) => {\n    page.qMatrix.forEach((row) => {\n      const dimensions = [];\n      const measures = [];\n      row.forEach((value, i) => {\n        if (i < dimensionInfoLength) {\n          dimensions.push(value.qText);\n        } else {\n          measures.push(value.qNum);\n        }\n      });\n      data.dimensions.push(dimensions);\n      data.measures.push(measures);\n    });\n  });\n  return data;\n}\n\n/**\n * Get the index of the dimension in the layout\n * @param {array} qDimensionInfo\n * @param {string} dimensionLabel\n * @returns {number}\n */\nfunction getDimensionIndex(qDimensionInfo, dimensionLabel) {\n  let index = -1;\n  qDimensionInfo.forEach((dimension, i) => {\n    if (dimension.qFallbackTitle === dimensionLabel) {\n      index = i;\n    }\n  });\n  return index;\n}\n\n/**\n * Build a object with indices of the dimensions to use for the calculation\n * @param {array} dimensions\n * @param {object} field\n * @returns {object}\n */\nfunction getDimensionIndices(dimensions, field) {\n  return {\n    primaryDimension: getDimensionIndex(dimensions, field.primaryDimension),\n    dimensionToRank: getDimensionIndex(dimensions, field.dimensionToRank)\n  };\n}\n\n/**\n * Retrieve measureIndex for measure we are calculating\n * @param {object} dimensionAndFieldList\n * @param {string} qLabel\n * @returns {number}\n */\nfunction getMeasureIndex(dimensionAndFieldList, qLabel) {\n  const allMeasures = dimensionAndFieldList.measures || [];\n  const measure = allMeasures.filter(m => m.label === qLabel);\n  return measure.length > 0 ? measure[0].index : 0;\n}\n\n/**\n * Get data from the hypercube to use for calculations\n * @param {object} layout\n * @param {object} field\n * @param {object} dimensionAndFieldList\n * @param {array} dataPages\n * @returns {Promise}\n */\nfunction getData(layout, field, dimensionAndFieldList, dataPages) {\n  return new Promise((resolve) => {\n    const hcData = getDataFromHyperCube(dataPages, layout.qHyperCube.qDimensionInfo.length);\n    const dimensionIndices = getDimensionIndices(layout.qHyperCube.qDimensionInfo, field);\n    const measureIndex = getMeasureIndex(dimensionAndFieldList, field.label) - layout.qHyperCube.qDimensionInfo.length;\n    // Extract data to use in calculation\n    resolve({\n      sourceData: hcData.measures.map(m => m[measureIndex]),\n      primaryDimension: hcData.dimensions.map(d => d[dimensionIndices.primaryDimension]),\n      dimensionToRank: hcData.dimensions.map(d => d[dimensionIndices.dimensionToRank])\n    });\n  });\n}\n\n/**\n * Prepare for calculation by parsing properties\n * @param {object} layout\n * @param {object} app\n * @param {object} properties\n * @param {object} field\n * @param {object} dimensionAndFieldList\n * @param {object} aggr\n * @param {array} dataPages\n * @returns {Promise}\n */\nfunction calculate(layout, app, properties, field, dimensionAndFieldList, aggr, dataPages) {\n  if (!layout.qHyperCube.qDimensionInfo || !layout.qHyperCube.qDimensionInfo.length) {\n    return Promise.resolve({\n      values: [0],\n      sourceValues: [0]\n    });\n  }\n  // Get settings from properties\n  setPrimaryDimension(aggr, field, layout.qHyperCube.qDimensionInfo);\n  setDimensionToRank(aggr, field, layout.qHyperCube.qDimensionInfo);\n  // Add to dimensions and fields\n  const modifiedDimensionAndFieldList = extend(true, {}, dimensionAndFieldList);\n  addDimensionAndFields(\n    modifiedDimensionAndFieldList,\n    layout.qHyperCube.qDimensionInfo,\n    field\n  );\n  return new Promise((resolve) => {\n    getData(layout, field, modifiedDimensionAndFieldList, dataPages).then((data) => {\n      const result = ranking(data, field, aggr);\n      resolve(result);\n    });\n  });\n}\n\nexport default calculate;\nexport { getDataFromHyperCube, getDimensionIndices };\n\u0005End File\u0006# qlik-oss/qlik-modifiers\n# src/aggregation/util/calculate.js\n/**\n * Common calculation functionality\n * @module\n */\n\n/**\n * Add the qAttributeExpressions calculations to the layout so that\n * they become available in the visualization\n * @param {object} model\n * @param {object} layout\n */\nfunction addCalculationsToLayout(model, layout) {\n  const measures = layout.qHyperCube.qMeasureInfo;\n  if (!measures || !measures.length || !model || !model.calculatedMeasures) {\n    return;\n  }\n  measures.forEach((measure, index) => {\n    const calculatedMeasureInfo = model.calculatedMeasures.filter(cMeasure => cMeasure.measureIndex === index);\n    if (calculatedMeasureInfo.length && calculatedMeasureInfo[0].calculatedValues) {\n      const calculatedValues = calculatedMeasureInfo[0].calculatedValues;\n      if (!calculatedValues || !calculatedValues.length) {\n        return;\n      }\n      const qAttrExprInfo = measure.qAttrExprInfo || [];\n      calculatedValues.forEach((calcVal, i) => {\n        if (qAttrExprInfo.length <= i) {\n          // First attributes not defined yet\n          qAttrExprInfo.push({\n            qFallbackTitle: calcVal.type,\n            qValues: calcVal.values,\n            qSourceValues: calcVal.sourceValues\n          });\n        } else {\n          // Attribute already exists, but update values\n          qAttrExprInfo[i] = {\n            qFallbackTitle: calcVal.type,\n            qValues: calcVal.values,\n            qSourceValues: calcVal.sourceValues\n          };\n        }\n        measure.qAttrExprInfo = qAttrExprInfo; // eslint-disable-line no-param-reassign\n      });\n    }\n  });\n}\n\n/**\n * Calculate all aggregations and add the qAttributeExpressions to layout\n * @param {object} calculationService\n * @param {object} layout\n * @param {object} model\n * @returns {Promise}\n */\nfunction calculate(calculationService, layout, model) {\n  if (!calculationService || !calculationService.registerForCalculation) {\n    return Promise.resolve(layout);\n  }\n  return calculationService.registerForCalculation(layout).then((result) => {\n    if (result && result.length) {\n      // Wait for calculations to finish\n      Promise.all(result).then(() => {\n        // Add all calculated values to the layout, so they will be available in the visualization\n        addCalculationsToLayout(model, layout);\n      });\n    }\n    return layout;\n  });\n}\n\nexport default {\n  calculate\n};\n\u0005End File\u0006# qlik-oss/qlik-modifiers\n/**\n * Service to get field information for a hypercube\n * @module\n */\n\n/**\n * Parse expressions with defined label, libId should be defined but not have a value\n * @param {object} def\n * @returns {string}\n */\nfunction getExpressionWithLabel(def) {\n  let expr = def.qDef;\n  if (typeof expr !== 'string') {\n    expr = expr.qDef;\n  }\n  return expr;\n}\n\n/**\n * Parse expressions with defined label, check for qLibraryId as well\n * @param {object} def\n * @returns {string}\n */\nfunction getExpressionWithLabelOrId(def) {\n  // Expression for master item\n  let expr = '';\n  if (typeof def.qLibraryId !== 'undefined' && def.qLibraryId !== '') {\n    expr = `$(\"${def.qLibraryId}\")`;\n  } else {\n    expr = getExpressionWithLabel(def);\n  }\n  return expr;\n}\n\n/**\n * Get measure expression\n * @param {object} properties\n * @param {number} measureIndex\n * @returns {string}\n */\nfunction getMeasureExpression(properties, measureIndex) {\n  if (!properties.qHyperCubeDef.qMeasures) {\n    return '';\n  }\n  const measure = properties.qHyperCubeDef.qMeasures[measureIndex];\n  return getExpressionWithLabelOrId(measure.qDef);\n}\n\n/**\n * Get dimension expression\n * @param {object} properties\n * @param {number} dimensionIndex\n * @returns {string}\n */\nfunction getDimensionExpression(properties, dimensionIndex) {\n  if (!properties.qHyperCubeDef.qDimensions) {\n    return '';\n  }\n  const dimension = properties.qHyperCubeDef.qDimensions[dimensionIndex];\n  if (dimension.qLibraryId && dimension.qLibraryId !== '') {\n    return `$(\"${dimension.qLibraryId}\")`;\n  }\n  if (dimension.qDef.qFieldDefs) {\n    return dimension.qDef.qFieldDefs[0];\n  }\n  return '';\n}\n\n/**\n * Get the dimension definition to use in our custom hypercube\n * @param {object} properties\n * @param {number} dimensionIndex\n * @returns {object}\n */\nfunction getDimensionDef(properties, dimensionIndex) {\n  if (!properties.qHyperCubeDef.qDimensions) {\n    return undefined;\n  }\n  const dimension = properties.qHyperCubeDef.qDimensions[dimensionIndex];\n  if (dimension.qLibraryId && dimension.qLibraryId !== '') {\n    return {\n      qLibraryId: dimension.qLibraryId,\n      qType: 'dimension'\n    };\n  }\n  // Add the dimension definition\n  return {\n    qDef: {\n      qFieldDefs: dimension.qDef.qFieldDefs,\n      qFieldLabels: dimension.qDef.qFieldLabels,\n      qSortCriterias: dimension.qDef.qSortCriterias\n    }\n  };\n}\n\n/**\n * Get dimensions and field list from properties\n * @param {object} properties\n * @returns {object}\n */\nfunction getDimensionAndFieldList(properties) {\n  const dimensionAndFieldList = {\n    dimensions: [],\n    measures: [],\n    fields: []\n  };\n  // For each dimension, add it to the list with index\n  (properties.qHyperCubeDef.qDimensions || []).forEach((dim, i) => {\n    const qDef = getDimensionDef(properties, i);\n    let label = '';\n    if (dim.qDef && dim.qDef.qFieldLabels && dim.qDef.qFieldLabels.length) {\n      label = dim.qDef.qFieldLabels[0];\n    } else if (dim.qDef && dim.qDef.qFieldDefs && dim.qDef.qFieldDefs.length) {\n      label = dim.qDef.qFieldDefs[0];\n    }\n    dimensionAndFieldList.dimensions.push({\n      index: i,\n      label,\n      qDef\n    });\n  });\n\n  // For each measure\n  (properties.qHyperCubeDef.qMeasures || []).forEach((measure, i) => {\n    let expr = getExpressionWithLabelOrId(measure.qDef);\n    let label = (measure.qDef.qLabel || measure.qDef.qLabelExpression || '');\n    if (!label && typeof expr === 'string') {\n      label = expr; // Use expression as label as a last resort\n    }\n    dimensionAndFieldList.measures.push({\n      index: properties.qHyperCubeDef.qDimensions.length + i,\n      label,\n      qDef: expr\n    });\n  });\n  return dimensionAndFieldList;\n}\n\nexport default {\n  getDimensionAndFieldList,\n  getMeasureExpression,\n  getDimensionExpression\n};\n\u0005End File\u0006/**\n * Service to handle aggregation of measures\n * @module\n */\n\nimport extend from 'extend';\nimport field from '../aggregation/util/field';\nimport accumulationCalc from '../aggregation/accumulation';\nimport movingAverageCalc from '../aggregation/moving-average';\nimport differenceCalc from '../aggregation/difference';\nimport rankingCalc from '../aggregation/ranking';\n\n// Modifier codes\nconst ACCUMULATION = 'acc';\nconst MOVING_AVERAGE = 'ma';\nconst DIFFERENCE = 'difference';\nconst RANKING = 'ranking';\n\n/**\n * Calculate aggregation for a specific measure\n * @param {object} layout\n * @param {object} app\n * @param {object} properties\n * @param {object} definition\n * @param {object} dimensionAndFieldList\n * @param {array} dataPages\n * @returns {Promise}\n */\nfunction calculateAggregation(layout, app, properties, definition, dimensionAndFieldList, dataPages) {\n  const field = {\n    label: definition.qDef.qLabel\n  };\n  if (definition.qDef.type === ACCUMULATION) {\n    return accumulationCalc(layout, app, properties, field, dimensionAndFieldList, definition, dataPages);\n  }\n  if (definition.qDef.type === MOVING_AVERAGE) {\n    return movingAverageCalc(layout, app, properties, field, dimensionAndFieldList, definition, dataPages);\n  }\n  if (definition.qDef.type === DIFFERENCE) {\n    return differenceCalc(layout, app, properties, field, dimensionAndFieldList, definition, dataPages);\n  }\n  if (definition.qDef.type === RANKING) {\n    return rankingCalc(layout, app, properties, field, dimensionAndFieldList, definition, dataPages);\n  }\n  return Promise.resolve({\n    values: [],\n    sourceValues: []\n  });\n}\n\n/**\n * Process calculations for a set of modifiers\n * @param {object} modifiers\n * @param {object} layout\n * @param {object} app\n * @param {object} properties\n * @param {array} calculatedMeasures\n * @param {object} dimensionAndFieldList\n * @param {array} dataPages\n * @param {object} model\n * @returns {Promise}\n */\nfunction processCalcs(modifiers, layout, app, properties, calculatedMeasures, dimensionAndFieldList, dataPages, model) {\n  return new Promise((resolve) => {\n    if (model.calculatedMeasures === undefined) {\n      model.calculatedMeasures = []; // eslint-disable-line no-param-reassign\n    }\n    const calculationsPromises = [];\n    // Get expression for measure. This should only be one measure\n    modifiers.measures.forEach((measureDef, i) => {\n      // Add measure to the list of calculated measures\n      const targetMeasure = {\n        measureIndex: measureDef.index,\n        calculatedValues: []\n      };\n      if (model.calculatedMeasures.filter(cMeasure => cMeasure.measureIndex === measureDef.index).length === 0) {\n        // Add the measure if it doesn't already exist\n        model.calculatedMeasures.push(targetMeasure);\n      }\n      // For each modifier, calculate values\n      modifiers.modifiers.forEach((modifier) => {\n        // Create definition for this modifier\n        const definition = {\n          qDef: extend({}, modifier.qDef, {\n            qLabel: measureDef.label\n          })\n        };\n        // Calculate the values\n        const calc = calculateAggregation(layout, app, properties, definition, dimensionAndFieldList, dataPages);\n        calculationsPromises.push(calc.then((result) => {\n          // Add values to calculatedValues for this measure\n          const calcValues = {\n            type: modifier.qDef.type,\n            values: result.values,\n            sourceValues: result.sourceValues\n          };\n          // Check if we've done this calculation before, if so - update\n          let existingIndex = -1;\n          const calcs = model.calculatedMeasures.filter(cMeasure => cMeasure.measureIndex === measureDef.index);\n          if (calcs.length > 0) {\n            const calc = calcs[0];\n            calc.calculatedValues.forEach((existingCalc, index) => {\n              if (existingCalc.type === calcValues.type) {\n                existingIndex = index;\n              }\n            });\n            if (existingIndex >= 0) {\n              calc.calculatedValues.splice(existingIndex, 1, calcValues);\n            } else {\n              calc.calculatedValues.push(calcValues);\n            }\n          }\n        }));\n      });\n    });\n    Promise.all(calculationsPromises).then(() => {\n      resolve();\n    });\n  });\n}\n\n/**\n * Initialize the calculation service\n * @param {object} model\n * @returns {object}\n */\nfunction initializeCalculationService(model) {\n  return {\n    registerForCalculation(layout) {\n      const calculations = [];\n      const properties = model.properties ? model.properties : {};\n\n      if (!model.app || !properties.qUndoExclude || !properties.qUndoExclude.qHyperCubeDef) {\n        return Promise.resolve([]);\n      }\n      if (!layout || !layout.qHyperCube) {\n        return Promise.resolve([]);\n      }\n      const dimensionAndFieldList = field.getDimensionAndFieldList(properties);\n      const app = model.app;\n      // Wait for dataPages to be resolved before calculating\n      const waitForData = model.getHyperCubeData().then((dataPages) => {\n        // Get calculation definitions from properties.qUndoExclude\n        const modifiers = properties.qUndoExclude.qHyperCubeDef.modifiers;\n        if (modifiers && modifiers.modifier && modifiers.measures) {\n          // We have modifiers, handle the calculations\n          calculations.push(processCalcs(modifiers, layout, app, properties, model.calculatedMeasures || [], dimensionAndFieldList, dataPages, model));\n        }\n        return Promise.all(calculations);\n      });\n      return Promise.resolve([waitForData]);\n    }\n  };\n}\n\nexport default {\n  initializeCalculationService\n};\n\u0005End File\u0006import extend from 'extend';\nimport updateAlternative from '../alternative';\nimport getSoftPropertyHandler from '../property-handler';\n\n// ---------------------------\n// Modifier settings\n// ---------------------------\nconst MODIFIER = {\n  type: 'accumulation',\n  activationPromise: null\n};\n\n// ---------------------------\n// Modifier functions\n// ---------------------------\n\n/**\n * Add the qDef property to the modifier\n * @param {object} modifier\n * @param {object} options\n */\nfunction addQDefToModifier(modifier, options) {\n  const qDef = {\n    type: 'acc',\n    modifierProperties: true\n  };\n  if (options && options.dimensions > 0) {\n    qDef.primaryDimension = options.defaultDimension;\n  }\n  if (options && options.sortByOptions) {\n    qDef.sortBy = {\n      sortByDimension: options.sortByDimension,\n      sortByExpression: options.sortByExpression\n    };\n  }\n  modifier.qDef = qDef; // eslint-disable-line no-param-reassign\n}\n\n/**\n * Add title components to the modifier\n * @param {object} modifier\n * @param {object} options\n */\nfunction addTitleComponents(modifier, options) {\n  if (options && options.dimensions > 0) {\n    modifier.components = []; // eslint-disable-line no-param-reassign\n  }\n  modifier.components = modifier.components || []; // eslint-disable-line no-param-reassign\n  // Add type (disabled if we have numeric dimension)\n  modifier.components.push({ // eslint-disable-line no-param-reassign\n    key: 'type',\n    type: 'string',\n    value: 'Accumulation',\n    undefined: true,\n    blocked: true\n  });\n}\n\n/**\n * Get primary dimension values\n * @param {object} layout\n * @returns {array}\n */\nfunction getDimensions(layout) {\n  if (!layout || !layout.qHyperCube || !layout.qHyperCube.qDimensionInfo) {\n    return [];\n  }\n  return layout.qHyperCube.qDimensionInfo.map(dim => ({\n    value: dim.qFallbackTitle,\n    label: dim.qFallbackTitle\n  }));\n}\n\n/**\n * Get the primary dimension based on the modifier\n * @param {object} layout\n * @param {object} modifier\n * @returns {string}\n */\nfunction getPrimaryDimension(layout, modifier) {\n  if (modifier && modifier.qDef && modifier.qDef.primaryDimension) {\n    return modifier.qDef.primaryDimension;\n  }\n  if (layout && layout.qHyperCube && layout.qHyperCube.qDimensionInfo && layout.qHyperCube.qDimensionInfo.length) {\n    return layout.qHyperCube.qDimensionInfo[0].qFallbackTitle;\n  }\n  return '';\n}\n\n/**\n * Get the values of all measures in the layout\n * @param {object} layout\n * @returns {array}\n */\nfunction getMeasures(layout) {\n  if (!layout || !layout.qHyperCube || !layout.qHyperCube.qMeasureInfo) {\n    return [];\n  }\n  return layout.qHyperCube.qMeasureInfo.map(measure => ({\n    value: measure.qFallbackTitle,\n    label: measure.qFallbackTitle\n  }));\n}\n\n/**\n * Get dimensions and measures for the default sort by settings\n * @param {object} layout\n * @param {object} modifier\n * @returns {object}\n */\nfunction getSortByOptions(layout, modifier) {\n  const dims = getDimensions(layout);\n  let sortByDimension = '';\n  let sortByExpression = '';\n  if (modifier && modifier.qDef && modifier.qDef.sortBy) {\n    sortByDimension = modifier.qDef.sortBy.sortByDimension || '';\n    sortByExpression = modifier.qDef.sortBy.sortByExpression || '';\n  } else if (dims.length > 0) {\n    sortByDimension = dims[0].value;\n  }\n  return {\n    dimensions: dims,\n    measures: getMeasures(layout),\n    sortByDimension,\n    sortByExpression\n  };\n}\n\n/**\n * Get property options for the modifier\n * @param {object} modifier\n * @param {object} properties\n * @param {object} layout\n * @param {string} defaultDimension\n * @returns {object}\n */\nfunction getPropertyOptions(modifier, properties, layout, defaultDimension) {\n  if (!layout) {\n    return {};\n  }\n  const dimensions = getDimensions(layout);\n  const primaryDimension = getPrimaryDimension(layout, modifier);\n  const options = {\n    dimensions: dimensions.length,\n    defaultDimension: defaultDimension || primaryDimension,\n    sortByOptions: getSortByOptions(layout, modifier)\n  };\n  return options;\n}\n\n/**\n * Update the modifier based on the current state of the properties and layout\n * @param {object} modifier\n * @param {object} properties\n * @param {object} layout\n * @param {object} model\n */\nfunction updateModifier(modifier, properties, layout, model) {\n  // First check that we have a qDef object to store properties in\n  if (!modifier.qDef) {\n    addQDefToModifier(modifier, getPropertyOptions(modifier, properties, layout));\n  }\n  // Make sure we have type\n  if (!modifier.type) {\n    modifier.type = MODIFIER.type; // eslint-disable-line no-param-reassign\n  }\n  // Make sure we have components\n  if (!modifier.components) {\n    addTitleComponents(modifier, getPropertyOptions(modifier, properties, layout));\n  } else {\n    // Update dimension values\n    const dimComp = modifier.components.filter(c => c.key === 'primaryDimension');\n    if (dimComp.length > 0) {\n      dimComp[0].values = getDimensions(layout);\n    }\n    // Update sortByDimension values\n    const sortByDim = modifier.components.filter(c => c.key === 'sortByDimension');\n    if (sortByDim.length > 0) {\n      sortByDim[0].values = [...getDimensions(layout), ...getMeasures(layout)];\n    }\n  }\n}\n\n/**\n * Check if the button should be disabled\n * @param {object} properties\n * @param {object} layout\n * @returns {boolean}\n */\nfunction isDisabled(properties, layout) {\n  // Enable if we have one dimension and one measure\n  return !layout || !layout.qHyperCube || !layout.qHyperCube.qDimensionInfo ||\n    !layout.qHyperCube.qMeasureInfo || !layout.qHyperCube.qDimensionInfo.length;\n}\n\n/**\n * Get the name displayed on the button\n * @param {object} properties\n * @param {object} layout\n * @returns {string}\n */\nfunction getName(properties, layout) {\n  return 'Accumulation';\n}\n\n/**\n * Get the available modifiers for this object\n * @param {object} options\n * @param {object} model\n * @param {object} layout\n * @param {object} properties\n */\nfunction getModifiers(options, model, layout, properties) {\n  const dimension = options.dimension || 0;\n  const measure = options.measure || 0;\n  const dimensions = getDimensions(layout);\n  const defaultDimension = dimensions.length > dimension ? dimensions[dimension].value : '';\n  const modifiers = [];\n  modifiers.push({\n    key: 'accumulation',\n    type: MODIFIER.type,\n    properties: getPropertyOptions({}, properties, layout, defaultDimension),\n    title: `Accumulation on ${dimensions.length ? dimensions[0].value : 'dimension'}`\n  });\n  return modifiers;\n}\n\n/**\n * Create a modifier with the correct properties\n * @param {object} modifier\n * @param {object} properties\n * @param {object} layout\n * @param {object} defaultValues\n * @returns {object}\n */\nfunction createModifier(modifier, properties, layout, defaultValues) {\n  // Copy the current modifier\n  const m = extend(true, {}, modifier);\n  // Add default values for properties\n  if (!m.qDef) {\n    addQDefToModifier(m, getPropertyOptions(m, properties, layout, defaultValues.dimension));\n  }\n  // Add title and description\n  addTitleComponents(m, getPropertyOptions(m, properties, layout, defaultValues.dimension));\n\n  return m;\n}\n\n/**\n * Modify properties for a modifier\n * @param {object} modifier\n * @param {object} properties\n * @param {object} propEntry\n * @param {object} layout\n */\nfunction modifyProperties(modifier, properties, propEntry, layout) {\n  if (!modifier || !modifier.qDef) {\n    return;\n  }\n  const options = propEntry.options;\n  if (options.type === 'select') {\n    // Handle selectBox\n    if (propEntry.key === 'primaryDimension') {\n      modifier.qDef.primaryDimension = propEntry.value;\n    } else if (propEntry.key === 'includeNull') {\n      modifier.qDef.includeNull = propEntry.value;\n    } else if (propEntry.key === 'sortByDimension') {\n      modifier.qDef.sortBy = modifier.qDef.sortBy || {};\n      modifier.qDef.sortBy.sortByDimension = propEntry.value;\n      modifier.qDef.sortBy.sortByExpression = '';\n    }\n  } else if (options.type === 'input') {\n    // Handle input\n    if (propEntry.key === 'sortByExpression') {\n      modifier.qDef.sortBy = modifier.qDef.sortBy || {};\n      modifier.qDef.sortBy.sortByExpression = propEntry.value;\n    }\n  }\n}\n\n/**\n * Add a component to an existing dialog-definition\n * @param {object} definition\n * @param {object} component\n */\nfunction addComponentToDefinition(definition, component) {\n  if (component && !component.hidden) {\n    if (component.ref) {\n      const refComponent = component.ref;\n      if (!refComponent.show) {\n        definition.items.push(refComponent);\n      }\n    } else {\n      definition.items.push(component);\n    }\n  }\n}\n\n/**\n * Get the property definition for a modifier\n * @param {object} modifier\n * @param {object} properties\n * @param {object} layout\n * @param {function} setPropertyValue\n * @returns {object}\n */\nfunction getPropertyDefinition(modifier, properties, layout, setPropertyValue) {\n  const definition = {\n    type: 'items',\n    items: []\n  };\n  if (!modifier || !modifier.qDef || !layout) {\n    return definition;\n  }\n  // Add primary dimension\n  const primaryDimensionVal = modifier.qDef.primaryDimension || getPrimaryDimension(layout, modifier);\n  const primaryDimension = {\n    type: 'string',\n    component: 'dropdown',\n    label: 'Dimension',\n    ref: 'primaryDimension',\n    defaultValue: primaryDimensionVal,\n    options: getDimensions(layout)\n  };\n  primaryDimension.change = (data) => {\n    setPropertyValue({\n      key: 'primaryDimension',\n      value: data,\n      options: {\n        type: 'select'\n      }\n    });\n  };\n  definition.items.push(primaryDimension);\n\n  // Add sort by\n  const sortBy = {\n    type: 'items',\n    component: 'expandable-items',\n    translation: 'properties.sorting',\n    items: {\n      defaultSort: {\n        type: 'items',\n        items: {}\n      }\n    }\n  };\n  // Add sort by value vs. expression\n  const useSortByExp = !!(modifier.qDef.sortBy && modifier.qDef.sortBy.sortByExpression);\n  const useSortByExpOption = {\n    type: 'boolean',\n    component: 'buttongroup',\n    label: 'Sort by',\n    ref: 'useSortByExp',\n    options: [{\n      value: false,\n      label: 'Value',\n      tooltip: 'Sort by dimension or measure'\n    }, {\n      value: true,\n      label: 'Expression',\n      tooltip: 'Sort by expression'\n    }],\n    defaultValue: useSortByExp\n  };\n  // sortByDimension\n  const values = [...getDimensions(layout), ...getMeasures(layout)];\n  const sortByDimensionVal = (modifier.qDef.sortBy && modifier.qDef.sortBy.sortByDimension) || (values.length > 0 ? values[0].value : '');\n  const sortByDimension = {\n    type: 'string',\n    component: 'dropdown',\n    label: 'Sort by',\n    ref: 'sortByDimension',\n    defaultValue: sortByDimensionVal,\n    options: values,\n    show: !useSortByExp\n  };\n  sortByDimension.change = (data) => {\n    setPropertyValue({\n      key: 'sortByDimension',\n      value: data,\n      options: {\n        type: 'select'\n      }\n    });\n  };\n  // Sort by expression\n  const sortByExpression = {\n    type: 'string',\n    component: 'expression',\n    expressionType: 'ValueExpression',\n    label: 'Sort by expression',\n    ref: 'sortByExpression',\n    defaultValue: (modifier.qDef.sortBy && modifier.qDef.sortBy.sortByExpression) || '',\n    show: useSortByExp\n  };\n  sortByExpression.change = (data) => {\n    setPropertyValue({\n      key: 'sortByExpression',\n      value: data,\n      options: {\n        type: 'input'\n      }\n    });\n  };\n\n  useSortByExpOption.change = (data) => {\n    if (data) {\n      // Show sortByExpression\n      sortByExpression.show = true;\n      sortByDimension.show = false;\n      setPropertyValue({\n        key: 'sortByExpression',\n        value: modifier.qDef.sortBy && modifier.qDef.sortBy.sortByExpression ? modifier.qDef.sortBy.sortByExpression : '',\n        options: {\n          type: 'input'\n        }\n      });\n    } else {\n      // Show sortByDimension\n      sortByExpression.show = false;\n      sortByDimension.show = true;\n      setPropertyValue({\n        key: 'sortByDimension',\n        value: modifier.qDef.sortBy && modifier.qDef.sortBy.sortByDimension ? modifier.qDef.sortBy.sortByDimension : (values.length > 0 ? values[0].value : ''),\n        options: {\n          type: 'select'\n        }\n      });\n    }\n  };\n  sortBy.items.defaultSort.items.useSortByExp = useSortByExpOption;\n  sortBy.items.defaultSort.items.sortByDimension = sortByDimension;\n  sortBy.items.defaultSort.items.sortByExpression = sortByExpression;\n  sortBy.items.defaultSort.items.sortAscending = {\n    type: 'boolean',\n    component: 'buttongroup',\n    label: 'Order',\n    ref: 'sortAscending',\n    options: [{\n      value: true,\n      label: 'Ascending',\n      tooltip: 'Sort ascending'\n    }, {\n      value: false,\n      label: 'Descending',\n      tooltip: 'Sort descending'\n    }],\n    defaultValue: true\n  };\n  definition.items.push(sortBy);\n\n  // Add include NULL\n  const includeNull = {\n    type: 'boolean',\n    component: 'buttongroup',\n    label: 'Include NULL',\n    ref: 'includeNull',\n    options: [{\n      value: 1,\n      label: 'Show'\n    }, {\n      value: 0,\n      label: 'Hide'\n    }],\n    defaultValue: 1\n  };\n  includeNull.change = (data) => {\n    setPropertyValue({\n      key: 'includeNull',\n      value: data,\n      options: {\n        type: 'select'\n      }\n    });\n  };\n  definition.items.push(includeNull);\n\n  return definition;\n}\n\n/**\n * Initialize the modifier\n * @param {object} localeInfo\n */\nfunction initialize(localeInfo) {\n  if (MODIFIER.activationPromise) {\n    return MODIFIER.activationPromise;\n  }\n  MODIFIER.activationPromise = Promise.resolve();\n  return MODIFIER.activationPromise;\n}\n\nexport default {\n  initialize,\n  isDisabled,\n  getName,\n  getModifiers,\n  createModifier,\n  updateModifier,\n  getPropertyDefinition,\n  modifyProperties,\n  activationPromise: MODIFIER.activationPromise\n};\n\u0005End File\u0006# qlik-oss/qlik-modifiers\n# src/modifiers/difference-modifier.js\nimport extend from 'extend';\nimport updateAlternative from '../alternative';\nimport getSoftPropertyHandler from '../property-handler';\n\n// ---------------------------\n// Modifier settings\n// ---------------------------\nconst MODIFIER = {\n  type: 'difference',\n  activationPromise: null\n};\n\n// ---------------------------\n// Modifier functions\n// ---------------------------\n\n/**\n * Add the qDef property to the modifier\n * @param {object} modifier\n * @param {object} options\n */\nfunction addQDefToModifier(modifier, options) {\n  const qDef = {\n    type: 'difference',\n    modifierProperties: true\n  };\n  if (options && options.dimensions > 0) {\n    qDef.primaryDimension = options.defaultDimension;\n  }\n  if (options && options.relativeDimension) {\n    qDef.relativeDimension = options.relativeDimension;\n  }\n  modifier.qDef = qDef; // eslint-disable-line no-param-reassign\n}\n\n/**\n * Add title components to the modifier\n * @param {object} modifier\n * @param {object} options\n */\nfunction addTitleComponents(modifier, options) {\n  if (options && options.dimensions > 0) {\n    modifier.components = []; // eslint-disable-line no-param-reassign\n  }\n  modifier.components = modifier.components || []; // eslint-disable-line no-param-reassign\n  // Add type (disabled if we have numeric dimension)\n  modifier.components.push({ // eslint-disable-line no-param-reassign\n    key: 'type',\n    type: 'string',\n    value: 'Difference',\n    undefined: true,\n    blocked: true\n  });\n}\n\n/**\n * Get primary dimension values\n * @param {object} layout\n * @returns {array}\n */\nfunction getDimensions(layout) {\n  if (!layout || !layout.qHyperCube || !layout.qHyperCube.qDimensionInfo) {\n    return [];\n  }\n  return layout.qHyperCube.qDimensionInfo.map(dim => ({\n    value: dim.qFallbackTitle,\n    label: dim.qFallbackTitle\n  }));\n}\n\n/**\n * Get the primary dimension based on the modifier\n * @param {object} layout\n * @param {object} modifier\n * @returns {string}\n */\nfunction getPrimaryDimension(layout, modifier) {\n  if (modifier && modifier.qDef && modifier.qDef.primaryDimension) {\n    return modifier.qDef.primaryDimension;\n  }\n  if (layout && layout.qHyperCube && layout.qHyperCube.qDimensionInfo && layout.qHyperCube.qDimensionInfo.length) {\n    return layout.qHyperCube.qDimensionInfo[0].qFallbackTitle;\n  }\n  return '';\n}\n\n/**\n * Get the relative dimension based on the modifier\n * @param {object} layout\n * @param {object} modifier\n * @returns {string}\n */\nfunction getRelativeDimension(layout, modifier) {\n  if (modifier && modifier.qDef && modifier.qDef.relativeDimension) {\n    return modifier.qDef.relativeDimension;\n  }\n  if (layout && layout.qHyperCube && layout.qHyperCube.qDimensionInfo && layout.qHyperCube.qDimensionInfo.length) {\n    return layout.qHyperCube.qDimensionInfo[0].qFallbackTitle;\n  }\n  return '';\n}\n\n/**\n * Get property options for the modifier\n * @param {object} modifier\n * @param {object} properties\n * @param {object} layout\n * @param {string} defaultDimension\n * @returns {object}\n */\nfunction getPropertyOptions(modifier, properties, layout, defaultDimension) {\n  if (!layout) {\n    return {};\n  }\n  const dimensions = getDimensions(layout);\n  const primaryDimension = getPrimaryDimension(layout, modifier);\n  const relativeDimension = getRelativeDimension(layout, modifier);\n  const options = {\n    dimensions: dimensions.length,\n    defaultDimension: defaultDimension || primaryDimension,\n    relativeDimension: relativeDimension\n  };\n  return options;\n}\n\n/**\n * Update the modifier based on the current state of the properties and layout\n * @param {object} modifier\n * @param {object} properties\n * @param {object} layout\n * @param {object} model\n */\nfunction updateModifier(modifier, properties, layout, model) {\n  // First check that we have a qDef object to store properties in\n  if (!modifier.qDef) {\n    addQDefToModifier(modifier, getPropertyOptions(modifier, properties, layout));\n  }\n  // Make sure we have type\n  if (!modifier.type) {\n    modifier.type = MODIFIER.type; // eslint-disable-line no-param-reassign\n  }\n  // Make sure we have components\n  if (!modifier.components) {\n    addTitleComponents(modifier, getPropertyOptions(modifier, properties, layout));\n  } else {\n    // Update dimension values\n    const dimComp = modifier.components.filter(c => c.key === 'primaryDimension');\n    if (dimComp.length > 0) {\n      dimComp[0].values = getDimensions(layout);\n    }\n    // Update relativeDimension values\n    const relativeDimComp = modifier.components.filter(c => c.key === 'relativeDimension');\n    if (relativeDimComp.length > 0) {\n      relativeDimComp[0].values = getDimensions(layout);\n    }\n  }\n}\n\n/**\n * Check if the button should be disabled\n * @param {object} properties\n * @param {object} layout\n * @returns {boolean}\n */\nfunction isDisabled(properties, layout) {\n  // Enable if we have one dimension and one measure\n  return !layout || !layout.qHyperCube || !layout.qHyperCube.qDimensionInfo ||\n    !layout.qHyperCube.qMeasureInfo || !layout.qHyperCube.qDimensionInfo.length;\n}\n\n/**\n * Get the name displayed on the button\n * @param {object} properties\n * @param {object} layout\n * @returns {string}\n */\nfunction getName(properties, layout) {\n  return 'Difference';\n}\n\n/**\n * Get the available modifiers for this object\n * @param {object} options\n * @param {object} model\n * @param {object} layout\n * @param {object} properties\n */\nfunction getModifiers(options, model, layout, properties) {\n  const dimension = options.dimension || 0;\n  const measure = options.measure || 0;\n  const dimensions = getDimensions(layout);\n  const defaultDimension = dimensions.length > dimension ? dimensions[dimension].value : '';\n  const modifiers = [];\n  modifiers.push({\n    key: 'difference',\n    type: MODIFIER.type,\n    properties: getPropertyOptions({}, properties, layout, defaultDimension),\n    title: `Difference on ${dimensions.length ? dimensions[0].value : 'dimension'}`\n  });\n  return modifiers;\n}\n\n/**\n * Create a modifier with the correct properties\n * @param {object} modifier\n * @param {object} properties\n * @param {object} layout\n * @param {object} defaultValues\n * @returns {object}\n */\nfunction createModifier(modifier, properties, layout, defaultValues) {\n  // Copy the current modifier\n  const m = extend(true, {}, modifier);\n  // Add default values for properties\n  if (!m.qDef) {\n    addQDefToModifier(m, getPropertyOptions(m, properties, layout, defaultValues.dimension));\n  }\n  // Add title and description\n  addTitleComponents(m, getPropertyOptions(m, properties, layout, defaultValues.dimension));\n\n  return m;\n}\n\n/**\n * Modify properties for a modifier\n * @param {object} modifier\n * @param {object} properties\n * @param {object} propEntry\n * @param {object} layout\n */\nfunction modifyProperties(modifier, properties, propEntry, layout) {\n  if (!modifier || !modifier.qDef) {\n    return;\n  }\n  const options = propEntry.options;\n  if (options.type === 'select') {\n    // Handle selectBox\n    if (propEntry.key === 'primaryDimension') {\n      modifier.qDef.primaryDimension = propEntry.value;\n    } else if (propEntry.key === 'relativeTo') {\n      modifier.qDef.relativeTo = propEntry.value;\n    } else if (propEntry.key === 'relativeDimension') {\n      modifier.qDef.relativeDimension = propEntry.value;\n    }\n  }\n}\n\n/**\n * Get the property definition for a modifier\n * @param {object} modifier\n * @param {object} properties\n * @param {object} layout\n * @param {function} setPropertyValue\n * @returns {object}\n */\nfunction getPropertyDefinition(modifier, properties, layout, setPropertyValue) {\n  const definition = {\n    type: 'items',\n    items: []\n  };\n  if (!modifier || !modifier.qDef || !layout) {\n    return definition;\n  }\n  // Add primary dimension\n  const primaryDimensionVal = modifier.qDef.primaryDimension || getPrimaryDimension(layout, modifier);\n  const primaryDimension = {\n    type: 'string',\n    component: 'dropdown',\n    label: 'Dimension',\n    ref: 'primaryDimension',\n    defaultValue: primaryDimensionVal,\n    options: getDimensions(layout)\n  };\n  primaryDimension.change = (data) => {\n    setPropertyValue({\n      key: 'primaryDimension',\n      value: data,\n      options: {\n        type: 'select'\n      }\n    });\n  };\n  definition.items.push(primaryDimension);\n\n  // Add relative type dropdown\n  const relativeTo = {\n    type: 'number',\n    component: 'dropdown',\n    label: 'Calculate differences relative to',\n    ref: 'relativeTo',\n    defaultValue: modifier.qDef.relativeTo || 1,\n    options: [{\n      value: 1,\n      label: 'First value'\n    }, {\n      value: 2,\n      label: 'All previous values'\n    }, {\n      value: 3,\n      label: 'Selected value'\n    }]\n  };\n  relativeTo.change = (data) => {\n    setPropertyValue({\n      key: 'relativeTo',\n      value: data,\n      options: {\n        type: 'select'\n      }\n    });\n  };\n  definition.items.push(relativeTo);\n\n  // Add selected dimension\n  const relativeDimensionVal = modifier.qDef.relativeDimension || getRelativeDimension(layout, modifier);\n  const relativeDimension = {\n    type: 'string',\n    component: 'dropdown',\n    label: 'Reference dimension',\n    ref: 'relativeDimension',\n    defaultValue: relativeDimensionVal,\n    options: getDimensions(layout),\n    show: modifier.qDef.relativeTo === 3\n  };\n  relativeDimension.change = (data) => {\n    setPropertyValue({\n      key: 'relativeDimension',\n      value: data,\n      options: {\n        type: 'select'\n      }\n    });\n  };\n  definition.items.push(relativeDimension);\n\n  return definition;\n}\n\n/**\n * Initialize the modifier\n * @param {object} localeInfo\n */\nfunction initialize(localeInfo) {\n  if (MODIFIER.activationPromise) {\n    return MODIFIER.activationPromise;\n  }\n  MODIFIER.activationPromise = Promise.resolve();\n  return MODIFIER.activationPromise;\n}\n\nexport default {\n  initialize,\n  isDisabled,\n  getName,\n  getModifiers,\n  createModifier,\n  updateModifier,\n  getPropertyDefinition,\n  modifyProperties,\n  activationPromise: MODIFIER.activationPromise\n};\n\u0005End File\u0006import extend from 'extend';\nimport updateAlternative from '../alternative';\nimport getSoftPropertyHandler from '../property-handler';\n\n// ---------------------------\n// Modifier settings\n// ---------------------------\nconst MODIFIER = {\n  type: 'ranking',\n  activationPromise: null\n};\n\n// ---------------------------\n// Modifier functions\n// ---------------------------\n\n/**\n * Add the qDef property to the modifier\n * @param {object} modifier\n * @param {object} options\n */\nfunction addQDefToModifier(modifier, options) {\n  const qDef = {\n    type: 'ranking',\n    modifierProperties: true\n  };\n  if (options && options.dimensions > 0) {\n    qDef.groupDimension = options.defaultDimension;\n  }\n  if (options && options.selectedDimension) {\n    qDef.selectedDimension = options.selectedDimension;\n  }\n  modifier.qDef = qDef; // eslint-disable-line no-param-reassign\n}\n\n/**\n * Add title components to the modifier\n * @param {object} modifier\n * @param {object} options\n */\nfunction addTitleComponents(modifier, options) {\n  if (options && options.dimensions > 0) {\n    modifier.components = []; // eslint-disable-line no-param-reassign\n  }\n  modifier.components = modifier.components || []; // eslint-disable-line no-param-reassign\n  // Add type (disabled if we have numeric dimension)\n  modifier.components.push({ // eslint-disable-line no-param-reassign\n    key: 'type',\n    type: 'string',\n    value: 'Ranking',\n    undefined: true,\n    blocked: true\n  });\n}\n\n/**\n * Get primary dimension values\n * @param {object} layout\n * @returns {array}\n */\nfunction getDimensions(layout) {\n  if (!layout || !layout.qHyperCube || !layout.qHyperCube.qDimensionInfo) {\n    return [];\n  }\n  return layout.qHyperCube.qDimensionInfo.map(dim => ({\n    value: dim.qFallbackTitle,\n    label: dim.qFallbackTitle\n  }));\n}\n\n/**\n * Get the primary dimension based on the modifier\n * @param {object} layout\n * @param {object} modifier\n * @returns {string}\n */\nfunction getPrimaryDimension(layout, modifier) {\n  if (modifier && modifier.qDef && modifier.qDef.groupDimension) {\n    return modifier.qDef.groupDimension;\n  }\n  if (layout && layout.qHyperCube && layout.qHyperCube.qDimensionInfo && layout.qHyperCube.qDimensionInfo.length) {\n    return layout.qHyperCube.qDimensionInfo[0].qFallbackTitle;\n  }\n  return '';\n}\n\n/**\n * Get the selected dimension based on the modifier\n * @param {object} layout\n * @param {object} modifier\n * @returns {string}\n */\nfunction getSelectedDimension(layout, modifier) {\n  if (modifier && modifier.qDef && modifier.qDef.selectedDimension) {\n    return modifier.qDef.selectedDimension;\n  }\n  if (layout && layout.qHyperCube && layout.qHyperCube.qDimensionInfo && layout.qHyperCube.qDimensionInfo.length) {\n    return layout.qHyperCube.qDimensionInfo[0].qFallbackTitle;\n  }\n  return '';\n}\n\n/**\n * Get property options for the modifier\n * @param {object} modifier\n * @param {object} properties\n * @param {object} layout\n * @param {string} defaultDimension\n * @returns {object}\n */\nfunction getPropertyOptions(modifier, properties, layout, defaultDimension) {\n  if (!layout) {\n    return {};\n  }\n  const dimensions = getDimensions(layout);\n  const primaryDimension = getPrimaryDimension(layout, modifier);\n  const selectedDimension = getSelectedDimension(layout, modifier);\n  const options = {\n    dimensions: dimensions.length,\n    defaultDimension: defaultDimension || primaryDimension,\n    selectedDimension: selectedDimension\n  };\n  return options;\n}\n\n/**\n * Update the modifier based on the current state of the properties and layout\n * @param {object} modifier\n * @param {object} properties\n * @param {object} layout\n * @param {object} model\n */\nfunction updateModifier(modifier, properties, layout, model) {\n  // First check that we have a qDef object to store properties in\n  if (!modifier.qDef) {\n    addQDefToModifier(modifier, getPropertyOptions(modifier, properties, layout));\n  }\n  // Make sure we have type\n  if (!modifier.type) {\n    modifier.type = MODIFIER.type; // eslint-disable-line no-param-reassign\n  }\n  // Make sure we have components\n  if (!modifier.components) {\n    addTitleComponents(modifier, getPropertyOptions(modifier, properties, layout));\n  } else {\n    // Update dimension values\n    const dimComp = modifier.components.filter(c => c.key === 'groupDimension');\n    if (dimComp.length > 0) {\n      dimComp[0].values = getDimensions(layout);\n    }\n    // Update selectedDimension values\n    const selectedDimComp = modifier.components.filter(c => c.key === 'selectedDimension');\n    if (selectedDimComp.length > 0) {\n      selectedDimComp[0].values = getDimensions(layout);\n    }\n  }\n}\n\n/**\n * Check if the button should be disabled\n * @param {object} properties\n * @param {object} layout\n * @returns {boolean}\n */\nfunction isDisabled(properties, layout) {\n  // Enable if we have one dimension and one measure\n  return !layout || !layout.qHyperCube || !layout.qHyperCube.qDimensionInfo ||\n    !layout.qHyperCube.qMeasureInfo || !layout.qHyperCube.qDimensionInfo.length;\n}\n\n/**\n * Get the name displayed on the button\n * @param {object} properties\n * @param {object} layout\n * @returns {string}\n */\nfunction getName(properties, layout) {\n  return 'Ranking';\n}\n\n/**\n * Get the available modifiers for this object\n * @param {object} options\n * @param {object} model\n * @param {object} layout\n * @param {object} properties\n */\nfunction getModifiers(options, model, layout, properties) {\n  const dimension = options.dimension || 0;\n  const measure = options.measure || 0;\n  const dimensions = getDimensions(layout);\n  const defaultDimension = dimensions.length > dimension ? dimensions[dimension].value : '';\n  const modifiers = [];\n  modifiers.push({\n    key: 'ranking',\n    type: MODIFIER.type,\n    properties: getPropertyOptions({}, properties, layout, defaultDimension),\n    title: `Ranking on ${dimensions.length ? dimensions[0].value : 'dimension'}`\n  });\n  return modifiers;\n}\n\n/**\n * Create a modifier with the correct properties\n * @param {object} modifier\n * @param {object} properties\n * @param {object} layout\n * @param {object} defaultValues\n * @returns {object}\n */\nfunction createModifier(modifier, properties, layout, defaultValues) {\n  // Copy the current modifier\n  const m = extend(true, {}, modifier);\n  // Add default values for properties\n  if (!m.qDef) {\n    addQDefToModifier(m, getPropertyOptions(m, properties, layout, defaultValues.dimension));\n  }\n  // Add title and description\n  addTitleComponents(m, getPropertyOptions(m, properties, layout, defaultValues.dimension));\n\n  return m;\n}\n\n/**\n * Modify properties for a modifier\n * @param {object} modifier\n * @param {object} properties\n * @param {object} propEntry\n * @param {object} layout\n */\nfunction modifyProperties(modifier, properties, propEntry, layout) {\n  if (!modifier || !modifier.qDef) {\n    return;\n  }\n  const options = propEntry.options;\n  if (options.type === 'select') {\n    // Handle selectBox\n    if (propEntry.key === 'groupDimension') {\n      modifier.qDef.groupDimension = propEntry.value;\n    } else if (propEntry.key === 'dimensionToRank') {\n      modifier.qDef.dimensionToRank = propEntry.value;\n    } else if (propEntry.key === 'selectedDimension') {\n      modifier.qDef.selectedDimension = propEntry.value;\n    }\n  }\n}\n\n/**\n * Get the property definition for a modifier\n * @param {object} modifier\n * @param {object} properties\n * @param {object} layout\n * @param {function} setPropertyValue\n * @returns {object}\n */\nfunction getPropertyDefinition(modifier, properties, layout, setPropertyValue) {\n  const definition = {\n    type: 'items',\n    items: []\n  };\n  if (!modifier || !modifier.qDef || !layout) {\n    return definition;\n  }\n  // Add primary dimension\n  const groupDimensionVal = modifier.qDef.groupDimension || getPrimaryDimension(layout, modifier);\n  const groupDimension = {\n    type: 'string',\n    component: 'dropdown',\n    label: 'Group dimension',\n    ref: 'groupDimension',\n    defaultValue: groupDimensionVal,\n    options: getDimensions(layout)\n  };\n  groupDimension.change = (data) => {\n    setPropertyValue({\n      key: 'groupDimension',\n      value: data,\n      options: {\n        type: 'select'\n      }\n    });\n  };\n  definition.items.push(groupDimension);\n\n  // Add dimension to rank dropdown\n  const dimensionToRank = {\n    type: 'number',\n    component: 'dropdown',\n    label: 'Dimension to rank',\n    ref: 'dimensionToRank',\n    defaultValue: modifier.qDef.dimensionToRank || 1,\n    options: [{\n      value: 1,\n      label: 'First dimension'\n    }, {\n      value: 2,\n      label: 'Selected dimension'\n    }]\n  };\n  dimensionToRank.change = (data) => {\n    setPropertyValue({\n      key: 'dimensionToRank',\n      value: data,\n      options: {\n        type: 'select'\n      }\n    });\n  };\n  definition.items.push(dimensionToRank);\n\n  // Add selected dimension\n  const selectedDimensionVal = modifier.qDef.selectedDimension || getSelectedDimension(layout, modifier);\n  const selectedDimension = {\n    type: 'string',\n    component: 'dropdown',\n    label: 'Ranking dimension',\n    ref: 'selectedDimension',\n    defaultValue: selectedDimensionVal,\n    options: getDimensions(layout),\n    show: modifier.qDef.dimensionToRank === 2\n  };\n  selectedDimension.change = (data) => {\n    setPropertyValue({\n      key: 'selectedDimension',\n      value: data,\n      options: {\n        type: 'select'\n      }\n    });\n  };\n  definition.items.push(selectedDimension);\n\n  return definition;\n}\n\n/**\n * Initialize the modifier\n * @param {object} localeInfo\n */\nfunction initialize(localeInfo) {\n  if (MODIFIER.activationPromise) {\n    return MODIFIER.activationPromise;\n  }\n  MODIFIER.activationPromise = Promise.resolve();\n  return MODIFIER.activationPromise;\n}\n\nexport default {\n  initialize,\n  isDisabled,\n  getName,\n  getModifiers,\n  createModifier,\n  updateModifier,\n  getPropertyDefinition,\n  modifyProperties,\n  activationPromise: MODIFIER.activationPromise\n};\n\u0005End File\u0006import extend from 'extend';\nimport updateAlternative from '../alternative';\nimport getSoftPropertyHandler from '../property-handler';\n\n// ---------------------------\n// Modifier settings\n// ---------------------------\nconst MODIFIER = {\n  type: 'moving-average',\n  activationPromise: null\n};\n\n// ---------------------------\n// Modifier functions\n// ---------------------------\n\n/**\n * Add the qDef property to the modifier\n * @param {object} modifier\n * @param {object} options\n */\nfunction addQDefToModifier(modifier, options) {\n  const qDef = {\n    type: 'ma',\n    modifierProperties: true,\n    mode: 0,\n    n: 2\n  };\n  if (options && options.dimensions > 0) {\n    qDef.primaryDimension = options.defaultDimension;\n  }\n  modifier.qDef = qDef; // eslint-disable-line no-param-reassign\n}\n\n/**\n * Add title components to the modifier\n * @param {object} modifier\n * @param {object} options\n */\nfunction addTitleComponents(modifier, options) {\n  if (options && options.dimensions > 0) {\n    modifier.components = []; // eslint-disable-line no-param-reassign\n  }\n  modifier.components = modifier.components || []; // eslint-disable-line no-param-reassign\n  // Add type (disabled if we have numeric dimension)\n  modifier.components.push({ // eslint-disable-line no-param-reassign\n    key: 'type',\n    type: 'string',\n    value: 'Moving average',\n    undefined: true,\n    blocked: true\n  });\n}\n\n/**\n * Get primary dimension values\n * @param {object} layout\n * @returns {array}\n */\nfunction getDimensions(layout) {\n  if (!layout || !layout.qHyperCube || !layout.qHyperCube.qDimensionInfo) {\n    return [];\n  }\n  return layout.qHyperCube.qDimensionInfo.map(dim => ({\n    value: dim.qFallbackTitle,\n    label: dim.qFallbackTitle\n  }));\n}\n\n/**\n * Get the primary dimension based on the modifier\n * @param {object} layout\n * @param {object} modifier\n * @returns {string}\n */\nfunction getPrimaryDimension(layout, modifier) {\n  if (modifier && modifier.qDef && modifier.qDef.primaryDimension) {\n    return modifier.qDef.primaryDimension;\n  }\n  if (layout && layout.qHyperCube && layout.qHyperCube.qDimensionInfo && layout.qHyperCube.qDimensionInfo.length) {\n    return layout.qHyperCube.qDimensionInfo[0].qFallbackTitle;\n  }\n  return '';\n}\n\n/**\n * Get property options for the modifier\n * @param {object} modifier\n * @param {object} properties\n * @param {object} layout\n * @param {string} defaultDimension\n * @returns {object}\n */\nfunction getPropertyOptions(modifier, properties, layout, defaultDimension) {\n  if (!layout) {\n    return {};\n  }\n  const dimensions = getDimensions(layout);\n  const primaryDimension = getPrimaryDimension(layout, modifier);\n  const options = {\n    dimensions: dimensions.length,\n    defaultDimension: defaultDimension || primaryDimension\n  };\n  return options;\n}\n\n/**\n * Update the modifier based on the current state of the properties and layout\n * @param {object} modifier\n * @param {object} properties\n * @param {object} layout\n * @param {object} model\n */\nfunction updateModifier(modifier, properties, layout, model) {\n  // First check that we have a qDef object to store properties in\n  if (!modifier.qDef) {\n    addQDefToModifier(modifier, getPropertyOptions(modifier, properties, layout));\n  }\n  // Make sure we have type\n  if (!modifier.type) {\n    modifier.type = MODIFIER.type; // eslint-disable-line no-param-reassign\n  }\n  // Make sure we have components\n  if (!modifier.components) {\n    addTitleComponents(modifier, getPropertyOptions(modifier, properties, layout));\n  } else {\n    // Update dimension values\n    const dimComp = modifier.components.filter(c => c.key === 'primaryDimension');\n    if (dimComp.length > 0) {\n      dimComp[0].values = getDimensions(layout);\n    }\n  }\n}\n\n/**\n * Check if the button should be disabled\n * @param {object} properties\n * @param {object} layout\n * @returns {boolean}\n */\nfunction isDisabled(properties, layout) {\n  // Enable if we have one dimension and one measure\n  return !layout || !layout.qHyperCube || !layout.qHyperCube.qDimensionInfo ||\n    !layout.qHyperCube.qMeasureInfo || !layout.qHyperCube.qDimensionInfo.length;\n}\n\n/**\n * Get the name displayed on the button\n * @param {object} properties\n * @param {object} layout\n * @returns {string}\n */\nfunction getName(properties, layout) {\n  return 'Moving average';\n}\n\n/**\n * Get the available modifiers for this object\n * @param {object} options\n * @param {object} model\n * @param {object} layout\n * @param {object} properties\n */\nfunction getModifiers(options, model, layout, properties) {\n  const dimension = options.dimension || 0;\n  const measure = options.measure || 0;\n  const dimensions = getDimensions(layout);\n  const defaultDimension = dimensions.length > dimension ? dimensions[dimension].value : '';\n  const modifiers = [];\n  modifiers.push({\n    key: 'moving-average',\n    type: MODIFIER.type,\n    properties: getPropertyOptions({}, properties, layout, defaultDimension),\n    title: `Moving average on ${dimensions.length ? dimensions[0].value : 'dimension'}`\n  });\n  return modifiers;\n}\n\n/**\n * Create a modifier with the correct properties\n * @param {object} modifier\n * @param {object} properties\n * @param {object} layout\n * @param {object} defaultValues\n * @returns {object}\n */\nfunction createModifier(modifier, properties, layout, defaultValues) {\n  // Copy the current modifier\n  const m = extend(true, {}, modifier);\n  // Add default values for properties\n  if (!m.qDef) {\n    addQDefToModifier(m, getPropertyOptions(m, properties, layout, defaultValues.dimension));\n  }\n  // Add title and description\n  addTitleComponents(m, getPropertyOptions(m, properties, layout, defaultValues.dimension));\n\n  return m;\n}\n\n/**\n * Modify properties for a modifier\n * @param {object} modifier\n * @param {object} properties\n * @param {object} propEntry\n * @param {object} layout\n */\nfunction modifyProperties(modifier, properties, propEntry, layout) {\n  if (!modifier || !modifier.qDef) {\n    return;\n  }\n  const options = propEntry.options;\n  if (options.type === 'select') {\n    // Handle selectBox\n    if (propEntry.key === 'primaryDimension') {\n      modifier.qDef.primaryDimension = propEntry.value;\n    } else if (propEntry.key === 'mode') {\n      modifier.qDef.mode = propEntry.value;\n    }\n  } else if (options.type === 'input') {\n    // Handle input\n    if (propEntry.key === 'n') {\n      modifier.qDef.n = propEntry.value;\n    }\n  }\n}\n\n/**\n * Get the property definition for a modifier\n * @param {object} modifier\n * @param {object} properties\n * @param {object} layout\n * @param {function} setPropertyValue\n * @returns {object}\n */\nfunction getPropertyDefinition(modifier, properties, layout, setPropertyValue) {\n  const definition = {\n    type: 'items',\n    items: []\n  };\n  if (!modifier || !modifier.qDef || !layout) {\n    return definition;\n  }\n  // Add primary dimension\n  const primaryDimensionVal = modifier.qDef.primaryDimension || getPrimaryDimension(layout, modifier);\n  const primaryDimension = {\n    type: 'string',\n    component: 'dropdown',\n    label: 'Dimension',\n    ref: 'primaryDimension',\n    defaultValue: primaryDimensionVal,\n    options: getDimensions(layout)\n  };\n  primaryDimension.change = (data) => {\n    setPropertyValue({\n      key: 'primaryDimension',\n      value: data,\n      options: {\n        type: 'select'\n      }\n    });\n  };\n  definition.items.push(primaryDimension);\n\n  // Mode dropdown\n  const mode = {\n    type: 'number',\n    component: 'dropdown',\n    label: 'Mode',\n    ref: 'mode',\n    defaultValue: modifier.qDef.mode || 0,\n    options: [{\n      value: 0,\n      label: 'Simple'\n    }, {\n      value: 1,\n      label: 'Weighted'\n    }, {\n      value: 2,\n      label: 'Exponential'\n    }]\n  };\n  mode.change = (data) => {\n    setPropertyValue({\n      key: 'mode',\n      value: data,\n      options: {\n        type: 'select'\n      }\n    });\n  };\n  definition.items.push(mode);\n\n  // n - number of steps\n  const n = {\n    type: 'number',\n    component: 'slider',\n    label: (modifier.qDef.mode === 0 || modifier.qDef.mode === 1) ? 'Number of steps' : 'Smoothing factor',\n    ref: 'n',\n    defaultValue: modifier.qDef.n || 2,\n    min: 1,\n    max: 20,\n    step: 1\n  };\n  n.change = (data) => {\n    setPropertyValue({\n      key: 'n',\n      value: data,\n      options: {\n        type: 'input'\n      }\n    });\n  };\n  definition.items.push(n);\n\n  return definition;\n}\n\n/**\n * Initialize the modifier\n * @param {object} localeInfo\n */\nfunction initialize(localeInfo) {\n  if (MODIFIER.activationPromise) {\n    return MODIFIER.activationPromise;\n  }\n  MODIFIER.activationPromise = Promise.resolve();\n  return MODIFIER.activationPromise;\n}\n\nexport default {\n  initialize,\n  isDisabled,\n  getName,\n  getModifiers,\n  createModifier,\n  updateModifier,\n  getPropertyDefinition,\n  modifyProperties,\n  activationPromise: MODIFIER.activationPromise\n};\n\u0005End File\u0006# qlik-oss/qlik-modifiers\nimport extend from 'extend';\n\n/**\n * Generic function to update the qUndoExclude property\n * @param {object} layout - the current layout\n * @param {object} properties - the property tree\n * @param {object} model - enigma model\n * @param {function} setProperties - function for setting properties on model\n * @param {function} createSoftPatch - function for setting properties with soft patch\n * @param {string} modifierKey - the modifier key\n * @param {object} modifiers - the list of modifiers\n * @param {object} options - configuration options\n * @returns {Promise}\n */\nfunction updateAlternative(layout, properties, model, setProperties, createSoftPatch, modifierKey, modifiers, options = {}) {\n  // Build a new properties object, extended from the existing properties\n  const modifiedProperties = extend(true, {}, properties);\n\n  // Make sure we have qUndoExclude\n  modifiedProperties.qUndoExclude = modifiedProperties.qUndoExclude || {};\n\n  // Make sure we have the hypercube def\n  modifiedProperties.qUndoExclude.qHyperCubeDef = modifiedProperties.qUndoExclude.qHyperCubeDef || {};\n\n  // Make sure the source exists\n  modifiedProperties.qUndoExclude.qHyperCubeDef.qStateName = 'qUndoExclude';\n\n  // Store the measure index in the modifier\n  const measureIndex = options.measure ? options.measure : 0;\n\n  // Create a modifiers object\n  modifiedProperties.qUndoExclude.qHyperCubeDef.modifiers = {\n    modifier: modifierKey,\n    measures: [{\n      index: measureIndex,\n      label: properties.qHyperCubeDef.qMeasures[measureIndex].qDef.qLabel ||\n        properties.qHyperCubeDef.qMeasures[measureIndex].qDef.qLabelExpression ||\n        properties.qHyperCubeDef.qMeasures[measureIndex].qDef.qDef\n    }],\n    modifiers\n  };\n\n  // Apply the properties\n  return createSoftPatch(modifiedProperties).then(() => {\n    if (options.calculationService) {\n      // Trigger calculation manually\n      options.calculationService.registerForCalculation(layout).then((result) => {\n        if (result && result.length) {\n          // Wait for calculations to finish\n          Promise.all(result);\n        }\n      });\n    }\n  });\n}\n\nexport default updateAlternative;\n\u0005End File\u0006# qlik-oss/qlik-modifiers\n// global describe, it, expect\nimport Accumulation from '../../src/aggregation/accumulation';\nimport data from './data-with-one-dimension.json';\nimport dataWithTwoDimensions from './data-with-two-dimensions.json';\n\nconst field = {\n  label: 'My label',\n  primaryDimension: 'Year',\n  sortByLabel: 'Calculated Measure'\n};\n\nconst aggr = {\n  qDef: {\n    type: 'acc',\n    includeNull: 1\n  }\n};\n\nconst layout = {\n  qHyperCube: {\n    qDimensionInfo: [{\n      qFallbackTitle: 'Year'\n    }],\n    qMeasureInfo: [{\n      qFallbackTitle: 'Calculated Measure'\n    }]\n  }\n};\n\nconst properties = {\n  qHyperCubeDef: {\n    qDimensions: [{\n      qDef: {\n        qFieldDefs: ['Year'],\n        qFieldLabels: ['Year']\n      }\n    }],\n    qMeasures: [{\n      qDef: {\n        qDef: 'Calculated Measure',\n        qLabel: 'Calculated Measure'\n      }\n    }]\n  }\n};\n\nconst dimensionAndFieldList = {\n  dimensions: [\n    {\n      index: 0,\n      label: 'Year'\n    }\n  ],\n  measures: [\n    {\n      index: 1,\n      label: 'Calculated Measure'\n    }\n  ]\n};\n\nconst dimensionAndFieldListWithTwoDims = {\n  dimensions: [\n    {\n      index: 0,\n      label: 'Year'\n    },\n    {\n      index: 1,\n      label: 'Month'\n    }\n  ],\n  measures: [\n    {\n      index: 2,\n      label: 'Calculated Measure'\n    }\n  ]\n};\n\ndescribe('accumulation', () => {\n  it('should accumulate all values', async () => {\n    const app = {\n      createSessionObject: () => Promise.resolve({\n        getHyperCubeData: () => Promise.resolve([{\n          qMatrix: [\n            [{ qText: 2011 }, { qNum: 50 }],\n            [{ qText: 2012 }, { qNum: 100 }],\n            [{ qText: 2013 }, { qNum: 75 }],\n            [{ qText: 2014 }, { qNum: 150 }]\n          ]\n        }])\n      })\n    };\n    const result = await Accumulation(layout, app, properties, field, dimensionAndFieldList, aggr, data);\n    expect(result.values).to.deep.equal([50, 150, 225, 375]);\n  });\n\n  it('should use the already calculated data from the dimension', async () => {\n    const app = {\n      createSessionObject: () => Promise.resolve({\n        getHyperCubeData: () => Promise.resolve([{\n          qMatrix: [\n            [{ qText: 2011 }, { qNum: 50 }],\n            [{ qText: 2012 }, { qNum: 100 }],\n            [{ qText: 2013 }, { qNum: 75 }],\n            [{ qText: 2014 }, { qNum: 150 }]\n          ]\n        }])\n      })\n    };\n    dimensionAndFieldList.measureIndex = 1;\n    const result = await Accumulation(layout, app, properties, field, dimensionAndFieldList, aggr, data);\n    expect(result.values).to.deep.equal([50, 150, 225, 375]);\n  });\n\n  it('should use the provided index from measure to sort by', async () => {\n    const app = {\n      createSessionObject: () => Promise.resolve({\n        getHyperCubeData: () => Promise.resolve([{\n          qMatrix: [\n            [{ qText: 2011 }, { qNum: 50 }],\n            [{ qText: 2012 }, { qNum: 100 }],\n            [{ qText: 2013 }, { qNum: 75 }],\n            [{ qText: 2014 }, { qNum: 150 }]\n          ]\n        }])\n      })\n    };\n    field.measureIndex = 1;\n    const result = await Accumulation(layout, app, properties, field, dimensionAndFieldList, aggr, data);\n    expect(result.values).to.deep.equal([50, 150, 225, 375]);\n  });\n\n  it('should sort the values', async () => {\n    const app = {\n      createSessionObject: () => Promise.resolve({\n        getHyperCubeData: () => Promise.resolve([{\n          qMatrix: [\n            [{ qText: 2011 }, { qNum: 50 }],\n            [{ qText: 2012 }, { qNum: 150 }],\n            [{ qText: 2013 }, { qNum: 100 }],\n            [{ qText: 2014 }, { qNum: 75 }]\n          ]\n        }])\n      })\n    };\n    // Set it to a cross-dimension\n    field.sortByExpression = 'Sum(Sales)';\n    // Call with a set of data that is unsorted\n    const unsortedData = [\n      {\n        qMatrix: [\n          [{ qText: 2011 }, { qNum: 75 }],\n          [{ qText: 2012 }, { qNum: 150 }],\n          [{ qText: 2013 }, { qNum: 50 }],\n          [{ qText: 2014 }, { qNum: 100 }]\n        ]\n      }\n    ];\n    const result = await Accumulation(layout, app, properties, field, dimensionAndFieldList, aggr, unsortedData);\n    expect(result.values).to.deep.equal([50, 150, 250, 375]);\n  });\n\n  it('should sort the values with multiple dimensions', async () => {\n    const app = {\n      createSessionObject: () => Promise.resolve({\n        getHyperCubeData: () => Promise.resolve([{\n          qMatrix: [\n            [{ qText: 2011 }, { qNum: 50 }],\n            [{ qText: 2012 }, { qNum: 150 }],\n            [{ qText: 2013 }, { qNum: 100 }],\n            [{ qText: 2014 }, { qNum: 75 }]\n          ]\n        }])\n      })\n    };\n    // Set it to a cross-dimension\n    field.sortByExpression = 'Sum(Sales)';\n    // Call with a set of data that is unsorted\n    const result = await Accumulation(layout, app, properties, field, dimensionAndFieldListWithTwoDims, aggr, dataWithTwoDimensions);\n    expect(result.values).to.deep.equal([\n      50, 150, 250, 375, 25, 125, 225, 350, 75, 175, 275, 400, 0, 100, 200, 325\n    ]);\n  });\n\n  it('should handle lack of qMatrix in data', async () => {\n    const app = {\n      createSessionObject: () => Promise.resolve({\n        getHyperCubeData: () => Promise.resolve([{\n          qMatrix: [\n            [{ qText: 2011 }, { qNum: 50 }],\n            [{ qText: 2012 }, { qNum: 100 }],\n            [{ qText: 2013 }, { qNum: 75 }],\n            [{ qText: 2014 }, { qNum: 150 }]\n          ]\n        }])\n      })\n    };\n    const result = await Accumulation(layout, app, properties, field, dimensionAndFieldList, aggr, [{\n      qArea: {}\n    }]);\n    expect(result.values).to.deep.equal([]);\n  });\n\n  it('should handle empty layout', async () => {\n    const app = {\n      createSessionObject: () => Promise.resolve({\n        getHyperCubeData: () => Promise.resolve([{\n          qMatrix: [\n            [{ qText: 2011 }, { qNum: 50 }],\n            [{ qText: 2012 }, { qNum: 100 }],\n            [{ qText: 2013 }, { qNum: 75 }],\n            [{ qText: 2014 }, { qNum: 150 }]\n          ]\n        }])\n      })\n    };\n    layout.qHyperCube.qDimensionInfo = [];\n    const result = await Accumulation(layout, app, properties, field, dimensionAndFieldList, aggr, data);\n    expect(result.values).to.deep.equal([0]);\n  });\n\n  describe('getSortByDef', () => {\n    describe('when aggr.qDef.sortBy contains sortByDimension and sortByExpression', () => {\n      it('should set both sortByLabel and sortByExpression', () => {\n        const aggrWithSortBy = {\n          qDef: {\n            sortBy: {\n              sortByDimension: 'sortBy',\n              sortByExpression: 'expression'\n            }\n          }\n        };\n        const fieldObj = {};\n        const func = Accumulation.__get__('getSortByDef');\n        func(aggrWithSortBy, fieldObj, layout);\n        expect(fieldObj.sortByLabel).to.equal('sortBy');\n        expect(fieldObj.sortByExpression).to.equal('expression');\n      });\n    });\n\n    describe('when aggr.qDef.sortBy contains sortByDimension but not sortByExpression', () => {\n      it('should set just sortByLabel', () => {\n        const aggrWithSortBy = {\n          qDef: {\n            sortBy: {\n              sortByDimension: 'sortBy'\n            }\n          }\n        };\n        const fieldObj = {};\n        const func = Accumulation.__get__('getSortByDef');\n        func(aggrWithSortBy, fieldObj, layout);\n        expect(fieldObj.sortByLabel).to.equal('sortBy');\n        expect(fieldObj.sortByExpression).to.be.undefined;\n      });\n    });\n\n    describe('when aggr.qDef.sortBy contains just sortByExpression', () => {\n      it('should set both sortByLabel and sortByExpression', () => {\n        const aggrWithSortBy = {\n          qDef: {\n            sortBy: {\n              sortByExpression: 'expression'\n            }\n          }\n        };\n        const fieldObj = {};\n        const func = Accumulation.__get__('getSortByDef');\n        func(aggrWithSortBy, fieldObj, layout);\n        expect(fieldObj.sortByLabel).to.equal('sortByExpression');\n        expect(fieldObj.sortByExpression).to.equal('expression');\n      });\n    });\n\n    describe('when aggr.qDef.sortBy is undefined', () => {\n      it('should set just sortByLabel', () => {\n        const aggrWithSortBy = {\n          qDef: {\n          }\n        };\n        const fieldObj = {};\n        const func = Accumulation.__get__('getSortByDef');\n        func(aggrWithSortBy, fieldObj, layout);\n        expect(fieldObj.sortByLabel).to.equal('Calculated Measure');\n        expect(fieldObj.sortByExpression).to.be.undefined;\n      });\n    });\n  });\n\n  describe('getCrossTableProperties', () => {\n    it('should create a correct cross table', () => {\n      const func = Accumulation.__get__('getCrossTableProperties');\n      field.sortByExpression = 'Sum(Sales)';\n      const result = func(field, dimensionAndFieldList);\n      expect(result.qDimensions).to.deep.equal([{\n        qLibraryId: '',\n        qDef: {\n          qGrouping: 'N',\n          qFieldDefs: [''],\n          qFieldLabels: ['']\n        },\n        qNullSuppression: true\n      }]);\n      expect(result.qMeasures).to.deep.equal([{\n        qDef: {\n          qDef: 'Sum(Sales)',\n          qLabel: 'Calculated Measure'\n        },\n        qSortBy: {\n          qSortByNumeric: 1\n        }\n      }]);\n    });\n\n    it('should create a correct cross table with measure', () => {\n      const func = Accumulation.__get__('getCrossTableProperties');\n      delete field.sortByExpression;\n      const result = func(field, dimensionAndFieldList);\n      expect(result.qDimensions).to.deep.equal([{\n        qLibraryId: '',\n        qDef: {\n          qGrouping: 'N',\n          qFieldDefs: [''],\n          qFieldLabels: ['']\n        },\n        qNullSuppression: true\n      }]);\n      expect(result.qMeasures).to.deep.equal([{\n        qDef: {\n          qDef: 'Calculated Measure',\n          qLabel: 'Calculated Measure'\n        },\n        qSortBy: {\n          qSortByNumeric: 1\n        }\n      }]);\n    });\n  });\n\n  describe('addDimensionAndFields', () => {\n    it('should add correct objects to dimensionAndFieldList', () => {\n      const fieldObj = {\n        primaryDimension: 'Year',\n        sortByLabel: 'Calculated Measure'\n      };\n      const dimAndFieldList = {\n        dimensions: [],\n        fields: []\n      };\n      const func = Accumulation.__get__('addDimensionAndFields');\n      func(dimAndFieldList, layout.qHyperCube.qDimensionInfo, fieldObj, properties.qHyperCubeDef);\n      expect(dimAndFieldList.dimensions).to.deep.equal([{\n        index: 0,\n        label: 'Year'\n      }]);\n      expect(dimAndFieldList.measureIndex).to.equal(1);\n    });\n\n    it('should add correct objects to dimensionAndFieldList with expression', () => {\n      const fieldObj = {\n        primaryDimension: 'Year',\n        sortByLabel: 'sortByExpression',\n        sortByExpression: 'Sum(Sales)'\n      };\n      const dimAndFieldList = {\n        dimensions: [],\n        fields: []\n      };\n      const func = Accumulation.__get__('addDimensionAndFields');\n      func(dimAndFieldList, layout.qHyperCube.qDimensionInfo, fieldObj, properties.qHyperCubeDef);\n      expect(dimAndFieldList.dimensions).to.deep.equal([{\n        index: 0,\n        label: 'Year'\n      }]);\n      expect(dimAndFieldList.fields).to.deep.equal([{\n        isDimension: false,\n        qDef: {\n          qDef: 'Sum(Sales)',\n          qLabel: 'sortByExpression'\n        }\n      }]);\n    });\n  });\n\n  describe('getMeasureToSortByFromDataPages', () => {\n    it('should create a correct object for sorting', () => {\n      const func = Accumulation.__get__('getMeasureToSortByFromDataPages');\n      const result = func(field, dimensionAndFieldList, data);\n      expect(result).to.deep.equal({\n        dimensions: ['2011', '2012', '2013', '2014'],\n        sortByValue: [50, 100, 75, 150]\n      });\n    });\n  });\n});\n\u0005End File\u0006# qlik-oss/qlik-modifiers\n// global describe, it, expect\nimport Calculate from '../../src/services/calculation-service';\n\nconst layout = {\n  qHyperCube: {\n    qDimensionInfo: [\n      {\n        qFallbackTitle: 'Year'\n      }\n    ],\n    qMeasureInfo: [\n      {\n        qFallbackTitle: 'Calculated Measure'\n      }\n    ]\n  }\n};\n\nconst properties = {\n  qUndoExclude: {\n    qHyperCubeDef: {\n      modifiers: {\n        modifier: 'acc',\n        measures: [\n          {\n            index: 0,\n            label: 'Calculated Measure'\n          }\n        ],\n        modifiers: [\n          {\n            type: 'accumulation',\n            qDef: {\n              type: 'acc',\n              primaryDimension: 'Year',\n              includeNull: 1\n            }\n          }\n        ]\n      }\n    }\n  },\n  qHyperCubeDef: {\n    qDimensions: [{\n      qDef: {\n        qFieldDefs: ['Year'],\n        qFieldLabels: ['Year']\n      }\n    }],\n    qMeasures: [{\n      qDef: {\n        qDef: 'Calculated Measure',\n        qLabel: 'Calculated Measure'\n      }\n    }]\n  }\n};\n\nconst dataPages = [\n  {\n    qMatrix: [\n      [{ qText: 2011 }, { qNum: 50 }],\n      [{ qText: 2012 }, { qNum: 100 }],\n      [{ qText: 2013 }, { qNum: 75 }],\n      [{ qText: 2014 }, { qNum: 150 }]\n    ]\n  }\n];\n\ndescribe('calculation-service', () => {\n  describe('initializeCalculationService', () => {\n    let calc = null;\n    let model = null;\n    let calculationSpy = null;\n\n    beforeEach(() => {\n      calculationSpy = sinon.spy(() => Promise.resolve([]));\n      model = {\n        app: {},\n        properties,\n        getHyperCubeData: () => Promise.resolve(dataPages),\n        calculateAggregation: calculationSpy\n      };\n      calc = Calculate.initializeCalculationService(model);\n    });\n\n    it('should return object with registerForCalculation function', async () => {\n      expect(calc).to.be.an('object');\n      expect(calc.registerForCalculation).to.be.a('function');\n    });\n\n    it('should resolve empty array if model.app is missing', async () => {\n      model.app = null;\n      const result = await calc.registerForCalculation(layout);\n      expect(result).to.deep.equal([]);\n    });\n\n    it('should resolve empty array if model.properties is missing', async () => {\n      model.properties = null;\n      const result = await calc.registerForCalculation(layout);\n      expect(result).to.deep.equal([]);\n    });\n\n    it('should resolve empty array if model.properties.qUndoExclude is missing', async () => {\n      model.properties.qUndoExclude = null;\n      const result = await calc.registerForCalculation(layout);\n      expect(result).to.deep.equal([]);\n    });\n\n    it('should resolve empty array if model.properties.qUndoExclude.qHyperCubeDef is missing', async () => {\n      model.properties.qUndoExclude.qHyperCubeDef = null;\n      const result = await calc.registerForCalculation(layout);\n      expect(result).to.deep.equal([]);\n    });\n\n    it('should resolve empty array if layout is missing', async () => {\n      const result = await calc.registerForCalculation(null);\n      expect(result).to.deep.equal([]);\n    });\n\n    it('should resolve empty array if layout.qHyperCube is missing', async () => {\n      const result = await calc.registerForCalculation({});\n      expect(result).to.deep.equal([]);\n    });\n\n    it('should not call calculateAggregation if modifiers is missing', async () => {\n      model.properties.qUndoExclude.qHyperCubeDef.modifiers = null;\n      const result = await calc.registerForCalculation(layout);\n      expect(calculationSpy.callCount).to.equal(0);\n    });\n\n    it('should not call calculateAggregation if modifiers.modifier is missing', async () => {\n      model.properties.qUndoExclude.qHyperCubeDef.modifiers.modifier = null;\n      const result = await calc.registerForCalculation(layout);\n      expect(calculationSpy.callCount).to.equal(0);\n    });\n\n    it('should not call calculateAggregation if modifiers.measures is missing', async () => {\n      model.properties.qUndoExclude.qHyperCubeDef.modifiers.measures = null;\n      const result = await calc.registerForCalculation(layout);\n      expect(calculationSpy.callCount).to.equal(0);\n    });\n\n    describe('processCalcs', () => {\n      let processCalcs = null;\n      let modifiers = null;\n      let accumulationCalculate = null;\n\n      beforeEach(() => {\n        accumulationCalculate = sinon.stub().returns(Promise.resolve({\n          values: [1, 2, 3],\n          sourceValues: [1, 2, 3]\n        }));\n        processCalcs = Calculate.__get__('processCalcs');\n        Calculate.__Rewire__('accumulationCalc', accumulationCalculate);\n        modifiers = {\n          modifier: 'acc',\n          measures: [\n            {\n              index: 0,\n              label: 'Calculated Measure'\n            }\n          ],\n          modifiers: [\n            {\n              type: 'accumulation',\n              qDef: {\n                type: 'acc',\n                primaryDimension: 'Year',\n                includeNull: 1\n              }\n            }\n          ]\n        };\n      });\n\n      it('should call accumulationCalc for accumulation calculation', async () => {\n        await processCalcs(modifiers, layout, model.app, properties, [], {}, [], model);\n        expect(accumulationCalculate.callCount).to.equal(1);\n      });\n\n      it('should handle multiple modifiers', async () => {\n        // Add a second modifier\n        modifiers.modifiers.push({\n          type: 'moving-average',\n          qDef: {\n            type: 'ma',\n            primaryDimension: 'Year',\n            includeNull: 1\n          }\n        });\n        const movingAverageCalculate = sinon.stub().returns(Promise.resolve({\n          values: [1, 2, 3],\n          sourceValues: [1, 2, 3]\n        }));\n        Calculate.__Rewire__('movingAverageCalc', movingAverageCalculate);\n        await processCalcs(modifiers, layout, model.app, properties, [], {}, [], model);\n        expect(accumulationCalculate.callCount).to.equal(1);\n        expect(movingAverageCalculate.callCount).to.equal(1);\n      });\n\n      it('should update existing calculatedMeasures', async () => {\n        model.calculatedMeasures = [{\n          measureIndex: 0,\n          calculatedValues: [{\n            type: 'acc',\n            values: [3, 4, 5],\n            sourceValues: [3, 4, 5]\n          }]\n        }];\n        await processCalcs(modifiers, layout, model.app, properties, [], {}, [], model);\n        expect(model.calculatedMeasures[0].calculatedValues[0]).to.deep.equal({\n          type: 'acc',\n          values: [1, 2, 3],\n          sourceValues: [1, 2, 3]\n        });\n      });\n\n      it('should add new calculatedMeasures', async () => {\n        model.calculatedMeasures = [{\n          measureIndex: 1,\n          calculatedValues: [{\n            type: 'acc',\n            values: [3, 4, 5],\n            sourceValues: [3, 4, 5]\n          }]\n        }];\n        await processCalcs(modifiers, layout, model.app, properties, [], {}, [], model);\n        expect(model.calculatedMeasures.length).to.equal(2);\n      });\n\n      it('should add new calculatedValues', async () => {\n        model.calculatedMeasures = [{\n          measureIndex: 0,\n          calculatedValues: [{\n            type: 'ma',\n            values: [3, 4, 5],\n            sourceValues: [3, 4, 5]\n          }]\n        }];\n        await processCalcs(modifiers, layout, model.app, properties, [], {}, [], model);\n        expect(model.calculatedMeasures[0].calculatedValues.length).to.equal(2);\n      });\n    });\n\n    describe('calculateAggregation', () => {\n      let calculateAggregation = null;\n      let definition = null;\n      let accumulationCalculate = null;\n\n      beforeEach(() => {\n        accumulationCalculate = sinon.stub().returns(Promise.resolve({\n          values: [1, 2, 3],\n          sourceValues: [1, 2, 3]\n        }));\n        calculateAggregation = Calculate.__get__('calculateAggregation');\n        Calculate.__Rewire__('accumulationCalc', accumulationCalculate);\n        definition = {\n          qDef: {\n            type: 'acc',\n            qLabel: 'Calculated Measure'\n          }\n        };\n      });\n\n      it('should call accumulationCalc for accumulation calculation', async () => {\n        await calculateAggregation(layout, model.app, properties, definition, {}, []);\n        expect(accumulationCalculate.callCount).to.equal(1);\n      });\n\n      it('should call movingAverageCalc for moving-average calculation', async () => {\n        definition.qDef.type = 'ma';\n        const movingAverageCalculate = sinon.stub().returns(Promise.resolve({\n          values: [1, 2, 3],\n          sourceValues: [1, 2, 3]\n        }));\n        Calculate.__Rewire__('movingAverageCalc', movingAverageCalculate);\n        await calculateAggregation(layout, model.app, properties, definition, {}, []);\n        expect(movingAverageCalculate.callCount).to.equal(1);\n      });\n\n      it('should call differenceCalc for difference calculation', async () => {\n        definition.qDef.type = 'difference';\n        const differenceCalculate = sinon.stub().returns(Promise.resolve({\n          values: [1, 2, 3],\n          sourceValues: [1, 2, 3]\n        }));\n        Calculate.__Rewire__('differenceCalc', differenceCalculate);\n        await calculateAggregation(layout, model.app, properties, definition, {}, []);\n        expect(differenceCalculate.callCount).to.equal(1);\n      });\n\n      it('should call rankingCalc for ranking calculation', async () => {\n        definition.qDef.type = 'ranking';\n        const rankingCalculate = sinon.stub().returns(Promise.resolve({\n          values: [1, 2, 3],\n          sourceValues: [1, 2, 3]\n        }));\n        Calculate.__Rewire__('rankingCalc', rankingCalculate);\n        await calculateAggregation(layout, model.app, properties, definition, {}, []);\n        expect(rankingCalculate.callCount).to.equal(1);\n      });\n\n      it('should handle calculation that does not exist', async () => {\n        definition.qDef.type = 'unknown';\n        const result = await calculateAggregation(layout, model.app, properties, definition, {}, []);\n        expect(result).to.deep.equal({\n          values: [],\n          sourceValues: []\n        });\n      });\n    });\n  });\n});\n\u0005End File\u0006# test/unit/difference.spec.js\n// global describe, it, expect\nimport Difference from '../../src/aggregation/difference';\nimport data from './data-with-one-dimension.json';\nimport dataWithTwoDimensions from './data-with-two-dimensions.json';\n\nconst field = {\n  label: 'My label',\n  primaryDimension: 'Year',\n  relativeDimension: 'Year',\n  relativeTo: 1\n};\n\nconst aggr = {\n  qDef: {\n    type: 'difference',\n    primaryDimension: 'Year',\n    relativeDimension: 'Year',\n    relativeTo: 1\n  }\n};\n\nconst layout = {\n  qHyperCube: {\n    qDimensionInfo: [{\n      qFallbackTitle: 'Year'\n    }],\n    qMeasureInfo: [{\n      qFallbackTitle: 'Calculated Measure'\n    }]\n  }\n};\n\nconst properties = {\n  qHyperCubeDef: {\n    qDimensions: [{\n      qDef: {\n        qFieldDefs: ['Year'],\n        qFieldLabels: ['Year']\n      }\n    }],\n    qMeasures: [{\n      qDef: {\n        qDef: 'Calculated Measure',\n        qLabel: 'Calculated Measure'\n      }\n    }]\n  }\n};\n\nconst dimensionAndFieldList = {\n  dimensions: [\n    {\n      index: 0,\n      label: 'Year'\n    }\n  ],\n  measures: [\n    {\n      index: 1,\n      label: 'My label'\n    }\n  ]\n};\n\nconst dimensionAndFieldListWithTwoDims = {\n  dimensions: [\n    {\n      index: 0,\n      label: 'Year'\n    },\n    {\n      index: 1,\n      label: 'Month'\n    }\n  ],\n  measures: [\n    {\n      index: 2,\n      label: 'My label'\n    }\n  ]\n};\n\ndescribe('difference', () => {\n  it('should use RELATIVE_TO_FIRST mode correctly', async () => {\n    const app = {};\n    const result = await Difference(layout, app, properties, field, dimensionAndFieldList, aggr, data);\n    expect(result.values).to.deep.equal([0, 50, 25, 100]);\n  });\n\n  it('should use RELATIVE_TO_ALL mode correctly', async () => {\n    field.relativeTo = 2;\n    const app = {};\n    const result = await Difference(layout, app, properties, field, dimensionAndFieldList, aggr, data);\n    expect(result.values).to.deep.equal([0, 50, -25, 75]);\n  });\n\n  it('should use RELATIVE_TO_SELECTED mode correctly', async () => {\n    field.relativeTo = 3;\n    field.relativeDimension = 'Year';\n    const app = {};\n    const result = await Difference(layout, app, properties, field, dimensionAndFieldList, aggr, data);\n    expect(result.values).to.deep.equal([0, 50, 25, 100]);\n  });\n\n  it('should handle empty layout', async () => {\n    layout.qHyperCube.qDimensionInfo = [];\n    const app = {};\n    const result = await Difference(layout, app, properties, field, dimensionAndFieldList, aggr, data);\n    expect(result.values).to.deep.equal([0]);\n  });\n\n  describe('setPrimaryDimension', () => {\n    beforeEach(() => {\n      layout.qHyperCube.qDimensionInfo = [{\n        qFallbackTitle: 'Year'\n      }];\n    });\n\n    describe('when aggr.qDef.primaryDimension is set', () => {\n      it('should set primaryDimension from aggr.qDef.primaryDimension', () => {\n        const func = Difference.__get__('setPrimaryDimension');\n        const aggrObj = {\n          qDef: {\n            primaryDimension: 'Month'\n          }\n        };\n        const fieldObj = {};\n        func(aggrObj, fieldObj, layout.qHyperCube.qDimensionInfo);\n        expect(fieldObj.primaryDimension).to.equal('Month');\n      });\n    });\n\n    describe('when aggr.qDef.primaryDimension is missing', () => {\n      it('should set primaryDimension from first dimension', () => {\n        const func = Difference.__get__('setPrimaryDimension');\n        const aggrObj = {\n          qDef: {\n          }\n        };\n        const fieldObj = {};\n        func(aggrObj, fieldObj, layout.qHyperCube.qDimensionInfo);\n        expect(fieldObj.primaryDimension).to.equal('Year');\n      });\n    });\n\n    describe('when no dimension exists', () => {\n      it('should set primaryDimension to undefined', () => {\n        const func = Difference.__get__('setPrimaryDimension');\n        const aggrObj = {\n          qDef: {\n          }\n        };\n        const fieldObj = {};\n        func(aggrObj, fieldObj, []);\n        expect(fieldObj.primaryDimension).to.be.undefined;\n      });\n    });\n  });\n\n  describe('setRelativeDimension', () => {\n    beforeEach(() => {\n      layout.qHyperCube.qDimensionInfo = [{\n        qFallbackTitle: 'Year'\n      }];\n    });\n\n    describe('when relativeTo === RELATIVE_TO_SELECTED and aggr.qDef.relativeDimension is set', () => {\n      it('should set relativeDimension from aggr.qDef.relativeDimension', () => {\n        const func = Difference.__get__('setRelativeDimension');\n        const aggrObj = {\n          qDef: {\n            relativeTo: 3,\n            relativeDimension: 'Month'\n          }\n        };\n        const fieldObj = {};\n        func(aggrObj, fieldObj, layout.qHyperCube.qDimensionInfo);\n        expect(fieldObj.relativeDimension).to.equal('Month');\n      });\n    });\n\n    describe('when relativeTo === RELATIVE_TO_SELECTED and aggr.qDef.relativeDimension is missing', () => {\n      it('should set relativeDimension from field.primaryDimension', () => {\n        const func = Difference.__get__('setRelativeDimension');\n        const aggrObj = {\n          qDef: {\n            relativeTo: 3\n          }\n        };\n        const fieldObj = {\n          primaryDimension: 'Month'\n        };\n        func(aggrObj, fieldObj, layout.qHyperCube.qDimensionInfo);\n        expect(fieldObj.relativeDimension).to.equal('Month');\n      });\n    });\n\n    describe('when relativeTo !== RELATIVE_TO_SELECTED', () => {\n      it('should set relativeDimension from first dimension', () => {\n        const func = Difference.__get__('setRelativeDimension');\n        const aggrObj = {\n          qDef: {\n          }\n        };\n        const fieldObj = {};\n        func(aggrObj, fieldObj, layout.qHyperCube.qDimensionInfo);\n        expect(fieldObj.relativeDimension).to.equal('Year');\n      });\n    });\n\n    describe('when no dimension exists', () => {\n      it('should set relativeDimension to undefined', () => {\n        const func = Difference.__get__('setRelativeDimension');\n        const aggrObj = {\n          qDef: {\n          }\n        };\n        const fieldObj = {};\n        func(aggrObj, fieldObj, []);\n        expect(fieldObj.relativeDimension).to.be.undefined;\n      });\n    });\n  });\n\n  describe('addDimensionAndFields', () => {\n    it('should add primaryDimension to dimensionAndFieldList', () => {\n      const func = Difference.__get__('addDimensionAndFields');\n      const dimensionsObj = [{\n        qFallbackTitle: 'Year'\n      }];\n      const fieldObj = {\n        primaryDimension: 'Year'\n      };\n      const dimAndFieldList = {\n        dimensions: [],\n        fields: []\n      };\n      func(dimAndFieldList, dimensionsObj, fieldObj);\n      expect(dimAndFieldList.dimensions).to.deep.equal([{\n        index: -1,\n        label: 'Year'\n      }]);\n    });\n\n    it('should add relativeDimension to dimensionAndFieldList', () => {\n      const func = Difference.__get__('addDimensionAndFields');\n      const dimensionsObj = [{\n        qFallbackTitle: 'Year'\n      }];\n      const fieldObj = {\n        relativeDimension: 'Year'\n      };\n      const dimAndFieldList = {\n        dimensions: [],\n        fields: []\n      };\n      func(dimAndFieldList, dimensionsObj, fieldObj);\n      expect(dimAndFieldList.dimensions).to.deep.equal([{\n        index: -1,\n        label: 'Year'\n      }]);\n    });\n\n    it('should not add primaryDimension to dimensionAndFieldList if it already exists', () => {\n      const func = Difference.__get__('addDimensionAndFields');\n      const dimensionsObj = [{\n        qFallbackTitle: 'Year'\n      }];\n      const fieldObj = {\n        primaryDimension: 'Year'\n      };\n      const dimAndFieldList = {\n        dimensions: [{\n          index: 0,\n          label: 'Year'\n        }],\n        fields: []\n      };\n      func(dimAndFieldList, dimensionsObj, fieldObj);\n      expect(dimAndFieldList.dimensions).to.deep.equal([{\n        index: 0,\n        label: 'Year'\n      }]);\n    });\n\n    it('should handle missing field.primaryDimension', () => {\n      const func = Difference.__get__('addDimensionAndFields');\n      const dimensionsObj = [{\n        qFallbackTitle: 'Year'\n      }];\n      const fieldObj = {\n      };\n      const dimAndFieldList = {\n        dimensions: [],\n        fields: []\n      };\n      func(dimAndFieldList, dimensionsObj, fieldObj);\n      expect(dimAndFieldList.dimensions).to.deep.equal([]);\n    });\n\n    it('should handle missing layout.qHyperCube.qDimensionInfo', () => {\n      const func = Difference.__get__('addDimensionAndFields');\n      const dimensionsObj = null;\n      const fieldObj = {\n        primaryDimension: 'Year'\n      };\n      const dimAndFieldList = {\n        dimensions: [],\n        fields: []\n      };\n      func(dimAndFieldList, dimensionsObj, fieldObj);\n      expect(dimAndFieldList.dimensions).to.deep.equal([]);\n    });\n  });\n\n  describe('getDataFromHyperCube', () => {\n    it('should get data from dataPages', () => {\n      const func = Difference.__get__('getDataFromHyperCube');\n      const result = func(data, 1);\n      expect(result).to.deep.equal({\n        dimensions: [\n          ['2011'], ['2012'], ['2013'], ['2014']\n        ],\n        measures: [\n          [50], [100], [75], [150]\n        ]\n      });\n    });\n  });\n\n  describe('getDimensionIndex', () => {\n    it('should get index of dimension with qFallbackTitle', () => {\n      const func = Difference.__get__('getDimensionIndex');\n      const result = func([{\n        qFallbackTitle: 'Year'\n      }, {\n        qFallbackTitle: 'Month'\n      }], 'Month');\n      expect(result).to.equal(1);\n    });\n\n    it('should return -1 if dimension is missing', () => {\n      const func = Difference.__get__('getDimensionIndex');\n      const result = func([{\n        qFallbackTitle: 'Year'\n      }, {\n        qFallbackTitle: 'Month'\n      }], 'Quarter');\n      expect(result).to.equal(-1);\n    });\n  });\n\n  describe('getDimensionIndices', () => {\n    it('should get indices of primaryDimension and relativeDimension', () => {\n      const func = Difference.__get__('getDimensionIndices');\n      const result = func([{\n        qFallbackTitle: 'Year'\n      }, {\n        qFallbackTitle: 'Month'\n      }], {\n        primaryDimension: 'Year',\n        relativeDimension: 'Month'\n      });\n      expect(result).to.deep.equal({\n        primaryDimension: 0,\n        relativeDimension: 1\n      });\n    });\n  });\n\n  describe('getData', () => {\n    it('should get data from primary and relative dimensions', async () => {\n      const func = Difference.__get__('getData');\n      const result = await func(layout, field, dimensionAndFieldList, data);\n      expect(result).to.deep.equal({\n        sourceData: [50, 100, 75, 150],\n        primaryDimension: ['2011', '2012', '2013', '2014'],\n        relativeDimension: ['2011', '2012', '2013', '2014']\n      });\n    });\n  });\n});\n\u0005End File\u0006# qlik-oss/qlik-modifiers\n# test/unit/moving-average.spec.js\n// global describe, it, expect\nimport MovingAverage from '../../src/aggregation/moving-average';\nimport data from './data-with-one-dimension.json';\n\nconst field = {\n  label: 'My label',\n  primaryDimension: 'Year'\n};\n\nconst aggr = {\n  qDef: {\n    type: 'ma',\n    primaryDimension: 'Year',\n    mode: 0,\n    n: 2\n  }\n};\n\nconst layout = {\n  qHyperCube: {\n    qDimensionInfo: [{\n      qFallbackTitle: 'Year'\n    }],\n    qMeasureInfo: [{\n      qFallbackTitle: 'Calculated Measure'\n    }]\n  }\n};\n\nconst properties = {\n  qHyperCubeDef: {\n    qDimensions: [{\n      qDef: {\n        qFieldDefs: ['Year'],\n        qFieldLabels: ['Year']\n      }\n    }],\n    qMeasures: [{\n      qDef: {\n        qDef: 'Calculated Measure',\n        qLabel: 'Calculated Measure'\n      }\n    }]\n  }\n};\n\nconst dimensionAndFieldList = {\n  dimensions: [\n    {\n      index: 0,\n      label: 'Year'\n    }\n  ],\n  measures: [\n    {\n      index: 1,\n      label: 'My label'\n    }\n  ]\n};\n\ndescribe('moving-average', () => {\n  it('should use simple mode correctly', async () => {\n    const app = {};\n    const result = await MovingAverage(layout, app, properties, field, dimensionAndFieldList, aggr, data);\n    expect(result.values).to.deep.equal([NaN, 75, 87.5, 112.5]);\n  });\n\n  it('should use weighted mode correctly', async () => {\n    aggr.qDef.mode = 1;\n    const app = {};\n    const result = await MovingAverage(layout, app, properties, field, dimensionAndFieldList, aggr, data);\n    expect(result.values).to.deep.equal([NaN, 83.33333333333333, 83.33333333333333, 125]);\n  });\n\n  it('should use exponential mode correctly', async () => {\n    aggr.qDef.mode = 2;\n    aggr.qDef.n = 1;\n    const app = {};\n    const result = await MovingAverage(layout, app, properties, field, dimensionAndFieldList, aggr, data);\n    expect(result.values).to.deep.equal([50, 75, 75, 112.5]);\n  });\n\n  it('should handle empty layout', async () => {\n    layout.qHyperCube.qDimensionInfo = [];\n    const app = {};\n    const result = await MovingAverage(layout, app, properties, field, dimensionAndFieldList, aggr, data);\n    expect(result.values).to.deep.equal([0]);\n  });\n\n  describe('setPrimaryDimension', () => {\n    beforeEach(() => {\n      layout.qHyperCube.qDimensionInfo = [{\n        qFallbackTitle: 'Year'\n      }];\n    });\n\n    describe('when aggr.qDef.primaryDimension is set', () => {\n      it('should set primaryDimension from aggr.qDef.primaryDimension', () => {\n        const func = MovingAverage.__get__('setPrimaryDimension');\n        const aggrObj = {\n          qDef: {\n            primaryDimension: 'Month'\n          }\n        };\n        const fieldObj = {};\n        func(aggrObj, fieldObj, layout.qHyperCube.qDimensionInfo);\n        expect(fieldObj.primaryDimension).to.equal('Month');\n      });\n    });\n\n    describe('when aggr.qDef.primaryDimension is missing', () => {\n      it('should set primaryDimension from first dimension', () => {\n        const func = MovingAverage.__get__('setPrimaryDimension');\n        const aggrObj = {\n          qDef: {\n          }\n        };\n        const fieldObj = {};\n        func(aggrObj, fieldObj, layout.qHyperCube.qDimensionInfo);\n        expect(fieldObj.primaryDimension).to.equal('Year');\n      });\n    });\n\n    describe('when no dimension exists', () => {\n      it('should set primaryDimension to undefined', () => {\n        const func = MovingAverage.__get__('setPrimaryDimension');\n        const aggrObj = {\n          qDef: {\n          }\n        };\n        const fieldObj = {};\n        func(aggrObj, fieldObj, []);\n        expect(fieldObj.primaryDimension).to.be.undefined;\n      });\n    });\n  });\n\n  describe('getDataFromHyperCube', () => {\n    it('should get data from dataPages', () => {\n      const func = MovingAverage.__get__('getDataFromHyperCube');\n      const result = func(data, 1);\n      expect(result).to.deep.equal({\n        dimensions: [\n          ['2011'], ['2012'], ['2013'], ['2014']\n        ],\n        measures: [\n          [50], [100], [75], [150]\n        ]\n      });\n    });\n  });\n\n  describe('getDimensionIndex', () => {\n    it('should get index of dimension with qFallbackTitle', () => {\n      const func = MovingAverage.__get__('getDimensionIndex');\n      const result = func([{\n        qFallbackTitle: 'Year'\n      }, {\n        qFallbackTitle: 'Month'\n      }], 'Month');\n      expect(result).to.equal(1);\n    });\n\n    it('should return -1 if dimension is missing', () => {\n      const func = MovingAverage.__get__('getDimensionIndex');\n      const result = func([{\n        qFallbackTitle: 'Year'\n      }, {\n        qFallbackTitle: 'Month'\n      }], 'Quarter');\n      expect(result).to.equal(-1);\n    });\n  });\n\n  describe('getData', () => {\n    it('should get data from primaryDimension', async () => {\n      const func = MovingAverage.__get__('getData');\n      const result = await func(layout, field, dimensionAndFieldList, data);\n      expect(result).to.deep.equal({\n        sourceData: [50, 100, 75, 150],\n        primaryDimension: ['2011', '2012', '2013', '2014']\n      });\n    });\n  });\n});\n\u0005End File\u0006# qlik-oss/qlik-modifiers\n// global describe, it, expect\nimport Ranking from '../../src/aggregation/ranking';\nimport data from './data-with-one-dimension.json';\nimport dataWithTwoDimensions from './data-with-two-dimensions.json';\n\nconst field = {\n  label: 'My label',\n  primaryDimension: 'Year',\n  dimensionToRank: 'Year',\n  dimensionToRankCode: 1\n};\n\nconst aggr = {\n  qDef: {\n    type: 'ranking',\n    groupDimension: 'Year',\n    selectedDimension: 'Year',\n    dimensionToRank: 1\n  }\n};\n\nconst layout = {\n  qHyperCube: {\n    qDimensionInfo: [{\n      qFallbackTitle: 'Year'\n    }],\n    qMeasureInfo: [{\n      qFallbackTitle: 'Calculated Measure'\n    }]\n  }\n};\n\nconst properties = {\n  qHyperCubeDef: {\n    qDimensions: [{\n      qDef: {\n        qFieldDefs: ['Year'],\n        qFieldLabels: ['Year']\n      }\n    }],\n    qMeasures: [{\n      qDef: {\n        qDef: 'Calculated Measure',\n        qLabel: 'Calculated Measure'\n      }\n    }]\n  }\n};\n\nconst dimensionAndFieldList = {\n  dimensions: [\n    {\n      index: 0,\n      label: 'Year'\n    }\n  ],\n  measures: [\n    {\n      index: 1,\n      label: 'My label'\n    }\n  ]\n};\n\nconst dimensionAndFieldListWithTwoDims = {\n  dimensions: [\n    {\n      index: 0,\n      label: 'Year'\n    },\n    {\n      index: 1,\n      label: 'Month'\n    }\n  ],\n  measures: [\n    {\n      index: 2,\n      label: 'My label'\n    }\n  ]\n};\n\ndescribe('ranking', () => {\n  it('should use FIRST_DIMENSION mode correctly', async () => {\n    const app = {};\n    const result = await Ranking(layout, app, properties, field, dimensionAndFieldList, aggr, data);\n    expect(result.values).to.deep.equal([4, 2, 3, 1]);\n  });\n\n  it('should use SELECTED_DIMENSION mode correctly', async () => {\n    field.dimensionToRankCode = 2;\n    field.dimensionToRank = 'Year';\n    const app = {};\n    const result = await Ranking(layout, app, properties, field, dimensionAndFieldList, aggr, data);\n    expect(result.values).to.deep.equal([4, 2, 3, 1]);\n  });\n\n  it('should handle empty layout', async () => {\n    layout.qHyperCube.qDimensionInfo = [];\n    const app = {};\n    const result = await Ranking(layout, app, properties, field, dimensionAndFieldList, aggr, data);\n    expect(result.values).to.deep.equal([0]);\n  });\n\n  describe('setPrimaryDimension', () => {\n    beforeEach(() => {\n      layout.qHyperCube.qDimensionInfo = [{\n        qFallbackTitle: 'Year'\n      }];\n    });\n\n    describe('when aggr.qDef.groupDimension is set', () => {\n      it('should set primaryDimension from aggr.qDef.groupDimension', () => {\n        const func = Ranking.__get__('setPrimaryDimension');\n        const aggrObj = {\n          qDef: {\n            groupDimension: 'Month'\n          }\n        };\n        const fieldObj = {};\n        func(aggrObj, fieldObj, layout.qHyperCube.qDimensionInfo);\n        expect(fieldObj.primaryDimension).to.equal('Month');\n      });\n    });\n\n    describe('when aggr.qDef.groupDimension is missing', () => {\n      it('should set primaryDimension from first dimension', () => {\n        const func = Ranking.__get__('setPrimaryDimension');\n        const aggrObj = {\n          qDef: {\n          }\n        };\n        const fieldObj = {};\n        func(aggrObj, fieldObj, layout.qHyperCube.qDimensionInfo);\n        expect(fieldObj.primaryDimension).to.equal('Year');\n      });\n    });\n\n    describe('when no dimension exists', () => {\n      it('should set primaryDimension to undefined', () => {\n        const func = Ranking.__get__('setPrimaryDimension');\n        const aggrObj = {\n          qDef: {\n          }\n        };\n        const fieldObj = {};\n        func(aggrObj, fieldObj, []);\n        expect(fieldObj.primaryDimension).to.be.undefined;\n      });\n    });\n  });\n\n  describe('setDimensionToRank', () => {\n    beforeEach(() => {\n      layout.qHyperCube.qDimensionInfo = [{\n        qFallbackTitle: 'Year'\n      }];\n    });\n\n    describe('when dimensionToRank === SELECTED_DIMENSION and aggr.qDef.selectedDimension is set', () => {\n      it('should set dimensionToRank from aggr.qDef.selectedDimension', () => {\n        const func = Ranking.__get__('setDimensionToRank');\n        const aggrObj = {\n          qDef: {\n            dimensionToRank: 2,\n            selectedDimension: 'Month'\n          }\n        };\n        const fieldObj = {};\n        func(aggrObj, fieldObj, layout.qHyperCube.qDimensionInfo);\n        expect(fieldObj.dimensionToRank).to.equal('Month');\n      });\n    });\n\n    describe('when dimensionToRank === SELECTED_DIMENSION and aggr.qDef.selectedDimension is missing', () => {\n      it('should set dimensionToRank from field.primaryDimension', () => {\n        const func = Ranking.__get__('setDimensionToRank');\n        const aggrObj = {\n          qDef: {\n            dimensionToRank: 2\n          }\n        };\n        const fieldObj = {\n          primaryDimension: 'Month'\n        };\n        func(aggrObj, fieldObj, layout.qHyperCube.qDimensionInfo);\n        expect(fieldObj.dimensionToRank).to.equal('Month');\n      });\n    });\n\n    describe('when dimensionToRank !== SELECTED_DIMENSION', () => {\n      it('should set dimensionToRank from first dimension', () => {\n        const func = Ranking.__get__('setDimensionToRank');\n        const aggrObj = {\n          qDef: {\n          }\n        };\n        const fieldObj = {};\n        func(aggrObj, fieldObj, layout.qHyperCube.qDimensionInfo);\n        expect(fieldObj.dimensionToRank).to.equal('Year');\n      });\n    });\n\n    describe('when no dimension exists', () => {\n      it('should set dimensionToRank to undefined', () => {\n        const func = Ranking.__get__('setDimensionToRank');\n        const aggrObj = {\n          qDef: {\n          }\n        };\n        const fieldObj = {};\n        func(aggrObj, fieldObj, []);\n        expect(fieldObj.dimensionToRank).to.be.undefined;\n      });\n    });\n  });\n\n  describe('addDimensionAndFields', () => {\n    it('should add primaryDimension to dimensionAndFieldList', () => {\n      const func = Ranking.__get__('addDimensionAndFields');\n      const dimensionsObj = [{\n        qFallbackTitle: 'Year'\n      }];\n      const fieldObj = {\n        primaryDimension: 'Year'\n      };\n      const dimAndFieldList = {\n        dimensions: [],\n        fields: []\n      };\n      func(dimAndFieldList, dimensionsObj, fieldObj);\n      expect(dimAndFieldList.dimensions).to.deep.equal([{\n        index: -1,\n        label: 'Year'\n      }]);\n    });\n\n    it('should add dimensionToRank to dimensionAndFieldList', () => {\n      const func = Ranking.__get__('addDimensionAndFields');\n      const dimensionsObj = [{\n        qFallbackTitle: 'Year'\n      }];\n      const fieldObj = {\n        dimensionToRank: 'Year'\n      };\n      const dimAndFieldList = {\n        dimensions: [],\n        fields: []\n      };\n      func(dimAndFieldList, dimensionsObj, fieldObj);\n      expect(dimAndFieldList.dimensions).to.deep.equal([{\n        index: -1,\n        label: 'Year'\n      }]);\n    });\n\n    it('should not add primaryDimension to dimensionAndFieldList if it already exists', () => {\n      const func = Ranking.__get__('addDimensionAndFields');\n      const dimensionsObj = [{\n        qFallbackTitle: 'Year'\n      }];\n      const fieldObj = {\n        primaryDimension: 'Year'\n      };\n      const dimAndFieldList = {\n        dimensions: [{\n          index: 0,\n          label: 'Year'\n        }],\n        fields: []\n      };\n      func(dimAndFieldList, dimensionsObj, fieldObj);\n      expect(dimAndFieldList.dimensions).to.deep.equal([{\n        index: 0,\n        label: 'Year'\n      }]);\n    });\n\n    it('should handle missing field.primaryDimension', () => {\n      const func = Ranking.__get__('addDimensionAndFields');\n      const dimensionsObj = [{\n        qFallbackTitle: 'Year'\n      }];\n      const fieldObj = {\n      };\n      const dimAndFieldList = {\n        dimensions: [],\n        fields: []\n      };\n      func(dimAndFieldList, dimensionsObj, fieldObj);\n      expect(dimAndFieldList.dimensions).to.deep.equal([]);\n    });\n\n    it('should handle missing layout.qHyperCube.qDimensionInfo', () => {\n      const func = Ranking.__get__('addDimensionAndFields');\n      const dimensionsObj = null;\n      const fieldObj = {\n        primaryDimension: 'Year'\n      };\n      const dimAndFieldList = {\n        dimensions: [],\n        fields: []\n      };\n      func(dimAndFieldList, dimensionsObj, fieldObj);\n      expect(dimAndFieldList.dimensions).to.deep.equal([]);\n    });\n  });\n\n  describe('getDataFromHyperCube', () => {\n    it('should get data from dataPages', () => {\n      const func = Ranking.__get__('getDataFromHyperCube');\n      const result = func(data, 1);\n      expect(result).to.deep.equal({\n        dimensions: [\n          ['2011'], ['2012'], ['2013'], ['2014']\n        ],\n        measures: [\n          [50], [100], [75], [150]\n        ]\n      });\n    });\n  });\n\n  describe('getDimensionIndex', () => {\n    it('should get index of dimension with qFallbackTitle', () => {\n      const func = Ranking.__get__('getDimensionIndex');\n      const result = func([{\n        qFallbackTitle: 'Year'\n      }, {\n        qFallbackTitle: 'Month'\n      }], 'Month');\n      expect(result).to.equal(1);\n    });\n\n    it('should return -1 if dimension is missing', () => {\n      const func = Ranking.__get__('getDimensionIndex');\n      const result = func([{\n        qFallbackTitle: 'Year'\n      }, {\n        qFallbackTitle: 'Month'\n      }], 'Quarter');\n      expect(result).to.equal(-1);\n    });\n  });\n\n  describe('getDimensionIndices', () => {\n    it('should get indices of primaryDimension and dimensionToRank', () => {\n      const func = Ranking.__get__('getDimensionIndices');\n      const result = func([{\n        qFallbackTitle: 'Year'\n      }, {\n        qFallbackTitle: 'Month'\n      }], {\n        primaryDimension: 'Year',\n        dimensionToRank: 'Month'\n      });\n      expect(result).to.deep.equal({\n        primaryDimension: 0,\n        dimensionToRank: 1\n      });\n    });\n  });\n\n  describe('getData', () => {\n    it('should get data from primary and dimensionToRank dimensions', async () => {\n      const func = Ranking.__get__('getData');\n      const result = await func(layout, field, dimensionAndFieldList, data);\n      expect(result).to.deep.equal({\n        sourceData: [50, 100, 75, 150],\n        primaryDimension: ['2011', '2012', '2013', '2014'],\n        dimensionToRank: ['2011', '2012', '2013', '2014']\n      });\n    });\n  });\n});\n\u0005End File\u0006# qlik-oss/qlik-modifiers\n// global describe, it, expect\nimport CalculateUtil from '../../src/aggregation/util/calculate';\n\nconst layout = {\n  qHyperCube: {\n    qDimensionInfo: [{\n      qFallbackTitle: 'Year'\n    }],\n    qMeasureInfo: [{\n      qFallbackTitle: 'Calculated Measure'\n    }]\n  }\n};\n\nconst model = {\n  calculatedMeasures: [{\n    measureIndex: 0,\n    calculatedValues: [{\n      type: 'acc',\n      values: [50, 100, 75, 150],\n      sourceValues: [25, 50, 50, 75]\n    }]\n  }]\n};\n\ndescribe('calculate-util', () => {\n  describe('addCalculationsToLayout', () => {\n    it('should add qAttrExprInfo', () => {\n      const func = CalculateUtil.__get__('addCalculationsToLayout');\n      func(model, layout);\n      expect(layout.qHyperCube.qMeasureInfo[0].qAttrExprInfo).to.deep.equal([{\n        qFallbackTitle: 'acc',\n        qValues: [50, 100, 75, 150],\n        qSourceValues: [25, 50, 50, 75]\n      }]);\n    });\n\n    it('should update qAttrExprInfo if it already exists', () => {\n      const func = CalculateUtil.__get__('addCalculationsToLayout');\n      layout.qHyperCube.qMeasureInfo[0].qAttrExprInfo = [{\n        qFallbackTitle: 'acc',\n        qValues: [1, 2, 3, 4],\n        qSourceValues: [1, 2, 3, 4]\n      }];\n      func(model, layout);\n      expect(layout.qHyperCube.qMeasureInfo[0].qAttrExprInfo).to.deep.equal([{\n        qFallbackTitle: 'acc',\n        qValues: [50, 100, 75, 150],\n        qSourceValues: [25, 50, 50, 75]\n      }]);\n    });\n\n    it('should append qAttrExprInfo if the first one already exists', () => {\n      const func = CalculateUtil.__get__('addCalculationsToLayout');\n      layout.qHyperCube.qMeasureInfo[0].qAttrExprInfo = [{\n        qFallbackTitle: 'x',\n        qValues: [1, 2, 3, 4],\n        qSourceValues: [1, 2, 3, 4]\n      }];\n      model.calculatedMeasures[0].calculatedValues.push({\n        type: 'diff',\n        values: [1, 2, 3, 4],\n        sourceValues: [1, 2, 3, 4]\n      });\n      func(model, layout);\n      expect(layout.qHyperCube.qMeasureInfo[0].qAttrExprInfo).to.deep.equal([{\n        qFallbackTitle: 'x',\n        qValues: [1, 2, 3, 4],\n        qSourceValues: [1, 2, 3, 4]\n      }, {\n        qFallbackTitle: 'diff',\n        qValues: [1, 2, 3, 4],\n        qSourceValues: [1, 2, 3, 4]\n      }]);\n    });\n\n    it('should handle missing qAttrExprInfo', () => {\n      const func = CalculateUtil.__get__('addCalculationsToLayout');\n      delete layout.qHyperCube.qMeasureInfo[0].qAttrExprInfo;\n      func(model, layout);\n      expect(layout.qHyperCube.qMeasureInfo[0].qAttrExprInfo).to.deep.equal([{\n        qFallbackTitle: 'acc',\n        qValues: [50, 100, 75, 150],\n        qSourceValues: [25, 50, 50, 75]\n      }]);\n    });\n\n    it('should handle missing measure', () => {\n      const func = CalculateUtil.__get__('addCalculationsToLayout');\n      model.calculatedMeasures[0].measureIndex = 1;\n      func(model, layout);\n      // No change to expect as no measure with index 1 exists\n    });\n\n    it('should handle missing calculatedMeasures', () => {\n      const func = CalculateUtil.__get__('addCalculationsToLayout');\n      delete model.calculatedMeasures;\n      func(model, layout);\n      // No change to expect\n    });\n\n    it('should handle missing calculatedValues', () => {\n      const func = CalculateUtil.__get__('addCalculationsToLayout');\n      delete model.calculatedMeasures[0].calculatedValues;\n      func(model, layout);\n      // No change to expect\n    });\n\n    it('should handle empty calculatedValues', () => {\n      const func = CalculateUtil.__get__('addCalculationsToLayout');\n      model.calculatedMeasures[0].calculatedValues = [];\n      func(model, layout);\n      // No change to expect\n    });\n\n    it('should handle empty layout', () => {\n      const func = CalculateUtil.__get__('addCalculationsToLayout');\n      func(model, {});\n      // No crash to expect\n    });\n\n    it('should handle empty model', () => {\n      const func = CalculateUtil.__get__('addCalculationsToLayout');\n      func(null, layout);\n      // No crash to expect\n    });\n  });\n\n  describe('calculate', () => {\n    it('should resolve layout if calculationService is missing', async () => {\n      const result = await CalculateUtil.calculate(null, layout, model);\n      expect(result).to.equal(layout);\n    });\n\n    it('should resolve layout if registerForCalculation is missing', async () => {\n      const calculationService = {};\n      const result = await CalculateUtil.calculate(calculationService, layout, model);\n      expect(result).to.equal(layout);\n    });\n\n    it('should call registerForCalculation', async () => {\n      const registerSpy = sinon.spy(() => Promise.resolve([]));\n      const calculationService = {\n        registerForCalculation: registerSpy\n      };\n      const result = await CalculateUtil.calculate(calculationService, layout, model);\n      expect(registerSpy.callCount).to.equal(1);\n      expect(result).to.equal(layout);\n    });\n\n    it('should wait for calculations to finish', async () => {\n      const registerSpy = sinon.spy(() => Promise.resolve([Promise.resolve(true)]));\n      const calculationService = {\n        registerForCalculation: registerSpy\n      };\n      const result = await CalculateUtil.calculate(calculationService, layout, model);\n      expect(registerSpy.callCount).to.equal(1);\n      expect(result).to.equal(layout);\n    });\n  });\n});\n\u0005End File\u0006# test/unit/util-field.spec.js\n// global describe, it, expect\nimport Field from '../../src/aggregation/util/field';\n\nconst properties = {\n  qHyperCubeDef: {\n    qDimensions: [{\n      qDef: {\n        qFieldDefs: ['Year'],\n        qFieldLabels: ['Year Label']\n      }\n    }, {\n      qLibraryId: 'Quarter'\n    }],\n    qMeasures: [{\n      qDef: {\n        qDef: 'Sum(Sales)',\n        qLabel: 'Measure Label'\n      }\n    }, {\n      qLibraryId: 'Master Item',\n      qDef: {\n        qLabel: 'Master Item Label'\n      }\n    }]\n  }\n};\n\ndescribe('field', () => {\n  describe('getDimensionAndFieldList', () => {\n    it('should create correct dimensions', () => {\n      const result = Field.getDimensionAndFieldList(properties);\n      expect(result.dimensions).to.deep.equal([{\n        index: 0,\n        label: 'Year Label',\n        qDef: {\n          qDef: {\n            qFieldDefs: ['Year'],\n            qFieldLabels: ['Year Label'],\n            qSortCriterias: undefined\n          }\n        }\n      }, {\n        index: 1,\n        label: '',\n        qDef: {\n          qLibraryId: 'Quarter',\n          qType: 'dimension'\n        }\n      }]);\n    });\n\n    it('should create correct measures', () => {\n      const result = Field.getDimensionAndFieldList(properties);\n      expect(result.measures).to.deep.equal([{\n        index: 2,\n        label: 'Measure Label',\n        qDef: 'Sum(Sales)'\n      }, {\n        index: 3,\n        label: 'Master Item Label',\n        qDef: '$(\"Master Item\")'\n      }]);\n    });\n\n    it('should handle expression for label', () => {\n      const props = {\n        qHyperCubeDef: {\n          qDimensions: [],\n          qMeasures: [{\n            qDef: {\n              qDef: 'Sum(Sales)',\n              qLabelExpression: 'Label from expression'\n            }\n          }]\n        }\n      };\n      const result = Field.getDimensionAndFieldList(props);\n      expect(result.measures).to.deep.equal([{\n        index: 0,\n        label: 'Label from expression',\n        qDef: 'Sum(Sales)'\n      }]);\n    });\n\n    it('should handle empty dimensions', () => {\n      const props = {\n        qHyperCubeDef: {\n          qDimensions: [],\n          qMeasures: [{\n            qDef: {\n              qDef: 'Sum(Sales)',\n              qLabel: 'Measure Label'\n            }\n          }]\n        }\n      };\n      const result = Field.getDimensionAndFieldList(props);\n      expect(result.dimensions).to.deep.equal([]);\n    });\n\n    it('should handle empty measures', () => {\n      const props = {\n        qHyperCubeDef: {\n          qDimensions: [{\n            qDef: {\n              qFieldDefs: ['Year'],\n              qFieldLabels: ['Year Label']\n            }\n          }],\n          qMeasures: []\n        }\n      };\n      const result = Field.getDimensionAndFieldList(props);\n      expect(result.measures).to.deep.equal([]);\n    });\n  });\n\n  describe('getMeasureExpression', () => {\n    it('should return expression for simple expression', () => {\n      const result = Field.getMeasureExpression(properties, 0);\n      expect(result).to.equal('Sum(Sales)');\n    });\n\n    it('should return expression for master item', () => {\n      const result = Field.getMeasureExpression(properties, 1);\n      expect(result).to.equal('$(\"Master Item\")');\n    });\n\n    it('should handle qMeasures being missing', () => {\n      const props = {\n        qHyperCubeDef: {\n          qDimensions: []\n        }\n      };\n      const result = Field.getMeasureExpression(props, 0);\n      expect(result).to.equal('');\n    });\n  });\n\n  describe('getDimensionExpression', () => {\n    it('should return expression for simple expression', () => {\n      const result = Field.getDimensionExpression(properties, 0);\n      expect(result).to.equal('Year');\n    });\n\n    it('should return expression for master item', () => {\n      const result = Field.getDimensionExpression(properties, 1);\n      expect(result).to.equal('$(\"Quarter\")');\n    });\n\n    it('should handle qDimensions being missing', () => {\n      const props = {\n        qHyperCubeDef: {\n          qMeasures: []\n        }\n      };\n      const result = Field.getDimensionExpression(props, 0);\n      expect(result).to.equal('');\n    });\n\n    it('should handle missing qDef.qFieldDefs', () => {\n      const props = {\n        qHyperCubeDef: {\n          qDimensions: [{\n            qDef: {}\n          }],\n          qMeasures: []\n        }\n      };\n      const result = Field.getDimensionExpression(props, 0);\n      expect(result).to.equal('');\n    });\n  });\n});\n\u0000include \"stdlib.fc\";\ninclude \"types.fc\";\n\nconst int OWNER_ADDRESS_CODE = \"owner_address\"c;\nconst int COLLECTION_META_DATA_CODE = \"collection_meta_data\"c;\nconst int NEXT_ITEM_INDEX_CODE = \"next_item_index\"c;\nconst int COLLECTION_CODE_CODE = \"collection_code\"c;\nconst int PARENT_ADDRESS_CODE = \"parent_address\"c;\nconst int ITEM_CODE_CODE = \"item_code\"c;\nconst int ROYALTY_PARAMS_CODE = \"royalty_params\"c;\nconst int MINT_MESSAGE_CODE = \"mint_message\"c;\nconst int MSG_VALUE_CODE = \"msg_value\"c;\n\nconst int op::init = 1;\nconst int op::mint = 2;\nconst int op::batch_mint = 3;\nconst int op::get_royalty_params = 0x693d3950;\n\nconst int error::unknown_op = 401;\nconst int error::access_denied = 403;\nconst int error::insufficient_gas = 404;\nconst int error::discovery_params_missing = 405;\nconst int error::insufficient_msg_value = 406;\nconst int error::invalid_item_count = 407;\nconst int error::invalid_item_mode = 408;\nconst int error::invalid_next_item_index = 409;\nconst int error::invalid_mint_message = 410;\nconst int error::invalid_item_amount = 411;\nconst int error::invalid_content = 412;\nconst int error::insufficient_msg_value_discovery = 413;\n\nglobal int storage::initialized;\nglobal slice storage::owner_address;\nglobal cell storage::collection_meta_data;\nglobal int storage::next_item_index;\nglobal cell storage::collection_code;\nglobal slice storage::parent_address;\nglobal cell storage::item_code;\nglobal cell storage::royalty_params;\nglobal cell storage::mint_message;\nglobal int storage::msg_value;\n\n;; For testing.\nglobal int storage::seed;\n\n;; Request data helpers\nint calculate_nft_address_by_index(int item_index) {\n  cell state_init = calculate_nft_state_init(item_index);\n  return cell_hash(state_init);\n}\n\ncell calculate_nft_state_init(int item_index) {\n  builder nft_data = begin_cell()\n    .store_uint(0, 64) ;; Contract seqno\n    .store_slice(my_address())\n    .store_uint(item_index, 64);\n\n  cell nft_code = storage::item_code;\n  cell nft_data_cell = nft_data.end_cell();\n\n  return begin_cell()\n      .store_uint(0, 2)\n      .store_dict(nft_code)\n      .store_dict(nft_data_cell)\n      .store_uint(0, 1)\n    .end_cell();\n}\n\n() mint_nft(int item_index, cell item_content, int amount, int item_message_value, int send_mode) impure {\n  cell state_init = calculate_nft_state_init(item_index);\n  slice nft_address = calculate_nft_item_address(storage::item_code, my_address(), item_index);\n\n  builder msg = begin_cell()\n    .store_uint(0x18, 6)\n    .store_slice(nft_address)\n    .store_coins(item_message_value)\n    .store_uint(4 + 2 + 1, 1 + 4 + 4 + 64 + 32 + 1 + 1 + 1)\n    .store_ref(state_init)\n    .store_ref(item_content);\n\n  cell msg_cell = msg.end_cell();\n  ;; cell_print(msg_cell);\n  send_raw_message(msg_cell, send_mode);\n}\n\n() batch_mint_nft(int item_index, int item_count, cell batch_content, int amount, int send_mode) impure {\n  cell state_init = calculate_nft_state_init(item_index);\n  slice nft_address = calculate_nft_item_address(storage::item_code, my_address(), item_index);\n\n  builder msg = begin_cell()\n    .store_uint(0x18, 6)\n    .store_slice(nft_address)\n    .store_coins(amount)\n    .store_uint(4 + 2 + 1, 1 + 4 + 4 + 64 + 32 + 1 + 1 + 1)\n    .store_ref(state_init);\n\n  cell mint_body = begin_cell()\n    .store_uint(op::batch_mint, 32)\n    .store_uint(0, 64)\n    .store_uint(item_count, 8)\n    .store_ref(batch_content)\n    .end_cell();\n\n  msg = msg.store_ref(mint_body);\n  \n  cell msg_cell = msg.end_cell();\n  ;; cell_print(msg_cell);\n  send_raw_message(msg_cell, send_mode);\n}\n\n;; Deployment\n\n() load_data() impure inline {\n  storage::seed = null();\n  var ds = get_data().begin_parse();\n  storage::initialized = ds~load_int(1);\n  if (storage::initialized) {\n    storage::owner_address = ds~load_msg_addr();\n    storage::collection_meta_data = ds~load_ref();\n    storage::next_item_index = ds~load_uint(64);\n    storage::collection_code = ds~load_ref();\n    storage::parent_address = ds~load_msg_addr();\n    storage::item_code = ds~load_ref();\n    storage::royalty_params = ds~load_ref();\n    storage::mint_message = ds~load_ref();\n    storage::msg_value = ds~load_coins();\n    \n    if (ds.slice_refs_empty?() != -1) {\n      storage::seed = ds~load_uint(32);\n    }\n  }\n}\n\n() save_data() impure inline {\n  var data = begin_cell()\n    .store_int(storage::initialized, 1)\n    .store_slice(storage::owner_address)\n    .store_ref(storage::collection_meta_data)\n    .store_uint(storage::next_item_index, 64)\n    .store_ref(storage::collection_code)\n    .store_slice(storage::parent_address)\n    .store_ref(storage::item_code)\n    .store_ref(storage::royalty_params)\n    .store_ref(storage::mint_message)\n    .store_coins(storage::msg_value);\n  \n  if (storage::seed != null()) {\n    data = data.store_uint(storage::seed, 32);\n  }\n  \n  set_data(data.end_cell());\n}\n\n() recv_internal(int balance, int msg_value, cell in_msg_full, slice in_msg_body) impure {\n  if (in_msg_body.slice_empty?()) { ;; ignore empty messages\n    return ();\n  }\n\n  slice cs = in_msg_full.begin_parse();\n  int flags = cs~load_uint(4);\n  if (flags & 1) { ;; ignore all bounced messages\n    return ();\n  }\n  slice sender_address = cs~load_msg_addr();\n\n  load_data();\n\n  int op = in_msg_body~load_uint(32);\n  int query_id = in_msg_body~load_uint(64);\n  \n  if (op == op::init) {\n    ;; 1 - Initialize collection\n    ;; This contract receives this message when it's deployed.\n    ;; throw_if(error::access_denied, storage::initialized);\n\n    ;; slice owner_address = in_msg_body~load_msg_addr();\n    ;; throw_unless(error::access_denied, equal_slice_bits(owner_address, sender_address));\n    ;; Get owner_address, meta_data, and collection_code from the msg.\n    \n    (slice owner_address, cell meta_data, slice parent_address, cell item_code, cell royalty_params, cell mint_message, int msg_value) = in_msg_body~extract_discovery_params();\n\n    storage::initialized = true;\n    storage::owner_address = owner_address;\n    storage::collection_meta_data = meta_data;\n    storage::next_item_index = 0;\n    storage::collection_code = in_msg_body~load_ref();\n    storage::parent_address = parent_address;\n    storage::item_code = item_code;\n    storage::royalty_params = royalty_params;\n    storage::mint_message = mint_message;\n    storage::msg_value = msg_value;\n    save_data();\n    return ();\n  }\n\n  if (op == op::mint) {\n    ;; 2 - Mint a new nft.\n    throw_unless(error::access_denied, equal_slice_bits(sender_address, storage::owner_address));\n    throw_if(error::insufficient_gas, msg_value < storage::msg_value);\n\n    ;; item_index is the id of a new nft item.\n    int item_index = in_msg_body~load_uint(64);\n    throw_if(error::invalid_next_item_index, item_index < storage::next_item_index);\n    cell item_content = in_msg_body~load_ref();\n\n    mint_nft(item_index, item_content, 0, storage::msg_value, 1);\n    storage::next_item_index = item_index + 1;\n    save_data();\n    return ();\n  }\n\n  if (op == op::batch_mint) {\n    ;; 3 - Mint multiple nft.\n    throw_unless(error::access_denied, equal_slice_bits(sender_address, storage::owner_address));\n    int item_count = in_msg_body~load_uint(8);\n    throw_if(error::insufficient_gas, msg_value < item_count * storage::msg_value);\n    throw_if(error::invalid_item_count, item_count < 1);\n    \n    ;; Starting item_index for this batch.\n    int item_index = in_msg_body~load_uint(64);\n    throw_if(error::invalid_next_item_index, item_index < storage::next_item_index);\n    cell batch_content = in_msg_body~load_ref();\n\n    batch_mint_nft(item_index, item_count, batch_content, item_count * storage::msg_value, 1);\n\n    storage::next_item_index = item_index + item_count;\n    save_data();\n    return ();\n  }\n\n  if (op == op::get_royalty_params) {\n    ;; 0x693d3950 - Get royalty params\n    var msg = begin_cell()\n        .store_uint(0x10, 6) ;; nobounce - int_msg_info$0 ihr_disabled:Bool bounce:Bool bounced:Bool src:MsgAddress -> 011000\n        .store_slice(sender_address)\n        .store_coins(0)\n        .store_uint(0, 1 + 4 + 4 + 64 + 32 + 1 + 1)\n        .store_uint(op::get_royalty_params, 32)\n        .store_uint(query_id, 64);\n    \n    var builder = begin_cell()\n      .store_uint(op::get_royalty_params, 32)\n      .store_uint(query_id, 64);\n\n    cell dict = storage::royalty_params;\n    builder = builder.store_ref(dict);\n\n    var msg_cell = msg.store_builder(builder).end_cell();\n    ;; cell_print(msg_cell);\n    send_raw_message(msg_cell, 64);\n    return ();\n  }\n\n  throw(error::unknown_op);\n}\n\n;; Get methods\n(int, cell, slice) get_collection_data() method_id {\n  load_data();\n  return (storage::next_item_index, storage::collection_meta_data, storage::owner_address);\n}\n\nslice get_nft_address_by_index(int index) method_id {\n  load_data();\n  return calculate_nft_item_address(storage::item_code, my_address(), index);\n}\n\n(int, int, slice) royalty_params() method_id {\n  load_data();\n  slice rs = storage::royalty_params.begin_parse();\n  return (rs~load_uint(16), rs~load_uint(16), rs~load_msg_addr());\n}\n\ncell get_nft_content(int index, cell individual_nft_content) method_id {\n  load_data();\n  slice cs = individual_nft_content.begin_parse();\n  \n  cs~load_ref();\n  cs~load_ref();\n  \n  slice common_content = storage::collection_meta_data.begin_parse();\n  return (begin_cell()\n                      .store_uint(1, 8) ;; offchain tag\n                      .store_slice(common_content)\n                     ).end_cell();\n}\n\n(int, cell, slice, slice, cell, cell, cell, int) get_collection_discovery_params() method_id {\n  load_data();\n  return (\n    storage::next_item_index,\n    storage::collection_meta_data,\n    storage::owner_address,\n    storage::parent_address,\n    storage::item_code,\n    storage::royalty_params,\n    storage::mint_message,\n    storage::msg_value\n  );\n}\n\n(int, slice, cell, cell) get_collection_debug_data() method_id {\n  load_data();\n  return (storage::next_item_index, storage::owner_address, storage::collection_code, storage::item_code);\n}\n\nint get_seed() method_id {\n  load_data();\n  return storage::seed;\n}\n\n(slice, (int)) debug_getglobal_variables() method_id {\n  load_data();\n  return (storage::owner_address, (storage::next_item_index));\n}\u0005End File\u0006# packages/core/contracts/nft-item.fc\n#include \"stdlib.fc\";\n#include \"types.fc\";\n\nconst int OWNER_ADDRESS_CODE = \"owner_address\"c;\nconst int ITEM_INDEX_CODE = \"item_index\"c;\nconst int COLLECTION_ADDRESS_CODE = \"collection_address\"c;\nconst int ITEM_DATA_CODE = \"item_data\"c;\nconst int MINT_TIMESTAMP_CODE = \"mint_timestamp\"c;\n\nconst int op::transfer = 0x5fcc3d14;\nconst int op::get_static_data = 0x2fcb26a2;\nconst int op::batch_mint = 3;\nconst int op::report_static_data = 0x8b771735;\nconst int op::get_royalty_params = 0x693d3950;\nconst int op::report_royalty_params = 0xa8cb00ad;\n\nconst int error::unknown_op = 401;\nconst int error::access_denied = 403;\nconst int error::insufficient_gas = 404;\nconst int error::insufficient_msg_value = 406;\nconst int error::invalid_item_index = 407;\nconst int error::invalid_item_mode = 408;\nconst int error::invalid_next_item_index = 409;\nconst int error::invalid_mint_message = 410;\nconst int error::invalid_item_amount = 411;\nconst int error::invalid_content = 412;\n\n;; These fields can be updated by the owner of the collection.\nglobal int storage::initialized;\nglobal slice storage::owner_address;\nglobal int storage::item_index;\nglobal slice storage::collection_address;\nglobal cell storage::item_data;\nglobal int storage::mint_timestamp;\n\n;; For testing.\nglobal int storage::seed;\n\n;; Deployment functions.\n\n() load_data() impure inline {\n  var ds = get_data().begin_parse();\n  storage::initialized = ds~load_int(1);\n  if (storage::initialized) {\n    storage::item_index = ds~load_uint(64);\n    storage::collection_address = ds~load_msg_addr();\n    storage::owner_address = ds~load_msg_addr();\n    storage::item_data = ds~load_ref();\n    storage::mint_timestamp = ds~load_uint(32);\n    \n    if (ds.slice_refs_empty?() != -1) {\n      storage::seed = ds~load_uint(32);\n    }\n  }\n}\n\n() save_data() impure inline {\n  var data = begin_cell()\n    .store_int(storage::initialized, 1)\n    .store_uint(storage::item_index, 64)\n    .store_slice(storage::collection_address)\n    .store_slice(storage::owner_address)\n    .store_ref(storage::item_data)\n    .store_uint(storage::mint_timestamp, 32);\n\n  if (storage::seed != null()) {\n    data = data.store_uint(storage::seed, 32);\n  }\n  \n  set_data(data.end_cell());\n}\n\n() recv_internal(int balance, int msg_value, cell in_msg_full, slice in_msg_body) impure {\n  if (in_msg_body.slice_empty?()) { ;; ignore empty messages\n    return ();\n  }\n\n  slice cs = in_msg_full.begin_parse();\n  int flags = cs~load_uint(4);\n  if (flags & 1) { ;; ignore all bounced messages\n    return ();\n  }\n  slice sender_address = cs~load_msg_addr();\n\n  load_data();\n\n  int op = in_msg_body~load_uint(32);\n  int query_id = in_msg_body~load_uint(64);\n\n  ;; Parse the message and either initialize the contract\n  ;; or call the transfer method.\n  \n  if (op == op::transfer) {\n    throw_unless(error::access_denied, equal_slice_bits(sender_address, storage::owner_address));\n    slice new_owner_address = in_msg_body~load_msg_addr();\n    slice response_destination = in_msg_body~load_msg_addr();\n    int custom_payload = in_msg_body~load_uint(1); ;; we skip this field.\n    throw_if(custom_payload, error::unknown_op);\n    int forward_amount = in_msg_body~load_coins();\n    \n    storage::owner_address = new_owner_address;\n    save_data();\n    \n    if (forward_amount > 0) {\n      var msg = begin_cell()\n        .store_uint(0x18, 6) ;; The outward message is bounabcle.\n        .store_slice(new_owner_address)\n        .store_coins(forward_amount)\n        .store_uint(1, 1 + 4 + 4 + 64 + 32 + 1 + 1)\n        .store_ref(in_msg_body~load_ref());\n      send_raw_message(msg.end_cell(), 1);\n    }\n    \n    if (response_destination.preload_uint(2) != 0) {\n      var msg = begin_cell()\n        .store_uint(0x10, 6) ;; The message doesn't bounce.\n        .store_slice(response_destination)\n        .store_coins(0)\n        .store_uint(0, 1 + 4 + 4 + 64 + 32 + 1 + 1)\n        .store_uint(op::transfer, 32)\n        .store_uint(query_id, 64);\n      send_raw_message(msg.end_cell(), 1);\n    }\n    \n    return ();\n  }\n\n  if (op == op::get_static_data) {\n    ;; reply static data\n    var msg = begin_cell()\n      .store_uint(0x10, 6) ;; nobouce - int_msg_info$0 ihr_disabled:Bool bounce:Bool bounced:Bool src:MsgAddress -> 011000\n      .store_slice(sender_address)\n      .store_coins(0)\n      .store_uint(0, 1 + 4 + 4 + 64 + 32 + 1 + 1)\n      .store_uint(op::report_static_data, 32)\n      .store_uint(query_id, 64)\n      .store_uint(storage::item_index, 256)\n      .store_slice(storage::collection_address);\n    send_raw_message(msg.end_cell(), 64);\n    return ();\n  }\n\n  if (op == op::get_royalty_params) {\n    ;; this contract doesn't impl this.\n    var msg = begin_cell()\n      .store_uint(0x10, 6) ;; nobouce - int_msg_info$0 ihr_disabled:Bool bounce:Bool bounced:Bool src:MsgAddress -> 011000\n      .store_slice(sender_address)\n      .store_coins(0)\n      .store_uint(0, 1 + 4 + 4 + 64 + 32 + 1 + 1)\n      .store_uint(op::get_royalty_params, 32)\n      .store_uint(query_id, 64);\n    \n    send_raw_message(msg.end_cell(), 64);\n    return ();\n  }\n\n  if (op == op::batch_mint) {\n    ;; Single nft or batch mint.\n    ;; This is sent by the collection contract directly\n    ;; and is verified by the state_init.\n    throw_unless(error::access_denied, equal_slice_bits(sender_address, storage::collection_address));\n    int total_count = in_msg_body~load_uint(8);\n    \n    cell all_content = in_msg_body~load_ref();\n    \n    cell this_item_data = null();\n    int i = 0;\n    slice content_slice = all_content.begin_parse();\n    repeat (total_count) {\n      i += 1;\n      this_item_data = content_slice~load_ref();\n      if (i == storage::item_index) {\n        break;\n      }\n    }\n    throw_if(error::invalid_content, this_item_data.null?());\n    \n    ;; init item\n    storage::initialized = true;\n    storage::owner_address = this_item_data.begin_parse()~load_msg_addr();\n    storage::item_data = this_item_data;\n    storage::mint_timestamp = now();\n    save_data();\n    return ();\n  }\n\n  if (op == op::report_royalty_params) {\n    ;; we just bounce this to the sender.\n    return ();\n  }\n\n  if (~ storage::initialized) {\n    ;; Set this nft as initialized using\n    ;; the collection contract's address as the nft's owner.\n    ;; This is used for single nft minting.\n    throw_unless(error::access_denied, equal_slice_bits(sender_address, storage::collection_address));\n    storage::initialized = true;\n    storage::owner_address = in_msg_body~load_msg_addr();\n    storage::item_data = in_msg_body~load_ref();\n    storage::mint_timestamp = now();\n    save_data();\n    return ();\n  }\n\n  throw(error::unknown_op);\n}\n\n(int, int, slice, slice, cell) get_nft_data() method_id {\n  load_data();\n  return (storage::initialized, storage::item_index, storage::collection_address, storage::owner_address, storage::item_data);\n}\n\n(int) get_mint_timestamp() method_id {\n  load_data();\n  return storage::mint_timestamp;\n}\n\nint get_seed() method_id {\n  load_data();\n  return storage::seed;\n}\u0005End File\u0006#include \"stdlib.fc\";\n#include \"types.fc\";\n\n;; Discovery params. Key: int/text, Value: any\n;; Owner_address -> owner_address:MsgAddress\n;; Collection_meta_data -> collection_meta_data:^Cell \n;; Parent_address -> parent_address:MsgAddress\n;; Item_code -> item_code:^Cell\n;; Royalty_params -> royalty_params:^Cell\n;; Mint_message -> mint_message:^Cell\n;; Msg_value -> msg_value:Coins\n\nconst int OWNER_ADDRESS_CODE = \"owner_address\"c;\nconst int COLLECTION_META_DATA_CODE = \"collection_meta_data\"c;\nconst int PARENT_ADDRESS_CODE = \"parent_address\"c;\nconst int ITEM_CODE_CODE = \"item_code\"c;\nconst int ROYALTY_PARAMS_CODE = \"royalty_params\"c;\nconst int MINT_MESSAGE_CODE = \"mint_message\"c;\nconst int MSG_VALUE_CODE = \"msg_value\"c;\n\nconst int error::discovery_params_missing = 405;\nconst int error::insufficient_msg_value_discovery = 413;\nconst int error::insufficient_msg_value = 406;\n\n() check_param_exists(int code, var value, int throw_error) impure inline {\n  throw_unless(throw_error, value != null());\n}\n\n() set_param(var ds, int code, var value) impure inline {\n  ds~idict_set_ref(256, code, value);\n}\n\nvar get_param(var ds, int code) inline {\n  var value = ds~idict_get_ref?(256, code);\n  return value;\n}\n\n(slice, cell, slice, cell, cell, cell, int) extract_discovery_params(slice in_msg_body) inline {\n  throw_unless(error::discovery_params_missing, in_msg_body.slice_refs() > 0);\n  cell params_dict = in_msg_body~load_ref();\n  var ds = params_dict.begin_parse();\n  \n  var owner_address = get_param(ds, OWNER_ADDRESS_CODE);\n  var collection_meta_data = get_param(ds, COLLECTION_META_DATA_CODE);\n  var parent_address = get_param(ds, PARENT_ADDRESS_CODE);\n  var item_code = get_param(ds, ITEM_CODE_CODE);\n  var royalty_params = get_param(ds, ROYALTY_PARAMS_CODE);\n  var mint_message = get_param(ds, MINT_MESSAGE_CODE);\n  var msg_value = get_param(ds, MSG_VALUE_CODE);\n  \n  check_param_exists(OWNER_ADDRESS_CODE, owner_address, error::discovery_params_missing);\n  check_param_exists(COLLECTION_META_DATA_CODE, collection_meta_data, error::discovery_params_missing);\n  check_param_exists(PARENT_ADDRESS_CODE, parent_address, error::discovery_params_missing);\n  check_param_exists(ITEM_CODE_CODE, item_code, error::discovery_params_missing);\n  check_param_exists(ROYALTY_PARAMS_CODE, royalty_params, error::discovery_params_missing);\n  check_param_exists(MINT_MESSAGE_CODE, mint_message, error::discovery_params_missing);\n  check_param_exists(MSG_VALUE_CODE, msg_value, error::discovery_params_missing);\n  \n  return (owner_address.begin_parse(), collection_meta_data, parent_address.begin_parse(), item_code, royalty_params, mint_message, msg_value.begin_parse()~load_coins());\n}\n\nbuilder build_discovery_params(\n  slice owner_address,\n  cell collection_meta_data,\n  slice parent_address,\n  cell item_code,\n  cell royalty_params,\n  cell mint_message,\n  int msg_value\n) inline {\n  var discovery_params = new_dict();\n  set_param(discovery_params, OWNER_ADDRESS_CODE, begin_cell().store_slice(owner_address).end_cell());\n  set_param(discovery_params, COLLECTION_META_DATA_CODE, collection_meta_data);\n  set_param(discovery_params, PARENT_ADDRESS_CODE, begin_cell().store_slice(parent_address).end_cell());\n  set_param(discovery_params, ITEM_CODE_CODE, item_code);\n  set_param(discovery_params, ROYALTY_PARAMS_CODE, royalty_params);\n  set_param(discovery_params, MINT_MESSAGE_CODE, mint_message);\n  set_param(discovery_params, MSG_VALUE_CODE, begin_cell().store_coins(msg_value).end_cell());\n  cell discovery_params_dict = begin_cell().store_dict(discovery_params).end_cell();\n  \n  return begin_cell().store_ref(discovery_params_dict);\n}\n\nslice calculate_nft_item_address(cell nft_item_code, slice collection_address, int item_index) {\n  builder nft_data = begin_cell()\n    .store_uint(0, 64) ;; Contract seqno\n    .store_slice(collection_address)\n    .store_uint(item_index, 64);\n\n  cell state_init = begin_cell()\n      .store_uint(0, 2)\n      .store_dict(nft_item_code)\n      .store_dict(nft_data.end_cell())\n      .store_uint(0, 1)\n    .end_cell();\n\n  return calc_address_by_state_init(state_init);\n}\n\n;; For testing.\ncell cell_debug_print(cell c) {\n  cell_print(c);\n  return c;\n}\n\nslice slice_debug_print(slice s) {\n  slice_print(s);\n  return s;\n}\n\nint int_debug_print(int i) {\n  int_print(i);\n  return i;\n}\n\ntuple tuple_debug_print(tuple t) {\n  tuple_print(t);\n  return t;\n}\n\nvar print_discovery_params(slice owner_address, cell collection_meta_data, slice parent_address, cell item_code, cell royalty_params, cell mint_message, int msg_value) {\n  slice_print(owner_address);\n  cell_print(collection_meta_data);\n  slice_print(parent_address);\n  cell_print(item_code);\n  cell_print(royalty_params);\n  cell_print(mint_message);\n  int_print(msg_value);\n  return null();\n}\n\ncell build_royalty_params(int numerator, int denominator, slice royalty_owner) {\n  ;; royalty is [0; 100) %\n  \n  return begin_cell()\n      .store_uint(numerator, 16)\n      .store_uint(denominator, 16)\n      .store_slice(royalty_owner)\n  .end_cell();\n}\u0005End File\u0006# packages/core/src/types.ts\nexport interface QubicItemData {\n  name: string;\n  description: string;\n  image: string;\n  traits: QubicTraits[];\n  external_links: QubicExternalLinks[];\n  license: QubicLicense | null;\n  // Data to allow recreating off-chain metadata collection\n  // and dynamic SVG rendering (if applicable)\n  collectionId: string;\n  collectionSize: number;\n  index: number;\n  originalContent: string;\n}\n\nexport interface QubicTraits {\n  trait_type: string;\n  value: string;\n  display_type?: string;\n}\n\nexport interface QubicExternalLinks {\n  label: string;\n  url: string;\n  type: string;\n}\n\nexport interface QubicLicense {\n  name: string;\n  text: string;\n}\n\nexport interface QubicMeta {\n  name: string;\n  description: string;\n  image: string;\n  cover_image: string | null;\n  license: QubicLicense | null;\n}\n\nexport enum QubicItemContentType {\n  JSON = 'JSON',\n  RAW_JSON = 'RAW_JSON',\n  SVG_DYNAMIC_SIMPLE = 'SVG_DYNAMIC_SIMPLE',\n  SVG_DYNAMIC_INDEX = 'SVG_DYNAMIC_INDEX',\n  SVG_STATIC = 'SVG_STATIC',\n  CUSTOM = 'CUSTOM'\n}\n\nexport interface QubicItem {\n  name: string;\n  description: string;\n  image: string;\n  attributes: QubicTraits[];\n  external_links: QubicExternalLinks[];\n  license: QubicLicense | null;\n  // Optional properties for minting\n  creator?: string;\n  ownerAddress?: string;\n  // Optional properties for storage\n  contentType?: QubicItemContentType;\n  originalContent?: string;\n  collectionId?: string;\n  collectionSize?: number;\n  index?: number;\n}\n\nexport interface QubicCollection {\n  collection: QubicMeta;\n  items: QubicItem[];\n}\n\nexport interface QubicContentRequest {\n  name: string;\n  description: string;\n  creator: string;\n  isStatic?: boolean;\n  renderType?: 'dynamic' | 'static';\n  elements?: {\n    elementType: string;\n    elementId: string;\n    elementText: string;\n    elementSize: string;\n    elementRotate: string;\n    elementX: string;\n    elementY: string;\n    elementColor: string;\n    elementFont: string;\n  }[];\n  templateItems?: {\n    name: string;\n    description: string;\n    attributes: { trait_type: string; value: string; display_type?: string }[];\n  }[];\n  collectionSize?: number;\n}\n\nexport interface QubicRequestOptions {\n  silent?: boolean;\n}\n\nexport type QubicRequestCallback = (\n  content: QubicContentRequest,\n  options?: QubicRequestOptions\n) => Promise<QubicCollection>;\n\nexport interface QubicCommentOptions {\n  text?: string;\n  user: string;\n  nftAddress: string;\n  timestamp?: number;\n}\n\nexport interface QubicComment {\n  id: string;\n  text: string;\n  user: string;\n  timestamp: number;\n  nftAddress: string;\n  replyToId?: string;\n  replies?: QubicComment[];\n}\n\u0005End File\u0006# openproduct/qubic-jswrappers\nimport TonWeb from 'tonweb';\nimport { CHAIN } from '@tonconnect/ui';\nimport {\n  Address,\n  beginCell,\n  Builder,\n  Cell,\n  Contract,\n  ContractProvider,\n  Sender,\n  toNano\n} from '@ton/core';\nimport {\n  QubicCollection,\n  QubicCollectionMeta,\n  QubicItem\n} from './types.js';\nimport { encodeOffChainContent } from './utils.js';\n\nexport type Network = CHAIN.MAINNET | CHAIN.TESTNET;\n\nexport const getTonWebNetwork = (network: Network) => {\n  switch (network) {\n    case CHAIN.MAINNET:\n      return true;\n    case CHAIN.TESTNET:\n      return false;\n    default:\n      return false;\n  }\n};\n\nexport type QubicConfig = {\n  network: Network;\n  collectionContract: string;\n  itemContract: string;\n  commissionAmount: string;\n  defaultMintMessageValue: string;\n  discoveryCatalogAddress: string;\n  defaultRoyalty: {\n    numerator: number;\n    denominator: number;\n  };\n};\n\nexport const defaultRoyaltyParams = {\n  numerator: 500,\n  denominator: 10000\n};\n\nexport const testnetConfig: QubicConfig = {\n  network: CHAIN.TESTNET,\n  collectionContract:\n    'EQBCFwW0NQta7-PzUl0pUkpFgZqEfAACCkjqhYrPkxAJNKSk',\n  itemContract:\n    'EQB2BdH8eLL5sJxzBpDDBSzU9Hp9gGZTDiIGuO2d49F32hEA',\n  discoveryCatalogAddress:\n    'EQAmVfVlGvq7r6YBJVwxMEHJm_-O8NKPl54K15VkuuVnNu16',\n  commissionAmount: '0.05',\n  defaultMintMessageValue: '0.025',\n  defaultRoyalty: defaultRoyaltyParams\n};\n\nexport const mainnetConfig: QubicConfig = {\n  network: CHAIN.MAINNET,\n  collectionContract:\n    'EQAcpK4zrOY4DZMF4ekVXPQQ-18JLdS0iXWBN5jQKUvBwbKF',\n  itemContract:\n    'EQDHPWp-Xp-P4bXA0fRX35TbXnmJ19vFWYpsDcg67cCGXJQP',\n  discoveryCatalogAddress:\n    'EQCbMZOy3wIlD3HoQnykzr7jM0iN4o5T3hiAKGgT8GpJVQp4',\n  commissionAmount: '0.5',\n  defaultMintMessageValue: '0.025',\n  defaultRoyalty: defaultRoyaltyParams\n};\n\nexport type RoyaltyParams = {\n  numerator: number;\n  denominator: number;\n  royaltyAddress: Address;\n};\n\nexport type DiscoveryParams = {\n  ownerAddress: Address;\n  collectionMetaData: Cell;\n  parentAddress: Address;\n  itemCode: Cell;\n  royaltyParams: Cell;\n  mintMessage: Cell;\n  msgValue: bigint;\n};\n\nexport function discoveryParamsToCell(\n  params: DiscoveryParams\n): Cell {\n  return beginCell()\n    .storeRef(\n      packDiscoveryParams({\n        ownerAddress: params.ownerAddress,\n        collectionMetaData: params.collectionMetaData,\n        parentAddress: params.parentAddress,\n        itemCode: params.itemCode,\n        royaltyParams: params.royaltyParams,\n        mintMessage: params.mintMessage,\n        msgValue: params.msgValue\n      })\n    )\n    .endCell();\n}\n\nexport function buildRoyaltyParams(params: RoyaltyParams): Cell {\n  return beginCell()\n    .storeUint(params.numerator, 16)\n    .storeUint(params.denominator, 16)\n    .storeAddress(params.royaltyAddress)\n    .endCell();\n}\n\nexport function getContentForCollection(\n  collection: QubicCollectionMeta\n): Cell {\n  const content = encodeOffChainContent(JSON.stringify(collection));\n\n  return beginCell().storeBuffer(Buffer.from(content)).endCell();\n}\n\nexport function getContentForNFT(\n  item: QubicItem,\n  options: {\n    ownerAddress: Address;\n  }\n): Cell {\n  const json = JSON.stringify(item);\n  const data = encodeOffChainContent(json);\n\n  return beginCell()\n    .storeAddress(options.ownerAddress)\n    .storeRef(beginCell().storeBuffer(Buffer.from(data)).endCell())\n    .endCell();\n}\n\n// Builds a Cell for a batch of NFTs\nexport function buildBatchContent(\n  items: QubicItem[],\n  ownerAddress: Address\n): Cell {\n  // First, prepare individual cell for each NFT\n  const itemCells = items.map((item) =>\n    getContentForNFT(item, { ownerAddress })\n  );\n\n  // Now create a cell with references to all item cells\n  let batchCell: Builder = beginCell();\n  for (const itemCell of itemCells) {\n    batchCell = batchCell.storeRef(itemCell);\n  }\n\n  return batchCell.endCell();\n}\n\nexport const DICT_KEY_CODES = {\n  OWNER_ADDRESS: BigInt('0x6f776e65725f61646472657373'),\n  COLLECTION_META_DATA: BigInt(\n    '0x636f6c6c656374696f6e5f6d6574615f64617461'\n  ),\n  PARENT_ADDRESS: BigInt('0x706172656e745f61646472657373'),\n  ITEM_CODE: BigInt('0x6974656d5f636f6465'),\n  ROYALTY_PARAMS: BigInt('0x726f79616c74795f706172616d73'),\n  MINT_MESSAGE: BigInt('0x6d696e745f6d657373616765'),\n  MSG_VALUE: BigInt('0x6d73675f76616c7565')\n};\n\nexport function packDiscoveryParams(params: DiscoveryParams): Cell {\n  // Create a dictionary of parameters\n  const dict = new Map<bigint, Cell>();\n\n  // Store each parameter in the dictionary\n  dict.set(\n    DICT_KEY_CODES.OWNER_ADDRESS,\n    beginCell().storeAddress(params.ownerAddress).endCell()\n  );\n  dict.set(\n    DICT_KEY_CODES.COLLECTION_META_DATA,\n    params.collectionMetaData\n  );\n  dict.set(\n    DICT_KEY_CODES.PARENT_ADDRESS,\n    beginCell().storeAddress(params.parentAddress).endCell()\n  );\n  dict.set(DICT_KEY_CODES.ITEM_CODE, params.itemCode);\n  dict.set(DICT_KEY_CODES.ROYALTY_PARAMS, params.royaltyParams);\n  dict.set(DICT_KEY_CODES.MINT_MESSAGE, params.mintMessage);\n  dict.set(\n    DICT_KEY_CODES.MSG_VALUE,\n    beginCell().storeCoins(params.msgValue).endCell()\n  );\n\n  // Convert the map to a Cell dictionary\n  const dictCell = beginCell();\n  for (const [key, value] of dict.entries()) {\n    dictCell.storeRef(\n      beginCell().storeUint(key, 256).storeRef(value).endCell()\n    );\n  }\n  return dictCell.endCell();\n}\n\nexport class QubicDiscoveryContract implements Contract {\n  constructor(\n    readonly address: Address,\n    readonly init?: { code: Cell; data: Cell }\n  ) {}\n\n  static createFromAddress(address: Address) {\n    return new QubicDiscoveryContract(address);\n  }\n\n  async sendDeploy(\n    provider: ContractProvider,\n    via: Sender,\n    value: bigint\n  ) {\n    await provider.internal(via, {\n      value,\n      sendMode: 1,\n      body: beginCell().endCell()\n    });\n  }\n\n  async sendRegisterCollection(\n    provider: ContractProvider,\n    via: Sender,\n    opts: {\n      value: bigint;\n      queryId?: number;\n      collectionId: string;\n      ownerAddress: Address;\n      collectionMetaData: Cell;\n      collectionCode: Cell;\n      parentAddress: Address;\n      itemCode: Cell;\n      royaltyParams: Cell;\n      mintMessage: Cell;\n      msgValue: bigint;\n    }\n  ) {\n    const discoveryParams = discoveryParamsToCell({\n      ownerAddress: opts.ownerAddress,\n      collectionMetaData: opts.collectionMetaData,\n      parentAddress: opts.parentAddress,\n      itemCode: opts.itemCode,\n      royaltyParams: opts.royaltyParams,\n      mintMessage: opts.mintMessage,\n      msgValue: opts.msgValue\n    });\n\n    await provider.internal(via, {\n      value: opts.value,\n      sendMode: 1,\n      body: beginCell()\n        .storeUint(1, 32) // op: register_collection\n        .storeUint(opts.queryId || 0, 64)\n        .storeRef(Buffer.from(opts.collectionId)) // collection ID as a ref cell\n        .storeBuilder(discoveryParams.asBuilder())\n        .storeRef(opts.collectionCode)\n        .endCell()\n    });\n  }\n\n  async getCollectionAddress(\n    provider: ContractProvider,\n    collectionId: string\n  ): Promise<Address | null> {\n    const result = await provider.get('get_collection_address', [\n      { type: 'cell', cell: beginCell().storeBuffer(Buffer.from(collectionId)).endCell() }\n    ]);\n    \n    return result.stack.readAddressOpt();\n  }\n}\n\nexport async function mintNFTCollection(\n  params: {\n    config: QubicConfig;\n    wallet: any;\n    walletAddress: string;\n    collection: QubicCollection;\n    seqno: number;\n    maxItems?: number;\n    ownerAddress?: string;\n    batchSize?: number;\n    royaltyParams?: {\n      numerator: number;\n      denominator: number;\n      destination: string;\n    };\n  }\n): Promise<{\n  mint: {\n    transaction: any;\n    collection: { address: string };\n  };\n}> {\n  console.log('mintNFTCollection started with params:', {\n    collection: params.collection.collection.name,\n    itemsCount: params.collection.items.length,\n    wallet: params.walletAddress\n  });\n\n  const ownerAddress = params.ownerAddress || params.walletAddress;\n  const isMainnet = params.config.network === CHAIN.MAINNET;\n  console.log('Network:', isMainnet ? 'mainnet' : 'testnet');\n\n  // Extract all non-null values from mintInfo\n  const metadata = {\n    name: params.collection.collection.name,\n    description: params.collection.collection.description,\n    image: params.collection.collection.image,\n    cover_image: params.collection.collection.cover_image,\n    license: params.collection.collection.license\n  };\n\n  // Create content cell for collection metadata\n  const collectionContent = getContentForCollection(metadata);\n\n  // Create TonWeb instance\n  const tonweb = new TonWeb();\n  const toAddress = isMainnet\n    ? params.config.discoveryCatalogAddress\n    : params.config.discoveryCatalogAddress;\n\n  // Prepare NFT collection deploy params\n  const collectionId = generateCollectionId();\n  const deployCost = toNano('0.5');\n\n  // Prepare royalty params\n  const royaltyDestination = params.royaltyParams?.destination || ownerAddress;\n  const royaltyNumerator = params.royaltyParams?.numerator || params.config.defaultRoyalty.numerator;\n  const royaltyDenominator = params.royaltyParams?.denominator || params.config.defaultRoyalty.denominator;\n  \n  const royaltyParams = {\n    numerator: royaltyNumerator, \n    denominator: royaltyDenominator,\n    destination: royaltyDestination\n  };\n  \n  console.log('Royalty params:', royaltyParams);\n\n  // Create message to deploy collection\n  const mintMessage = beginCell().storeUint(0, 32).endCell();\n  \n  // Mint NFT collection (first operation, returns address)\n  const mintResult = await wallet.methods.transfer({\n    secretKey: wallet.keyPair.secretKey,\n    toAddress: toAddress,\n    amount: deployCost.toString(),\n    seqno: seqno,\n    payload: createCollectionDeployPayload({\n      collectionId: collectionId,\n      ownerAddress: ownerAddress,\n      metadata: metadata,\n      royaltyParams: royaltyParams,\n      mintMessageValue: params.config.defaultMintMessageValue\n    }),\n    sendMode: 3,\n  }).send();\n\n  console.log('Collection deployment transaction sent');\n  \n  // Return mint info\n  return {\n    mint: {\n      transaction: mintResult,\n      collection: {\n        address: computeCollectionAddress(collectionId, isMainnet)\n      }\n    }\n  };\n}\n\n// Helper functions for NFT collection minting\nfunction generateCollectionId(): string {\n  return `collection_${Date.now()}_${Math.random().toString(36).substring(2, 15)}`;\n}\n\nfunction createCollectionDeployPayload(params: {\n  collectionId: string,\n  ownerAddress: string,\n  metadata: any,\n  royaltyParams: {\n    numerator: number,\n    denominator: number,\n    destination: string\n  },\n  mintMessageValue: string\n}): string {\n  // Implement the payload creation for collection deployment\n  // This would create the proper BoC for the Discovery contract\n  const payload = {};\n  \n  return payload;\n}\n\nfunction computeCollectionAddress(collectionId: string, isMainnet: boolean): string {\n  // This function would compute the expected collection address\n  // based on the collection ID and network\n  return `EQ...`;\n}\n\u0005End File\u0006# openproduct/qubic-jswrappers\nimport TonWeb from 'tonweb';\nimport { CHAIN } from '@tonconnect/ui';\nimport {\n  Address,\n  beginCell,\n  Builder,\n  Cell,\n  Contract,\n  ContractProvider,\n  Sender,\n  toNano,\n  Dictionary\n} from '@ton/core';\nimport {\n  QubicCollection,\n  QubicItem,\n  QubicMeta\n} from './types';\nimport { encodeOffChainContent } from './utils';\n\nexport type Network = CHAIN.MAINNET | CHAIN.TESTNET;\n\nexport const getTonWebNetwork = (network: Network) => {\n  switch (network) {\n    case CHAIN.MAINNET:\n      return true;\n    case CHAIN.TESTNET:\n      return false;\n    default:\n      return false;\n  }\n};\n\nexport type QubicConfig = {\n  network: Network;\n  collectionContract: string;\n  itemContract: string;\n  commissionAmount: string;\n  defaultMintMessageValue: string;\n  discoveryCatalogAddress: string;\n  defaultRoyalty: {\n    numerator: number;\n    denominator: number;\n  };\n};\n\nexport const defaultRoyaltyParams = {\n  numerator: 500,\n  denominator: 10000\n};\n\nexport const testnetConfig: QubicConfig = {\n  network: CHAIN.TESTNET,\n  collectionContract:\n    'EQBCFwW0NQta7-Pzlq0pUkpFgZqEfAACCkjqhYrPkxAJNKSk',\n  itemContract:\n    'EQB2BdH8eLL5sJxzBpDDBSzU9Hp9gGZTDiIGuO2d49F32hEA',\n  discoveryCatalogAddress:\n    'EQAmVfVlGvq7r6YBJVwxMEHJm_-O8NKPl54K15VkuuVnNu16',\n  commissionAmount: '0.05',\n  defaultMintMessageValue: '0.025',\n  defaultRoyalty: defaultRoyaltyParams\n};\n\nexport const mainnetConfig: QubicConfig = {\n  network: CHAIN.MAINNET,\n  collectionContract:\n    'EQAcpK4zrOY4DZMF4ekVXPQQ-18JLdS0iXWBN5jQKUvBwbKF',\n  itemContract:\n    'EQDHPWp-Xp-P4bXA0fRX35TbXnmJ19vFWYpsDcg67cCGXJQP',\n  discoveryCatalogAddress:\n    'EQCbMZOy3wIlD3HoQnykzr7jM0iN4o5T3hiAKGgT8GpJVQp4',\n  commissionAmount: '0.5',\n  defaultMintMessageValue: '0.025',\n  defaultRoyalty: defaultRoyaltyParams\n};\n\nexport type RoyaltyParams = {\n  numerator: number;\n  denominator: number;\n  royaltyAddress: Address;\n};\n\nexport type DiscoveryParams = {\n  ownerAddress: Address;\n  collectionMetaData: Cell;\n  parentAddress: Address;\n  itemCode: Cell;\n  royaltyParams: Cell;\n  mintMessage: Cell;\n  msgValue: bigint;\n};\n\nexport function discoveryParamsToCell(\n  params: DiscoveryParams\n): Cell {\n  return beginCell()\n    .storeRef(\n      packDiscoveryParams({\n        ownerAddress: params.ownerAddress,\n        collectionMetaData: params.collectionMetaData,\n        parentAddress: params.parentAddress,\n        itemCode: params.itemCode,\n        royaltyParams: params.royaltyParams,\n        mintMessage: params.mintMessage,\n        msgValue: params.msgValue\n      })\n    )\n    .endCell();\n}\n\nexport function buildRoyaltyParams(params: RoyaltyParams): Cell {\n  return beginCell()\n    .storeUint(params.numerator, 16)\n    .storeUint(params.denominator, 16)\n    .storeAddress(params.royaltyAddress)\n    .endCell();\n}\n\nexport function getContentForCollection(\n  collection: QubicMeta\n): Cell {\n  const content = encodeOffChainContent(JSON.stringify(collection));\n\n  return beginCell().storeBuffer(Buffer.from(content)).endCell();\n}\n\nexport function getContentForNFT(\n  item: QubicItem,\n  options: {\n    ownerAddress: Address;\n  }\n): Cell {\n  const json = JSON.stringify(item);\n  const data = encodeOffChainContent(json);\n\n  return beginCell()\n    .storeAddress(options.ownerAddress)\n    .storeRef(beginCell().storeBuffer(Buffer.from(data)).endCell())\n    .endCell();\n}\n\n// Builds a Cell for a batch of NFTs\nexport function buildBatchContent(\n  items: QubicItem[],\n  ownerAddress: Address\n): Cell {\n  // First, prepare individual cell for each NFT\n  const itemCells = items.map((item) =>\n    getContentForNFT(item, { ownerAddress })\n  );\n\n  // Now create a cell with references to all item cells\n  let batchCell: Builder = beginCell();\n  for (const itemCell of itemCells) {\n    batchCell = batchCell.storeRef(itemCell);\n  }\n\n  return batchCell.endCell();\n}\n\nexport const DICT_KEY_CODES = {\n  OWNER_ADDRESS: BigInt('0x6f776e65725f61646472657373'),\n  COLLECTION_META_DATA: BigInt(\n    '0x636f6c6c656374696f6e5f6d6574615f64617461'\n  ),\n  PARENT_ADDRESS: BigInt('0x706172656e745f61646472657373'),\n  ITEM_CODE: BigInt('0x6974656d5f636f6465'),\n  ROYALTY_PARAMS: BigInt('0x726f79616c74795f706172616d73'),\n  MINT_MESSAGE: BigInt('0x6d696e745f6d657373616765'),\n  MSG_VALUE: BigInt('0x6d73675f76616c7565')\n};\n\nexport function packDiscoveryParams(params: DiscoveryParams): Cell {\n  // Create a dictionary to store parameter key-value pairs\n  const dict = Dictionary.empty(\n    Dictionary.Keys.BigUint(256),\n    Dictionary.Values.Cell()\n  );\n\n  // Store owner address\n  dict.set(\n    DICT_KEY_CODES.OWNER_ADDRESS,\n    beginCell().storeAddress(params.ownerAddress).endCell()\n  );\n  \n  // Store collection metadata\n  dict.set(\n    DICT_KEY_CODES.COLLECTION_META_DATA,\n    params.collectionMetaData\n  );\n  \n  // Store parent address\n  dict.set(\n    DICT_KEY_CODES.PARENT_ADDRESS,\n    beginCell().storeAddress(params.parentAddress).endCell()\n  );\n  \n  // Store item code\n  dict.set(DICT_KEY_CODES.ITEM_CODE, params.itemCode);\n  \n  // Store royalty parameters\n  dict.set(DICT_KEY_CODES.ROYALTY_PARAMS, params.royaltyParams);\n  \n  // Store mint message\n  dict.set(DICT_KEY_CODES.MINT_MESSAGE, params.mintMessage);\n  \n  // Store message value\n  dict.set(\n    DICT_KEY_CODES.MSG_VALUE,\n    beginCell().storeCoins(params.msgValue).endCell()\n  );\n\n  // Return the dictionary as a cell\n  return beginCell().storeDict(dict).endCell();\n}\n\nexport class QubicDiscoveryContract implements Contract {\n  constructor(\n    readonly address: Address,\n    readonly init?: { code: Cell; data: Cell }\n  ) {}\n\n  static createFromAddress(address: Address) {\n    return new QubicDiscoveryContract(address);\n  }\n\n  async sendDeploy(\n    provider: ContractProvider,\n    via: Sender,\n    value: bigint\n  ) {\n    await provider.internal(via, {\n      value,\n      sendMode: 1,\n      body: beginCell().endCell()\n    });\n  }\n\n  async sendRegisterCollection(\n    provider: ContractProvider,\n    via: Sender,\n    opts: {\n      value: bigint;\n      queryId?: number;\n      collectionId: string;\n      ownerAddress: Address;\n      collectionMetaData: Cell;\n      collectionCode: Cell;\n      parentAddress: Address;\n      itemCode: Cell;\n      royaltyParams: Cell;\n      mintMessage: Cell;\n      msgValue: bigint;\n    }\n  ) {\n    const discoveryParams = discoveryParamsToCell({\n      ownerAddress: opts.ownerAddress,\n      collectionMetaData: opts.collectionMetaData,\n      parentAddress: opts.parentAddress,\n      itemCode: opts.itemCode,\n      royaltyParams: opts.royaltyParams,\n      mintMessage: opts.mintMessage,\n      msgValue: opts.msgValue\n    });\n\n    await provider.internal(via, {\n      value: opts.value,\n      sendMode: 1,\n      body: beginCell()\n        .storeUint(1, 32) // op: register_collection\n        .storeUint(opts.queryId || 0, 64)\n        .storeRef(beginCell().storeBuffer(Buffer.from(opts.collectionId)).endCell()) // collection ID as a ref cell\n        .storeBuilder(discoveryParams.asBuilder())\n        .storeRef(opts.collectionCode)\n        .endCell()\n    });\n  }\n\n  async getCollectionAddress(\n    provider: ContractProvider,\n    collectionId: string",
    "5-itglue-alternatives-affordable-powerfu|category|4": "Tekniskt skrivande"
}
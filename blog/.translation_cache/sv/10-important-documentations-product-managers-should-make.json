{
    "__metadata__": {
        "original_categories": [
            "Product Documentation",
            "Product Management",
            "Documentation Portals",
            "Best Practices",
            "Product Managers"
        ],
        "author_name": "Tal F.",
        "author_email": "tal@docsie.io",
        "author_info": "VP of Customer Success @ Docsie.io",
        "author_image": " https://cdn.docsie.io/user_profiles/15/logo_logo_QmXrbijvL0L2hFKNm6Q25DtjahujKdB6nu4pqBlLBgvtT.png",
        "header_image": "https://cdn.docsie.io/workspace_8D5W1pxgb7Jq3oZO7/doc_QpDdxIGnXpT0d02oQ/file_HklmFy6HpUlaN8sHv/boo_XGfvRm3TVTFbV6HET/009de899-1fe0-460f-f9c0-56afd1d9d917Untitled_1_min_1.jpg",
        "timestamp": "2021-11-30T16:29:04+00:00",
        "status": 1
    },
    "10-important-documentations-product-mana|title": "10 viktiga dokumentationer produktchefer bör skapa",
    "10-important-documentations-product-mana|summary": "Låt oss titta på några av fördelarna med dokumentation för produktchefer för att få en bättre förståelse för hur viktigt det verkligen är.",
    "10-important-documentations-product-mana|markdown": "Skriftlig kommunikation är utan tvekan en mer sammanhängande metod för att utbyta information om en mjukvaruprodukt som alla teammedlemmar bör känna till. Det är därför produktchefer lägger en betydande del av sin tid på att uppdatera dokumentation för alla mjukvarurelaterade projekt.\n\nDet är allmänt accepterat inom alla branscher att produktion av olika dokumentation för olika processer hjälper till att hålla hela utvecklingsprocessen strukturerad och förhindrar oväntade problem orsakade av kommunikationsmissar.\n\nLåt oss titta på några fördelar med dokumentation för produktchefer för att bättre förstå hur viktigt det verkligen är.\n\n## Varför är dokumentation viktigt för produktchefer?\n\n![Importance of documentation for product managers](https://cdn.docsie.io/workspace_8D5W1pxgb7Jq3oZO7/doc_vQfR1TFvrUMWGTXFc/file_XYQ5ntfsPFkJhvxSM/boo_tt3aeZp07xsCA9YkY/ddbbfc33-4cf1-a58f-090a-6b645b5f4034firmbee_com_gcsNOsPEXfs_unsplash.jpg)\n\n\n### För att utveckla en tydlig produktvision\n\nDokumentation hjälper produktchefer att hitta svar på alla \"varför\" som uppstår i projekt kring kärnprodukten eller tjänsten. Att skriva ner allt hjälper produktchefer att fatta viktiga beslut och få svar på frågor som vem produkten skapas för och varför appen eller produkten behöver utvecklas från början. Detta förebygger alla möjliga missförstånd eller misstag.\n\n### Ett betydande stöd i planeringsprocessen\n\nDu kan inte bara anta att din produkt är den bästa lösningen på problemet – du måste ha en strategi för att göra den till den bästa lösningen. Planering är avgörande. Genom att tydligt dokumentera sin vision genom att skapa användarberättelser, sprintar och mål hjälper chefer hela utvecklingsteamet att producera mjukvara som motsvarar användarnas behov.\n\n### Stödjer genomförande i tid\n\nOm planer inte genomförs i tid och på rätt sätt blir de verkningslösa. För att omvandla en appidé till en välfungerande applikation använder produktchefen dokumentation och skriftlig kommunikation med designers, utvecklare och andra intressenter för att styra dem i rätt riktning och genomföra de välformulerade planerna.\n\n### Team hålls ansvariga\n\nGenom att upprätthålla komplett dokumentation av allt arbete kopplat till en produkt kan produktchefer få tillgång till information om vad teammedlemmar gör och hålla dem ansvariga för sina delar av uppgifterna. Att föra detaljerade anteckningar om allt hjälper till att hålla saker enkla och tydliga.\n\n### Kundernas behov tillgodoses\n\nGenom att dokumentera allt från appkonceptet till planeringsfasen kan produktchefer enkelt se vilka funktioner som ska ingå i applikationen och vilka uppgifter varje funktion måste uppfylla. Senare kan de kommunicera denna bedömning till teamet på ett exakt och begripligt sätt, vilket säkerställer att slutprodukten är precis vad kunderna vill ha.\n\n\n\n**Att skapa dokumentation är en nyckelfaktor inom produktledning. Här följer en lista med 10 viktiga dokumentationer som produktchefer arbetar med för att maximera produktiviteten i sina team och projekt.**\n\n\n\n1. Dokumentation om konkurrentanalys\n\n2. Dokumentation som beskriver produktstrategi och vision\n\n3. Produktkravsdokumentation (PRDs)\n\n4. OKR, nyckeltal och framgångsmätningar\n\n5. Färdplansdokumentation\n\n6. Dokumentation om design och prototyper\n\n7. Dokumentation om användarresor och användarberättelser\n\n8. Dokumentation om releaseinformation och omfattning\n\n9. Interna guider och vanliga frågor\n\n10. Kundorienterade användarguider och produktdokumentation\n\n### Dokumentation om konkurrentanalys\n\nKonkurrentanalys är en stor del av marknadsundersökningen som låter dig undersöka din produkts konkurrensfördel jämfört med konkurrenter som producerar samma eller liknande produkt.\n\nKonkurrentanalys innebär att undersöka varor och tjänster som erbjuds av konkurrenter, samt deras marknadsandelar, styrkor och svagheter. Dokumentation om konkurrentanalys som innehåller alla dessa faktorer skapas och skickas till hela utvecklingsteamet för granskning. En produktchef fattar bara ett slutgiltigt beslut om designen av sin applikation eller produkt efter att ha gjort en grundlig undersökning av konkurrenterna.\n\nHär är ett exempel på hur en konkurrenttabell skulle se ut i dokumentationen för konkurrentanalys:\n\n* Företagets namn (konkurrenten)\n\n* Konkurrentens webbadress\n\n* Antal användare (för att uppskatta effektiviteten av dess produkter och tjänster)\n\n* Hur länge konkurrenten har funnits på marknaden\n\n* Konkurrenters specifika detaljer och expertområden\n\n* Kostnaden för en tjänst eller produkt\n\n* Anteckningar om olika ämnen\n\nEftersom produktchefer gör många olika typer av analyser kan innehållet i dokumentet variera kraftigt. Några av de mer välkända typerna är kapacitetsanalys, konkurrenslandskapsanalys, konkurrensedifferentieringsanalys, imiterbarhetsstege-analys och värdeerbjudandeanalys.\n\n### Dokumentation som beskriver produktstrategi och vision\n\n![Documentation Outlining the Product Strategy and Vision](https://cdn.docsie.io/workspace_8D5W1pxgb7Jq3oZO7/doc_vQfR1TFvrUMWGTXFc/file_fOcQeHgEHeuCjKOTU/boo_tt3aeZp07xsCA9YkY/115c02c0-2019-006e-ae69-acc57558cdd5patrick_perkins_ETRPjvb0KM0_unsplash_(1).jpg)\n\nProduktvisionen skapar en bild av produktens framtid som vi försöker utveckla. I form av en storyboard, berättelse eller prototyp är den avsedd att locka team, investerare och partners att investera i och stödja produkten.\n\nProduktstrategin definierar sekvensen av produkter som ska skapas tills den slutliga produkten uppnås.\n\nEn av de viktigaste förmågorna hos effektiva produktchefer är förmågan att utveckla en produktvision, men detta är bara början. De måste också bygga en lockande produktstrategi för att förmedla en tydlig syn på produkten. Både produktvisionen och produktstrategin måste vara mycket målmedvetna för att lyckas. Därför utarbetas dokumentation för att fånga all information kopplad till vad slutprodukten kommer att vara och hur man omvandlar en idé till verklighet. Oftast delas dessa material med intressenter för att få deras feedback och åsikter.\n\n### Produktkravsdokumentation (PRDs)\n\n**Produktkravsdokumentation** är en allomfattande dokumentation som samlar de olika aspekterna av en applikation på ett ställe. Specifikationsdokument är den vanligaste typen av dokument och de innehåller beskrivningar av applikationernas funktioner, bland annat.\n\nVarje PRD kan vara olika. Dessa dokumentationer beskriver forskningsfrågor, framgångsmått, MVP-funktionslista, tekniska implementeringsdetaljer och så vidare.\n\nProduktkravsdokument (PRDs) innehåller varje steg i hela produktbilden, beslut om att inkludera eller ta bort vissa funktioner, och indikerar eventuella svårigheter. Produktchefer kan använda detta dokument för att visualisera den tid som krävs för projektutvecklingsprocesser, förstå hur mycket pengar som behövs och skapa en ömsesidig förståelse mellan kunder och utvecklingsteamet.\n\nJag har beskrivit vikten av PRDs i en annan artikel. [För att lära dig mer klicka här.](https://www.docsie.io/blog/articles/product-requirements-documentation-for-product-managers/)\n\n### Dokumentation om mål och nyckelresultat, nyckeltal och framgångsmätningar\n\n![Objectives and key results, key performance indicators, and success metrics documentation](https://cdn.docsie.io/workspace_8D5W1pxgb7Jq3oZO7/doc_vQfR1TFvrUMWGTXFc/file_C5dij4zpuNJfYdxuZ/boo_tt3aeZp07xsCA9YkY/944a57c7-e03b-eb86-7f94-c5335ba726c3domenico_loia_hGV2TfOh0ns_unsplash.jpg)\n\n**Mål** och **nyckelresultat** (OKR) är en mekanism som produktchefer använder för att fastställa målen för produktutvecklingsprocessen och sedan följa upp resultaten medan processen fortsätter. Målet styr teamet mot målen, medan resultaten visar om målen har uppnåtts. Två frågor ställs och besvaras under processen: \"Vart vill du komma?\" och \"Har du kommit fram eller har du misslyckats med att nå\" ett specifikt mål eller produktmål.\n\nEtt nyckeltal, eller KPI, mäter den övergripande framgången för en utvecklingsprocess i dess nuvarande stadium. Kundlivstidsvärde och konverteringsgrad från test till kund inom försäljning, webbtrafik och konverteringsgrad inom marknadsföring är några exempel på nyckeltal (KPI:er). Alla dessa mål, liksom resultaten som uppnåtts under processens gång, beskrivs i relevant dokumentation.\n\n### Färdplansdokumentation\n\nFärdplaner är en av de viktigaste dokumentationerna som produktchefer ska utforma. En färdplan fungerar som ett sätt att kommunicera produktens betydelse till teamet.\n\nEn produktchef skapar en produktlivscykel som beskriver vad som behöver göras, när det behöver göras och hur hela processen ska genomföras. En färdplan är ett dokument som innehåller en lista över alla initiativ som har tagits för att effektivt bygga mjukvara eller någon annan produkt. Det är en väg som produktchefer har lagt ut och som hela teamet följer. Dessa kan förberedas på Docsie för att skickas till deras anställda med inbäddade PowerPoint-presentationer inom dokumentationen skapad av Google Slides. Docsie möjliggör integration med Google slides genom våra integrationsmöjligheter. För att lära dig mer om Docsies integrationsmöjligheter [klicka här.](https://help.docsie.io/?doc=/docsie-integrations/)\n\n### Dokumentation om design och prototyper\n\n![Documentation pertaining to designs and prototypes](https://cdn.docsie.io/workspace_8D5W1pxgb7Jq3oZO7/doc_vQfR1TFvrUMWGTXFc/file_7UkZbKPYCrKwI0wls/boo_tt3aeZp07xsCA9YkY/dbf4c782-cb7c-467a-3fbb-eaf18de2c57bedho_pratama_T6fDN60bMWY_unsplash.jpg)\n\nAtt skapa något från grunden utan en ritning är mycket svårt. Detta gäller även för produktdesign. Även om grundkonceptet är viktigt kan hundratals varianter uppstå under utvecklingsprocessen. Därför måste produktchefer upprätthålla ett dokument som registrerar alla ändringar och revideringar som har gjorts i produktens design.\n\nNär det gäller produktprototyper har produktchefer en mycket annorlunda upplevelse än ingenjörer eller designers. Produktchefer sätter tonen för prototypframtagning genom att sätta tydliga mål och lägga ut en färdplan för teamet att följa.\n\nOm du undrar varför en produktchef skulle behöva skapa en app-protypdokumentation, överväg följande fördelar:\n\n* Risken för missförstånd elimineras helt\n\n* Iterationer slutförs snabbt\n\n* Tidigt i processen är det viktigt att motivera idéerna\n\n* Förbättringar i kvaliteten på teknisk feedback\n\nAv dessa skäl och fler är prototypdokumentation nödvändig.\n\n### Dokumentation om användarresor och användarberättelser\n\nI utvecklingen av någon applikation eller plattform är **användarberättelser** och **kundreskartor** två kritiska verktyg som måste användas tillsammans. Produktchefer utvecklar och upprätthåller dokumentation för dessa två för att säkerställa att varje detalj registreras och förvaras säkert.\n\nNär man skapar ett användarberättelsedokument är det viktigt att tänka på de många anledningarna till varför en användare skulle vilja använda en viss produkt. Produktchefer registrerar varje tänkbar utlösare som kan leda till att en användare interagerar med en funktion i plattformen, inklusive buggar och funktionsförfrågningar. En användarresa kan i detta fall betraktas på mikronivå.\n\nAnvändarresan är däremot ett dokument som kartlägger hela användarupplevelsen, från köp eller nedladdning till användning av produktens funktioner. Detta hjälper produktchefer att ytterligare förklara produkten för sitt team och andra intressenter (till exempel intressenter), samt att etablera deras förtroende för själva produkten. Denna information kan också användas som marknadsföringsresurser för reklamkampanjer eller för att förklara användningsfallet för en produkt för potentiella kunder.\n\n### Dokumentation om releaseinformation och omfattning\n\n**Releaseinformation**, som namnet antyder, är dokumentationen som skickas ut i samband med lanseringen av nya plattformar eller SaaS-produkter. För att informera användare om nya standarder, identifiera vilka problem som har lösts och marknadsföra applikationen när uppdateringen är klar, sammanställer produktchefer denna dokumentation. Eftersom SaaS-produkter skiljer sig mycket från varandra är ingen dokumentation exakt likadan.\n\nOmfattningsdokumentation kallas ibland för arbetets omfattningsdokument. Chefer använder detta verktyg för att definiera bredden av funktionerna som en applikation eller en programvara innehåller, vad dessa funktioner möjliggör och så vidare.\n\n### Interna guider och vanliga frågor\n\nDet är nödvändigt att producera konfidentiella interna **FAQ** för intressenter för att hålla dem informerade under hela produktutvecklingsprocessen. Sättet på vilket dessa FAQ skrivs är mycket enkelt. Wireframes för en produkt med en stark användarupplevelseskomponent, eller en länk till uppdelad wireframe-dokumentation, kan finnas i denna mapp.\n\nAll information om hur saker fungerar i utvecklingsprocessen ingår i dessa interna manualer. Förutom att säkerställa att data registreras på ett sådant sätt att det möjliggör smidig överlämning mellan medlemmar, fungerar det också som en referens för externa positioner som försäljning, marknadsföring, kundsupport och liknande positioner för att hjälpa kunder.\n\n### Kundorienterade användarguider och produktdokumentation\n\n![Customer-Facing User Guides and Product Documentation](https://cdn.docsie.io/workspace_8D5W1pxgb7Jq3oZO7/doc_vQfR1TFvrUMWGTXFc/file_QaQUnhXAgdAoDoEVV/boo_tt3aeZp07xsCA9YkY/a9b5abb3-dc46-6359-9f21-cb8c8319a976mantas_hesthaven__g1WdcKcV3w_unsplash.jpg)\n\nFör den oinvigde är den kundorienterade guiden en användarmanualdokument i traditionell bemärkelse. Det är produktchefernas ansvar att förbereda denna dokumentation, som ger instruktioner om hur man använder den nyutvecklade SaaS-produkten.\n\nAnvändare kan hamna i förvirring om hur man kör produkten om detta inte görs, åtminstone i början, tills de själva räknar ut flödet. Därför bör det vara uppenbart varför detta dokument är så viktigt att det är ett av de mest använda eller utvecklade dokumentationerna av produktchefer i branschen.\n\n## Slutsatser:\n\nKort sagt, följande dokumentationer är de tio viktigaste dokumenten som kompetenta produktchefer förlitar sig på för att säkerställa en effektiv produkthanteringsprocess.\n\nTack vare dessa dokumentationer är det omöjligt för dem att ha några missförstånd eller tvister eftersom de har delat upp informationen om uppgifterna i flera dokument. Det skapar en mycket strukturerad och smidig utvecklingsprocess som har dokumenterats noggrant i varje steg.\n\n### Hur kan Docsie hjälpa till att skapa all denna dokumentation?\n\nDocsie är en robust plattform som är produktchefernas bästa vän när det gäller dokumentation. Docsie specialiserar sig på att skapa, hantera och publicera dokumentation som kan översättas till olika språk med ett sofistikerat versionssystem, lättanvänd redigerare och olika andra fantastiska funktioner som hjälper produktchefer att skapa robust och dynamisk online-dokumentation.\n\n[För att prova Docsie gratis, klicka här.](https://www.docsie.io/)",
    "10-important-documentations-product-mana|category|0": "Produktdokumentation\n\u0000module.exports = (function(){\n\"use strict\";\n\nconst fs = require(\"fs\");\nconst path = require(\"path\");\nconst mysql = require(\"mysql2\");\nconst argv = require(\"./argv.js\");\nconst util = require(\"./util.js\");\nconst config = require(\"./config.js\");\nconst Database = require(\"./database.js\");\n\nfunction loadSQLFile (file) {\n\tif (!fs.existsSync(file)) {\n\t\treturn null;\n\t}\n\n\treturn fs.readFileSync(file).toString();\n}\n\nmodule.exports = class MariaDB extends Database {\n\tstatic get name () { return \"mariadb\"; }\n\tstatic get database () { return \"MariaDB\"; }\n\tstatic get parameterPrefix () { return \"?\"; }\n\tstatic get usesAmbiguousInterval () { return false; }\n\tstatic get formatPath () { return __dirname; }\n\tstatic get sqlFilePath () { return path.normalize(`${__dirname}/../sql/definitions/mariadb`); }\n\n\tstatic async checkConnection (options) {\n\t\tif (!options) {\n\t\t\tthrow new Error(\"No database options provided\");\n\t\t}\n\n\t\t// MariaDB defaults\n\t\toptions.connectTimeout = options.connectTimeout || 10_000;\n\t\toptions.socketTimeout = options.socketTimeout || 10_000;\n\t\toptions.dateStrings = true;\n\n\t\tconst connection = mysql.createConnection(options);\n\t\tawait connection.promise().connect();\n\n\t\treturn {\n\t\t\tconnection,\n\t\t\tdatabase: this\n\t\t};\n\t}\n\n\t/**\n\t * Creates a connection to the database.\n\t * @param options\n\t * @param name\n\t * @returns {Promise<void>}\n\t */\n\tstatic async connect (options, name = \"sb\") {\n\t\ttry {\n\t\t\tconsole.log(\"Connecting to database...\");\n\n\t\t\toptions.dateStrings = true;\n\t\t\toptions.connectTimeout = options.connectTimeout || 10_000;\n\t\t\toptions.socketTimeout = options.socketTimeout || 10_000;\n\n\t\t\tconst connection = mysql.createConnection(options);\n\t\t\tawait connection.promise().connect();\n\n\t\t\tconst connectionData = { options, connection, pool: null };\n\t\t\tthis.addConnection(name, connectionData);\n\n\t\t\tconsole.log(\"Database connection OK\", name);\n\t\t\tif (name === \"sb\") {\n\t\t\t\tglobal.queryCounter = 0;\n\t\t\t\tglobal.queryStartTime = process.hrtime.bigint();\n\t\t\t\tglobal.queryTotalTime = 0n;\n\t\t\t}\n\t\t}\n\t\tcatch (err) {\n\t\t\tconsole.error(\"Database connection failed\", err);\n\t\t\tprocess.exit(1);\n\t\t}\n\t}\n\n\tstatic async connectWithOptions (options, name = \"sb\") {\n\t\tif (!options) {\n\t\t\tthrow new Error(\"No MariaDB options provided\");\n\t\t}\n\n\t\toptions.connectTimeout = options.connectTimeout || 10_000;\n\t\toptions.socketTimeout = options.socketTimeout || 10_000;\n\t\toptions.dateStrings = true;\n\n\t\tconst connection = mysql.createConnection(options);\n\t\tawait connection.promise().connect();\n\n\t\tconst connectionData = { options, connection, pool: null };\n\t\tthis.addConnection(name, connectionData);\n\n\t\treturn { connector: this, connection: connectionData };\n\t}\n\n\tstatic addConnection (name, connectionData) {\n\t\tif (!this.data) {\n\t\t\tthis.data = {};\n\t\t}\n\n\t\tthis.data[name] = connectionData;\n\t}\n\n\tstatic async useDatabase (specificDatabase, options) {\n\t\tconst pool = mysql.createPool({\n\t\t\t...options,\n\t\t\tdatabase: specificDatabase,\n\t\t\tconnectionLimit: 25,\n\t\t\tconnectTimeout: options.connectTimeout || 10_000,\n\t\t\tsocketTimeout: options.socketTimeout || 10_000,\n\t\t\tdateStrings: true\n\t\t});\n\n\t\tthis.data.sb.pool = pool;\n\t}\n\n\tstatic get modulePath () { return \"supibot-package-manager\"; }\n\n\tstatic get fetchSingleRow () { return true; }\n\n\tstatic get raw () {\n\t\treturn {\n\t\t\t/**\n\t\t\t * Similar to transaction, but does not use a transaction.\n\t\t\t * Useful for queries that lock tables, which don't work within transactions.\n\t\t\t * @param callback\n\t\t\t * @returns {Promise<unknown>}\n\t\t\t */\n\t\t\tunsafe: async (callback) => {\n\t\t\t\tconst promisePool = this.data.sb.pool.promise();\n\t\t\t\tconst conn = await promisePool.getConnection();\n\n\t\t\t\ttry {\n\t\t\t\t\tconst result = await callback(conn);\n\t\t\t\t\treturn result;\n\t\t\t\t}\n\t\t\t\tcatch (e) {\n\t\t\t\t\tconsole.error(\"MariaDB unsafe mode error\", e);\n\t\t\t\t\tthrow e;\n\t\t\t\t}\n\t\t\t\tfinally {\n\t\t\t\t\tconn.release();\n\t\t\t\t}\n\t\t\t},\n\n\t\t\t/**\n\t\t\t * Creates a transaction and executes the callback.\n\t\t\t * If the callback throws, the transaction is rolled back.\n\t\t\t * Otherwise, the transaction is committed.\n\t\t\t * @param callback\n\t\t\t * @returns {Promise<unknown>}\n\t\t\t */\n\t\t\ttransaction: async (callback) => {\n\t\t\t\tconst promisePool = this.data.sb.pool.promise();\n\t\t\t\tconst conn = await promisePool.getConnection();\n\n\t\t\t\ttry {\n\t\t\t\t\tawait conn.beginTransaction();\n\t\t\t\t\tconst result = await callback(conn);\n\t\t\t\t\tawait conn.commit();\n\n\t\t\t\t\treturn result;\n\t\t\t\t}\n\t\t\t\tcatch (e) {\n\t\t\t\t\tawait conn.rollback();\n\t\t\t\t\tconsole.error(\"MariaDB transaction error\", e);\n\t\t\t\t\tthrow e;\n\t\t\t\t}\n\t\t\t\tfinally {\n\t\t\t\t\tconn.release();\n\t\t\t\t}\n\t\t\t},\n\n\t\t\t/**\n\t\t\t * Simple method to pool-execute a given query with given variables.\n\t\t\t * @param query\n\t\t\t * @param variables\n\t\t\t * @returns {Promise<*>}\n\t\t\t */\n\t\t\texecute: async (query, variables) => {\n\t\t\t\ttry {\n\t\t\t\t\tconst promisePool = this.data.sb.pool.promise();\n\t\t\t\t\tconst [rows] = await promisePool.execute(query, variables ?? []);\n\t\t\t\t\treturn rows;\n\t\t\t\t}\n\t\t\t\tcatch (e) {\n\t\t\t\t\tconsole.error(\"SQL error\", {\n\t\t\t\t\t\tquery,\n\t\t\t\t\t\tvariables,\n\t\t\t\t\t\terror: e\n\t\t\t\t\t});\n\n\t\t\t\t\tthrow e;\n\t\t\t\t}\n\t\t\t},\n\n\t\t\t/**\n\t\t\t * Executes a transactional query.\n\t\t\t * @param query\n\t\t\t * @param variables\n\t\t\t * @returns {Promise<unknown>}\n\t\t\t */\n\t\t\ttransactionQuery: async (query, variables) => {\n\t\t\t\treturn this.raw.transaction(async (connection) => {\n\t\t\t\t\tconst [rows] = await connection.execute(query, variables ?? []);\n\t\t\t\t\treturn rows;\n\t\t\t\t});\n\t\t\t}\n\t\t};\n\t}\n\n\tstatic escapeIdentifier (identifier) {\n\t\treturn `\\`${identifier}\\``;\n\t}\n\n\tstatic escapeBoolean (value) {\n\t\treturn (value) ? \"1\" : \"0\";\n\t}\n\n\tstatic escapeString (string) {\n\t\treturn mysql.escape(string);\n\t}\n\n\tstatic async executeQuery (query, useDatabase, options = {}) {\n\t\tif (options.limit && !options.limit.offset) {\n\t\t\toptions.limit.offset = 0;\n\t\t}\n\t\tif (options.limit) {\n\t\t\tquery += ` LIMIT ${options.limit.offset ?? 0}, ${options.limit.limit}`;\n\t\t}\n\n\t\tlet sql = \"\";\n\t\tif (options.rawMode === \"prepare\") {\n\t\t\tsql = query;\n\t\t}\n\t\telse {\n\t\t\tconst preSQL = loadSQLFile(`${this.sqlFilePath}/${query}.sql`);\n\t\t\tif (preSQL === null) {\n\t\t\t\tsql = query;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tsql = preSQL;\n\t\t\t}\n\t\t}\n\n\t\tconst tries = {\n\t\t\tamount: options.retries ?? 3,\n\t\t\tcurrent: 0\n\t\t};\n\n\t\tconst fetchSingleRowFromResults = (options.fetchSingleRow === undefined)\n\t\t\t? this.fetchSingleRow\n\t\t\t: options.fetchSingleRow;\n\n\t\tlet row = null;\n\t\tlet promisePool = null;\n\t\tconst throwError = async (e) => {\n\t\t\tif (e.code === \"ER_LOCK_DEADLOCK\" || e.code === \"ER_LOCK_WAIT_TIMEOUT\") {\n\t\t\t\tconsole.warn(\"SQL lock timeout\", { tries: tries.current, query: sql });\n\t\t\t\tif (tries.current < tries.amount) {\n\t\t\t\t\ttries.current++;\n\t\t\t\t\tawait util.sleep(tries.current * 100);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tthrow new Error(\"SQL deadlock limit reached\");\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tthrow e;\n\t\t\t}\n\t\t};\n\n\t\t// eslint-disable-next-line no-constant-condition\n\t\twhile (true) {\n\t\t\ttry {\n\t\t\t\tif (options.connection) {\n\t\t\t\t\t[row] = await options.connection.execute(sql, options.params ?? []);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\t// If using a specific database, then connect to it using the pool\n\t\t\t\t\tif (useDatabase) {\n\t\t\t\t\t\tif (this.data.sb.pool === null) {\n\t\t\t\t\t\t\tthis.data.sb.pool = mysql.createPool({\n\t\t\t\t\t\t\t\t...this.data.sb.options,\n\t\t\t\t\t\t\t\tdatabase: useDatabase,\n\t\t\t\t\t\t\t\tconnectionLimit: 25,\n\t\t\t\t\t\t\t\tconnectTimeout: this.data.sb.options.connectTimeout || 10_000,\n\t\t\t\t\t\t\t\tsocketTimeout: this.data.sb.options.socketTimeout || 10_000,\n\t\t\t\t\t\t\t\tdateStrings: true\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tpromisePool = this.data.sb.pool.promise();\n\t\t\t\t\t}\n\t\t\t\t\t// Otherwise, use the specific database connection directly\n\t\t\t\t\telse {\n\t\t\t\t\t\tpromisePool = this.data.sb.connection.promise();\n\t\t\t\t\t}\n\n\t\t\t\t\tif (argv.debug) {\n\t\t\t\t\t\tconst before = process.hrtime.bigint();\n\t\t\t\t\t\t[row] = await promisePool.execute(sql, options.params ?? []);\n\t\t\t\t\t\tconst after = process.hrtime.bigint();\n\t\t\t\t\t\tconst delta = after - before;\n\n\t\t\t\t\t\tglobal.queryCounter++;\n\t\t\t\t\t\tglobal.queryTotalTime += delta;\n\n\t\t\t\t\t\tconsole.debug({\n\t\t\t\t\t\t\tcounter: global.queryCounter,\n\t\t\t\t\t\t\ttime: Number(delta / 1_000_000n),\n\t\t\t\t\t\t\ttotal: Number(global.queryTotalTime / 1_000_000n),\n\t\t\t\t\t\t\tavg: (Number(global.queryTotalTime / 1_000_000n) / global.queryCounter),\n\t\t\t\t\t\t\tthroughput: Math.ceil(global.queryCounter / (Number(process.hrtime.bigint() - global.queryStartTime) / 1e9))\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\t[row] = await promisePool.execute(sql, options.params ?? []);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (row.insertId && fetchSingleRowFromResults) {\n\t\t\t\t\treturn { insertId: row.insertId };\n\t\t\t\t}\n\t\t\t\telse if (fetchSingleRowFromResults && Array.isArray(row) && row.length === 1) {\n\t\t\t\t\treturn row[0];\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\treturn row;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (e) {\n\t\t\t\tif (e.code === \"ER_LOCK_DEADLOCK\" || e.code === \"ER_LOCK_WAIT_TIMEOUT\") {\n\t\t\t\t\tawait throwError(e);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tconsole.error(\"SQL error\", {\n\t\t\t\t\t\tcode: e.code,\n\t\t\t\t\t\terror: e,\n\t\t\t\t\t\tquery: sql,\n\t\t\t\t\t\tparams: options.params\n\t\t\t\t\t});\n\n\t\t\t\t\tthrow e;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Starts a serialized transaction block.\n\t * @param connection\n\t * @returns {Promise<void>}\n\t */\n\tstatic async beginTransaction (connection) {\n\t\tawait connection.execute(\"SET SESSION TRANSACTION ISOLATION LEVEL SERIALIZABLE\");\n\t\tawait connection.beginTransaction();\n\t}\n\n\tstatic async serialTransaction (callback) {\n\t\tif (!this.data.sb.pool) {\n\t\t\tthrow new Error(\"No database pool available\");\n\t\t}\n\n\t\tconst promisePool = this.data.sb.pool.promise();\n\t\tconst connection = await promisePool.getConnection();\n\n\t\ttry {\n\t\t\tawait connection.query(\"SET SESSION TRANSACTION ISOLATION LEVEL SERIALIZABLE\");\n\t\t\tawait connection.beginTransaction();\n\n\t\t\tconst result = await callback(connection);\n\t\t\tawait connection.commit();\n\n\t\t\treturn result;\n\t\t}\n\t\tcatch (e) {\n\t\t\tconsole.error(\"Transaction error\", e);\n\t\t\tawait connection.rollback();\n\t\t\tthrow e;\n\t\t}\n\t\tfinally {\n\t\t\tconnection.release();\n\t\t}\n\t}\n\n\tstatic async initialize () {\n\t\tawait this.connect(config.get(\"MARIA\"));\n\t}\n\n\tstatic async getDatabases () {\n\t\treturn await this.executeQuery(\"SHOW DATABASES\");\n\t}\n\n\tstatic convertDateToSQL (date) {\n\t\tif (!(date instanceof Date)) {\n\t\t\tdate = new Date(date);\n\t\t}\n\n\t\treturn date.toISOString()\n\t\t\t.slice(0, 19)\n\t\t\t.replace(\"T\", \" \");\n\t}\n\n\tstatic parseAvailability (user, data) {\n\t\tconst availability = data.Availability;\n\t\treturn {\n\t\t\tavailability: {\n\t\t\t\tstatus: (availability === null) ? null : Boolean(availability.Status),\n\t\t\t\tdescription: (availability === null) ? null : availability.Description\n\t\t\t}\n\t\t};\n\t}\n};\n\nreturn module.exports;\n})();\n\u0005End File\u0006# util.js\nmodule.exports = (function () {\n\t\"use strict\";\n\n\t/**\n\t * @typedef {'string'|'number'|'boolean'} GenericTypeString\n\t */\n\n\t/**\n\t * @template {GenericTypeString} T\n\t * @typedef {T extends 'string' ? string : T extends 'number' ? number : T extends 'boolean' ? boolean : never} MappedType\n\t */\n\n\t/**\n\t * @template {GenericTypeString} T\n\t * @param {T} expectedType\n\t * @param {any} value\n\t * @returns {MappedType<T>}\n\t */\n\tconst typeCast = (expectedType, value) => {\n\t\tif (typeof value === expectedType) {\n\t\t\treturn value;\n\t\t}\n\n\t\tif (expectedType === \"string\") {\n\t\t\treturn String(value);\n\t\t}\n\t\telse if (expectedType === \"number\") {\n\t\t\tconst temp = Number(value);\n\t\t\tif (Number.isNaN(temp)) {\n\t\t\t\tthrow new Error(\"Cannot parse to number\");\n\t\t\t}\n\t\t\telse {\n\t\t\t\treturn temp;\n\t\t\t}\n\t\t}\n\t\telse if (expectedType === \"boolean\") {\n\t\t\tif (typeof value === \"string\") {\n\t\t\t\t// loose checking\n\t\t\t\tif (value.toLowerCase() === \"true\" || value === \"1\") {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\telse if (value.toLowerCase() === \"false\" || value === \"0\") {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tthrow new Error(\"Cannot parse boolean value\");\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (typeof value === \"number\") {\n\t\t\t\tif (value === 1) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\telse if (value === 0) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tthrow new Error(\"Cannot parse boolean value\");\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tthrow new Error(\"Invalid value or type\");\n\t};\n\n\t/**\n\t * @param {number} ms\n\t * @returns {Promise<void>}\n\t */\n\tconst sleep = (ms) => {\n\t\treturn new Promise(resolve => setTimeout(resolve, ms));\n\t};\n\n\t/**\n\t * Returns a new promise that throws if the original promise rejects within the given timeout.\n\t * @template T\n\t * @param {Promise<T>} promise\n\t * @param {number} timeout\n\t * @param {string|Function} [errorWhenTimedOut] If not provided, a default error message is used.\n\t * @returns {Promise<T>}\n\t */\n\tconst promiseWithTimeout = (promise, timeout, errorWhenTimedOut) => {\n\t\treturn new Promise((resolve, reject) => {\n\t\t\tsetTimeout(() => {\n\t\t\t\tif (typeof errorWhenTimedOut === \"function\") {\n\t\t\t\t\treject(errorWhenTimedOut());\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\treject(new Error(errorWhenTimedOut ?? \"Promise timed out\"));\n\t\t\t\t}\n\t\t\t}, timeout);\n\t\t\tpromise.then(resolve).catch(reject);\n\t\t});\n\t};\n\n\t/**\n\t * @template T\n\t * @param {Promise<T>} promise\n\t * @param {number} timeout\n\t * @param {T} fallbackValue\n\t * @returns {Promise<T>}\n\t */\n\tconst promiseWithFallback = (promise, timeout, fallbackValue) => {\n\t\treturn new Promise((resolve) => {\n\t\t\tlet timedOut = false;\n\t\t\tconst timer = setTimeout(() => {\n\t\t\t\ttimedOut = true;\n\t\t\t\tresolve(fallbackValue);\n\t\t\t}, timeout);\n\n\t\t\tpromise.then(value => {\n\t\t\t\tclearTimeout(timer);\n\t\t\t\tif (!timedOut) {\n\t\t\t\t\tresolve(value);\n\t\t\t\t}\n\t\t\t}).catch(e => {\n\t\t\t\tconsole.error(e);\n\t\t\t\tclearTimeout(timer);\n\t\t\t\tif (!timedOut) {\n\t\t\t\t\tresolve(fallbackValue);\n\t\t\t\t}\n\t\t\t});\n\t\t});\n\t};\n\n\t/**\n\t * @template T\n\t * @param {Array<T>} array\n\t * @param {string|number} property\n\t * @returns {Array<T>}\n\t */\n\tconst removeDuplicatesFromArrayByProperty = (array, property) => {\n\t\treturn [...new Map(array.map(item => [item[property], item])).values()];\n\t};\n\n\t/**\n\t * @template T\n\t * @param {Array<T>} array\n\t * @returns {Array<T>}\n\t */\n\tconst shuffleArray = (array) => {\n\t\tif (!Array.isArray(array)) {\n\t\t\tthrow new Error(\"shuffleArray() argument must be an array\");\n\t\t}\n\n\t\tconst shuffled = [...array];\n\t\tfor (let i = shuffled.length - 1; i > 0; i--) {\n\t\t\tconst j = Math.floor(Math.random() * (i + 1));\n\t\t\t[shuffled[i], shuffled[j]] = [shuffled[j], shuffled[i]];\n\t\t}\n\n\t\treturn shuffled;\n\t};\n\n\t/**\n\t * @param {number} min\n\t * @param {number} max\n\t * @returns {number}\n\t */\n\tconst getRandomInt = (min, max) => {\n\t\tmin = Math.ceil(min);\n\t\tmax = Math.floor(max);\n\t\treturn Math.floor(Math.random() * (max - min + 1)) + min;\n\t};\n\n\t/**\n\t * @param {string[]} fullList\n\t * @param {string} name\n\t * @returns {string|null}\n\t */\n\tconst closeenough = (fullList, name) => {\n\t\tif (!name) {\n\t\t\treturn null;\n\t\t}\n\n\t\t// If the name is already in the list, then it's a \"perfect\" match\n\t\tconst found = fullList.find(i => i.toLowerCase() === name.toLowerCase());\n\t\tif (found) {\n\t\t\treturn found;\n\t\t}\n\n\t\t// First step: Trim the name to avoid whitespace issues.\n\t\t// Then, convert to lowercase for case-insensitive matching.\n\t\t// Finally, replace spaces with empty strings for easier matching.\n\t\tconst trimmedName = name.trim().toLowerCase().replace(/\\s+/g, \"\");\n\t\tif (trimmedName.length === 0) {\n\t\t\treturn null;\n\t\t}\n\n\t\t// Check if the processed name is contained in any processed item in the list.\n\t\t// This is the most lenient check.\n\t\tconst results = fullList.filter(item => {\n\t\t\tconst processedItem = item.toLowerCase().replace(/\\s+/g, \"\");\n\t\t\treturn processedItem.includes(trimmedName) || trimmedName.includes(processedItem);\n\t\t});\n\n\t\t// Return the most accurate result, or null if none exists.\n\t\tif (results.length === 0) {\n\t\t\treturn null;\n\t\t}\n\t\telse if (results.length === 1) {\n\t\t\treturn results[0];\n\t\t}\n\t\telse {\n\t\t\t// If multiple results, try to find the closest match\n\t\t\tconst sorted = results.sort((a, b) => {\n\t\t\t\tconst aDiff = Math.abs(a.length - name.length);\n\t\t\t\tconst bDiff = Math.abs(b.length - name.length);\n\t\t\t\treturn aDiff - bDiff;\n\t\t\t});\n\n\t\t\treturn sorted[0];\n\t\t}\n\t};\n\n\t/**\n\t * @param {string[]} options\n\t * @param {string} search\n\t * @returns {string|null}\n\t */\n\tconst stringSearch = (options, search) => {\n\t\tif (!search) {\n\t\t\treturn null;\n\t\t}\n\n\t\t// If there's an exact match (case insensitive), return that\n\t\tfor (const option of options) {\n\t\t\tif (option.toLowerCase() === search.toLowerCase()) {\n\t\t\t\treturn option;\n\t\t\t}\n\t\t}\n\n\t\t// Find an option that contains the search string (case insensitive)\n\t\tfor (const option of options) {\n\t\t\tif (option.toLowerCase().includes(search.toLowerCase())) {\n\t\t\t\treturn option;\n\t\t\t}\n\t\t}\n\n\t\t// Find an option where the search string contains the option (case insensitive)\n\t\tfor (const option of options) {\n\t\t\tif (search.toLowerCase().includes(option.toLowerCase())) {\n\t\t\t\treturn option;\n\t\t\t}\n\t\t}\n\n\t\t// No match found\n\t\treturn null;\n\t};\n\n\t/**\n\t * @param {string[]} options\n\t * @param {string} search\n\t * @returns {string|null}\n\t */\n\tconst fuzzyMatch = (options, search) => {\n\t\tif (!search) {\n\t\t\treturn null;\n\t\t}\n\n\t\t// First, try exact match (case insensitive)\n\t\tfor (const option of options) {\n\t\t\tif (option.toLowerCase() === search.toLowerCase()) {\n\t\t\t\treturn option;\n\t\t\t}\n\t\t}\n\n\t\t// Next, try prefix match (case insensitive)\n\t\tconst searchLower = search.toLowerCase();\n\t\tconst prefixMatches = options.filter(option => option.toLowerCase().startsWith(searchLower));\n\t\tif (prefixMatches.length === 1) {\n\t\t\treturn prefixMatches[0];\n\t\t}\n\n\t\t// Then, try fuzzy matching by checking if each character in search appears in the option in order\n\t\tconst fuzzyMatches = options.filter(option => {\n\t\t\tconst optionLower = option.toLowerCase();\n\t\t\tlet index = 0;\n\t\t\tfor (const char of searchLower) {\n\t\t\t\tindex = optionLower.indexOf(char, index);\n\t\t\t\tif (index === -1) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\tindex++;\n\t\t\t}\n\t\t\treturn true;\n\t\t});\n\n\t\t// Return the first match, or null if none found\n\t\treturn fuzzyMatches[0] || null;\n\t};\n\n\t/**\n\t * @param {string} commandString\n\t * @returns {Object}\n\t */\n\tconst parseUserCommandArguments = (commandString) => {\n\t\t// Get rid of double+ spaces\n\t\tconst args = commandString.replace(/\\s+/g, \" \").trim().split(\" \");\n\t\tconst result = {};\n\n\t\t// Flags (no arguments)\n\t\tconst flags = args.filter(i => i.startsWith(\"--\") && !i.includes(\"=\"));\n\t\tfor (const flag of flags) {\n\t\t\tconst name = flag.slice(2).toLowerCase();\n\t\t\tresult[name] = true;\n\t\t}\n\n\t\t// Arguments (with value)\n\t\tconst params = args.filter(i => i.startsWith(\"--\") && i.includes(\"=\"));\n\t\tfor (const param of params) {\n\t\t\tconst [rawName, value] = param.split(\"=\");\n\t\t\tconst name = rawName.slice(2).toLowerCase();\n\t\t\tresult[name] = value;\n\t\t}\n\n\t\treturn result;\n\t};\n\n\t/**\n\t * @param {Array} array\n\t * @param {string|number} property\n\t * @param {string|number} value\n\t * @returns {*}\n\t */\n\tconst getByProperty = (array, property, value) => {\n\t\tif (typeof property !== \"string\" && typeof property !== \"number\") {\n\t\t\tthrow new Error(\"Property must be a string or number\");\n\t\t}\n\n\t\treturn array.find(i => i[property] === value);\n\t};\n\n\t/**\n\t * @template T\n\t * @param {Array<T>} array1\n\t * @param {Array<T>} array2\n\t * @returns {Array<T>}\n\t */\n\tconst combinedArrays = (array1, array2) => {\n\t\treturn [...new Set([...array1, ...array2])];\n\t};\n\n\t/**\n\t * @template T\n\t * @param {Array<T>} array1\n\t * @param {Array<T>} array2\n\t * @returns {Array<T>}\n\t */\n\tconst intersection = (array1, array2) => {\n\t\treturn array1.filter(i => array2.includes(i));\n\t};\n\n\t/**\n\t * @template T\n\t * @param {Array<T>} array1\n\t * @param {Array<T>} array2\n\t * @returns {Array<T>}\n\t */\n\tconst difference = (array1, array2) => {\n\t\treturn array1.filter(i => !array2.includes(i));\n\t};\n\n\t/**\n\t * @template T\n\t * @param {Array<T>} array1\n\t * @param {Array<T>} array2\n\t * @returns {Array<T>}\n\t */\n\tconst symmetricDifference = (array1, array2) => {\n\t\treturn [...difference(array1, array2), ...difference(array2, array1)];\n\t};\n\n\t/**\n\t * @param {string} word\n\t * @returns {string}\n\t */\n\tconst capitalize = (word) => {\n\t\treturn word[0].toUpperCase() + word.slice(1).toLowerCase();\n\t};\n\n\t/**\n\t * @param {Array} array\n\t * @returns {Array}\n\t */\n\tconst cloneArray = (array) => {\n\t\tif (!Array.isArray(array)) {\n\t\t\tthrow new Error(\"cloneArray() argument must be an array\");\n\t\t}\n\n\t\treturn JSON.parse(JSON.stringify(array));\n\t};\n\n\t/**\n\t * @param {Object} object\n\t * @returns {Object}\n\t */\n\tconst cloneObject = (object) => {\n\t\tif (object === null) {\n\t\t\treturn null;\n\t\t}\n\n\t\tif (typeof object !== \"object\") {\n\t\t\tthrow new Error(\"cloneObject() argument must be an object\");\n\t\t}\n\n\t\treturn JSON.parse(JSON.stringify(object));\n\t};\n\n\t/**\n\t * @param {number} value\n\t * @param {number} from\n\t * @param {number} to\n\t */\n\tconst mapRange = (value, from, to) => {\n\t\treturn (value - from) / (to - from);\n\t};\n\n\t/**\n\t * @param {number} value\n\t * @param {number} from\n\t * @param {number} to\n\t * @param {number} newFrom\n\t * @param {number} newTo\n\t * @returns {number}\n\t */\n\tconst remapRange = (value, from, to, newFrom, newTo) => {\n\t\tconst ratio = mapRange(value, from, to);\n\t\treturn (newTo - newFrom) * ratio + newFrom;\n\t};\n\n\t/**\n\t * @returns {string}\n\t */\n\tconst randomBytes = (length = 32) => {\n\t\treturn require(\"crypto\")\n\t\t\t.randomBytes(length)\n\t\t\t.toString(\"hex\");\n\t};\n\n\t/**\n\t * @param {number} width\n\t * @param {number} height\n\t * @returns {number}\n\t */\n\tconst gcd = (width, height) => {\n\t\tif (width === 0 || height === 0) {\n\t\t\treturn 1;\n\t\t}\n\n\t\tconst lesser = Math.min(width, height);\n\t\tconst greater = Math.max(width, height);\n\t\tconst remainder = greater % lesser;\n\n\t\tif (remainder === 0) {\n\t\t\treturn lesser;\n\t\t}\n\t\telse {\n\t\t\treturn gcd(lesser, remainder);\n\t\t}\n\t};\n\n\t/**\n\t * @param {number} width\n\t * @param {number} height\n\t * @returns {string}\n\t */\n\tconst aspectRatio = (width, height) => {\n\t\tconst divisor = gcd(width, height);\n\t\tif (divisor === 0) {\n\t\t\treturn \"1:1\";\n\t\t}\n\n\t\treturn `${width / divisor}:${height / divisor}`;\n\t};\n\n\t/**\n\t * @param {string} string\n\t * @returns {string}\n\t */\n\tconst escapeRegExp = (string) => {\n\t\treturn string.replace(/[.*+?^${}()|[\\]\\\\]/g, \"\\\\$&\");\n\t};\n\n\t/**\n\t * @param {Array} array\n\t * @param {*} item\n\t * @returns {Array}\n\t */\n\tconst removeFromArray = (array, item) => {\n\t\tif (!Array.isArray(array)) {\n\t\t\tthrow new Error(\"removeFromArray() first argument must be an array\");\n\t\t}\n\n\t\tconst index = array.indexOf(item);\n\t\tif (index !== -1) {\n\t\t\tarray.splice(index, 1);\n\t\t}\n\n\t\treturn array;\n\t};\n\n\t/**\n\t * @param {string} string\n\t * @returns {string}\n\t */\n\tconst htmlEncode = (string) => {\n\t\treturn String(string)\n\t\t\t.replace(/&/g, \"&amp;\")\n\t\t\t.replace(/</g, \"&lt;\")\n\t\t\t.replace(/>/g, \"&gt;\")\n\t\t\t.replace(/'/g, \"&#39;\")\n\t\t\t.replace(/\"/g, \"&quot;\");\n\t};\n\n\tconst removeEmotesFromString = (string, emotes) => {\n\t\tfor (const emote of emotes) {\n\t\t\tconst regex = new RegExp(escapeRegExp(emote), \"g\");\n\t\t\tstring = string.replace(regex, \"\");\n\t\t}\n\n\t\tstring = string.replace(/\\s+/g, \" \").trim();\n\t\treturn string;\n\t};\n\n\t/**\n\t * For a given time object and a future date, returns the number of seconds between them.\n\t * @param {Date} targetDate\n\t * @returns {number}\n\t */\n\tconst getDelayUntilDate = (targetDate) => {\n\t\tif (!(targetDate instanceof Date)) {\n\t\t\tthrow new Error(\"Date must be a Date object\");\n\t\t}\n\n\t\tconst now = new Date();\n\t\tconst delta = targetDate.valueOf() - now.valueOf();\n\n\t\tif (delta < 0) {\n\t\t\treturn -1;\n\t\t}\n\t\telse {\n\t\t\treturn Math.ceil(delta / 1000);\n\t\t}\n\t};\n\n\t/**\n\t * For a given date object, returns the next occurrence of the date with the given hour and minute.\n\t * @param {Date} date\n\t * @param {number} hour\n\t * @param {number} minute\n\t * @param {number} second\n\t * @returns {Date}\n\t */\n\tconst getNextDailyTimestamp = (date, hour, minute, second = 0) => {\n\t\tconst result = new Date(date);\n\t\tresult.setHours(hour);\n\t\tresult.setMinutes(minute);\n\t\tresult.setSeconds(second);\n\t\tresult.setMilliseconds(0);\n\n\t\tif (result <= date) {\n\t\t\tresult.setDate(result.getDate() + 1);\n\t\t}\n\n\t\treturn result;\n\t};\n\n\t/**\n\t * @param {string} url\n\t * @returns {Promise<*>}\n\t */\n\tconst fetchData = async (url, options = {}) => {\n\t\tconst response = await fetch(url, options);\n\t\treturn await response.json();\n\t};\n\n\treturn {\n\t\tsleep,\n\t\ttypeCast,\n\t\tpromiseWithTimeout,\n\t\tpromiseWithFallback,\n\t\tfetchData,\n\t\tcloseenough,\n\t\tshuffleArray,\n\t\tgetRandomInt,\n\t\tstringSearch,\n\t\tfuzzyMatch,\n\t\tparseUserCommandArguments,\n\t\tgetByProperty,\n\t\tcombinedArrays,\n\t\tintersection,\n\t\tdifference,\n\t\tsymmetricDifference,\n\t\tcapitalize,\n\t\tcloneArray,\n\t\tcloneObject,\n\t\tremoveDuplicatesFromArrayByProperty,\n\t\tmapRange,\n\t\tremapRange,\n\t\trandomBytes,\n\t\tgcd,\n\t\taspectRatio,\n\t\tescapeRegExp,\n\t\tremoveFromArray,\n\t\thtmlEncode,\n\t\tremoveEmotesFromString,\n\t\tgetDelayUntilDate,\n\t\tgetNextDailyTimestamp\n\t};\n})();\n\u0005End File\u0006module.exports = (function(){\n\"use strict\";\n\nconst Alias = require(\"./alias.js\");\nconst Banphrase = require(\"./banphrase.js\");\nconst Channel = require(\"./channel.js\");\nconst ChannelGroup = require(\"./channel-group.js\");\nconst Command = require(\"./command.js\");\nconst Config = require(\"./config-schema.js\");\nconst ExternalInteraction = require(\"./external-interaction.js\");\nconst Filter = require(\"./filter.js\");\nconst Gachi = require(\"./gachi.js\");\nconst RemoteCommand = require(\"./remote-command.js\");\nconst User = require(\"./user.js\");\nconst UserAlias = require(\"./user-alias.js\");\nconst Reminder = require(\"./reminder.js\");\nconst Got = require(\"./got.js\");\nconst Log = require(\"./log.js\");\nconst Chat = require(\"./chat-module/index.js\");\nconst TemplateModule = require(\"./template-module.js\");\nconst Error = require(\"./error.js\");\nconst Timer = require(\"./timer.js\");\n\nconst fs = require(\"fs\");\nconst path = require(\"path\");\nconst Module = require(\"module\");\nconst importData = require(\"../import-data.js\");\nconst util = require(\"./util.js\");\nconst ModuleLogger = require(\"./module-logger.js\");\n\nclass CoreModule {\n\t/**\n\t * @param {string} name\n\t * @param {string} [basePath]\n\t */\n\tconstructor (name, basePath) {\n\t\tthis.platform = {\n\t\t\tname: \"node\"\n\t\t};\n\n\t\tthis.Name = name;\n\t\tthis.started = false;\n\t\tthis.destroyed = false;\n\t\tthis.restarting = false;\n\t\tthis.modules = {};\n\t\tthis.Data = importData;\n\t\tthis.basePath = basePath ?? process.cwd();\n\t\tthis.Logger = new ModuleLogger(name);\n\n\t\tthis.waitUntilInitialized = new Promise((resolve, reject) => {\n\t\t\tthis.resolveInitialization = resolve;\n\t\t\tthis.rejectInitialization = reject;\n\t\t});\n\t}\n\n\tasync initialize () {\n\t\ttry {\n\t\t\tthis.Logger.resolveLoadingEmitter();\n\n\t\t\tawait this.loadGlobalModules();\n\t\t\tawait this.loadChatModules();\n\n\t\t\tthis.resolveInitialization(true);\n\t\t}\n\t\tcatch (e) {\n\t\t\tthis.rejectInitialization(e);\n\t\t\tconsole.error(e);\n\t\t}\n\t}\n\n\t/**\n\t * Initializes a module instance.\n\t * @param {Object} ModuleClass\n\t * @param {string} [customName] If not provided, ModuleClass.name will be used\n\t * @returns {Promise<void>}\n\t */\n\tasync loadModule (ModuleClass, customName) {\n\t\tconst moduleName = customName ?? ModuleClass.name;\n\t\tconst moduleInstance = new ModuleClass(this);\n\n\t\tthis.modules[moduleName] = moduleInstance;\n\t\tif (typeof moduleInstance.initialize === \"function\") {\n\t\t\tawait moduleInstance.initialize();\n\t\t}\n\t}\n\n\tasync loadGlobalModules () {\n\t\tawait this.loadModule(Alias);\n\t\tawait this.loadModule(Banphrase);\n\t\tawait this.loadModule(Channel);\n\t\tawait this.loadModule(ChannelGroup);\n\t\tawait this.loadModule(Command);\n\t\tawait this.loadModule(Config);\n\t\tawait this.loadModule(ExternalInteraction);\n\t\tawait this.loadModule(Filter);\n\t\tawait this.loadModule(Gachi);\n\t\tawait this.loadModule(RemoteCommand);\n\t\tawait this.loadModule(User);\n\t\tawait this.loadModule(UserAlias);\n\t\tawait this.loadModule(Reminder);\n\t\tawait this.loadModule(Got);\n\t\tawait this.loadModule(Log);\n\t\tawait this.loadModule(Error);\n\t\tawait this.loadModule(Timer);\n\t}\n\n\tasync loadChatModules () {\n\t\ttry {\n\t\t\tawait this.loadModule(Chat);\n\t\t}\n\t\tcatch (e) {\n\t\t\tconsole.error(\"Chat module failed to initialize\", e);\n\t\t}\n\t}\n\n\t/**\n\t * @returns {Promise<Object>}\n\t */\n\tgetPluginModuleList () {\n\t\tconst pluginDirectories = [\n\t\t\tpath.join(this.basePath, \"plugins\"),\n\t\t\tpath.join(this.basePath, \"custom_modules\")\n\t\t];\n\n\t\t/**\n\t\t * @param {string} directory\n\t\t */\n\t\tconst loadModulesFromDirectory = async (directory) => {\n\t\t\tif (!fs.existsSync(directory)) {\n\t\t\t\treturn {};\n\t\t\t}\n\n\t\t\tconst modules = {};\n\t\t\tconst listing = fs.readdirSync(directory, { withFileTypes: true });\n\t\t\tconst moduleTypes = listing.filter(i => i.isDirectory());\n\n\t\t\tfor (const moduleDir of moduleTypes) {\n\t\t\t\tconst typeName = moduleDir.name;\n\t\t\t\tconst modulePath = path.join(directory, typeName);\n\t\t\t\tconst moduleFiles = fs.readdirSync(modulePath, { withFileTypes: true });\n\t\t\t\tconst moduleNames = moduleFiles\n\t\t\t\t\t.filter(i => i.isFile() && i.name.endsWith(\".js\") && !i.name.startsWith(\"_\"))\n\t\t\t\t\t.map(i => i.name.replace(/\\.js$/, \"\"));\n\n\t\t\t\tmodules[typeName] = {};\n\t\t\t\tfor (const moduleName of moduleNames) {\n\t\t\t\t\tconst moduleFilePath = path.join(modulePath, `${moduleName}.js`);\n\t\t\t\t\ttry {\n\t\t\t\t\t\tlet targetRequire = require;\n\t\t\t\t\t\t// If module is in the custom_modules directory, make it look for requires relative to the base path\n\t\t\t\t\t\tif (directory.includes(\"custom_modules\")) {\n\t\t\t\t\t\t\tconst modulePaths = Module._nodeModulePaths(this.basePath);\n\t\t\t\t\t\t\tconst parent = module.parent;\n\t\t\t\t\t\t\tconst fakeModule = new Module(moduleFilePath, parent);\n\t\t\t\t\t\t\tfakeModule.filename = moduleFilePath;\n\t\t\t\t\t\t\tfakeModule.paths = modulePaths;\n\t\t\t\t\t\t\ttargetRequire = fakeModule.require.bind(fakeModule);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tmodules[typeName][moduleName] = targetRequire(moduleFilePath);\n\t\t\t\t\t}\n\t\t\t\t\tcatch (e) {\n\t\t\t\t\t\tthis.Logger.error(`Failed to load module ${moduleName}`, e);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn modules;\n\t\t};\n\n\t\tconst allResults = {};\n\t\tconst promises = pluginDirectories.map(async (directory) => {\n\t\t\tconst result = await loadModulesFromDirectory(directory);\n\t\t\t// Merge the results into allResults\n\t\t\tfor (const [typeName, modules] of Object.entries(result)) {\n\t\t\t\tif (!allResults[typeName]) {\n\t\t\t\t\tallResults[typeName] = {};\n\t\t\t\t}\n\t\t\t\tfor (const [moduleName, module] of Object.entries(modules)) {\n\t\t\t\t\tallResults[typeName][moduleName] = module;\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\n\t\treturn Promise.all(promises).then(() => allResults);\n\t}\n\n\t/**\n\t * @param {string} moduleName\n\t * @returns {Promise<any>}\n\t */\n\tasync loadPluginModule (moduleName) {\n\t\ttry {\n\t\t\t// First, check if module exists in the base path\n\t\t\tconst moduleBasePath = path.join(this.basePath, \"plugins\", moduleName);\n\t\t\tlet moduleFile = null;\n\n\t\t\ttry {\n\t\t\t\tmoduleFile = require(moduleBasePath);\n\t\t\t}\n\t\t\tcatch (e) {\n\t\t\t\tif (e.code !== \"MODULE_NOT_FOUND\") {\n\t\t\t\t\tthrow e;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// If not found, try the custom_modules path\n\t\t\tif (!moduleFile) {\n\t\t\t\tconst customModulePath = path.join(this.basePath, \"custom_modules\", moduleName);\n\t\t\t\ttry {\n\t\t\t\t\tmoduleFile = require(customModulePath);\n\t\t\t\t}\n\t\t\t\tcatch (e) {\n\t\t\t\t\tif (e.code !== \"MODULE_NOT_FOUND\") {\n\t\t\t\t\t\tthrow e;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (!moduleFile) {\n\t\t\t\tthrow new Error(`Module ${moduleName} not found`);\n\t\t\t}\n\n\t\t\tawait this.loadModule(moduleFile, moduleName);\n\t\t\treturn this.modules[moduleName];\n\t\t}\n\t\tcatch (e) {\n\t\t\tconsole.error(`Failed to load plugin module ${moduleName}`, e);\n\t\t\tthrow e;\n\t\t}\n\t}\n\n\t// For compatibility with sb-utils\n\tasync send (type, message) {\n\t\tif (!this.started) {\n\t\t\treturn;\n\t\t}\n\n\t\t// @todo implement as needed\n\t\tconsole.log(\"send\", type, message);\n\t}\n\n\tdestroy () {\n\t\tthis.destroyed = true;\n\t\treturn true;\n\t}\n\n\trestart () {\n\t\tif (this.restarting) {\n\t\t\treturn false;\n\t\t}\n\n\t\tthis.restarting = true;\n\t\tsetTimeout(() => this.destroy(), 1000);\n\t\treturn true;\n\t}\n\n\t/**\n\t * @param {string} code\n\t * @returns {Promise<*>}\n\t */\n\tasync executeCode (code) {\n\t\tconst AsyncFunction = Object.getPrototypeOf(async function() {}).constructor;\n\t\tconst asyncFunction = new AsyncFunction(\n\t\t\t\"sb\",\n\t\t\t\"console\",\n\t\t\t\"utils\",\n\t\t\t\"setTimeout\",\n\t\t\t\"setInterval\",\n\t\t\t\"clearTimeout\",\n\t\t\t\"clearInterval\",\n\t\t\t\"require\",\n\t\t\t\"fetch\",\n\t\t\t\"process\",\n\t\t\t\"module\",\n\t\t\t\"__filename\",\n\t\t\t\"__dirname\",\n\t\t\tcode\n\t\t);\n\n\t\tconst logRecorder = {\n\t\t\tlogs: [],\n\t\t\terrors: [],\n\t\t\tinfo: function (...args) {\n\t\t\t\tthis.logs.push({\n\t\t\t\t\ttype: \"info\",\n\t\t\t\t\targs\n\t\t\t\t});\n\t\t\t\tconsole.info(...args);\n\t\t\t},\n\t\t\tlog: function (...args) {\n\t\t\t\tthis.logs.push({\n\t\t\t\t\ttype: \"log\",\n\t\t\t\t\targs\n\t\t\t\t});\n\t\t\t\tconsole.log(...args);\n\t\t\t},\n\t\t\twarn: function (...args) {\n\t\t\t\tthis.logs.push({\n\t\t\t\t\ttype: \"warn\",\n\t\t\t\t\targs\n\t\t\t\t});\n\t\t\t\tconsole.warn(...args);\n\t\t\t},\n\t\t\terror: function (...args) {\n\t\t\t\tthis.errors.push({\n\t\t\t\t\ttype: \"error\",\n\t\t\t\t\targs\n\t\t\t\t});\n\t\t\t\tconsole.error(...args);\n\t\t\t},\n\t\t\tdebug: function (...args) {\n\t\t\t\tthis.logs.push({\n\t\t\t\t\ttype: \"debug\",\n\t\t\t\t\targs\n\t\t\t\t});\n\t\t\t\tconsole.debug(...args);\n\t\t\t}\n\t\t};\n\n\t\ttry {\n\t\t\tconst result = await asyncFunction(\n\t\t\t\tthis,\n\t\t\t\tlogRecorder,\n\t\t\t\tutil,\n\t\t\t\tsetTimeout,\n\t\t\t\tsetInterval,\n\t\t\t\tclearTimeout,\n\t\t\t\tclearInterval,\n\t\t\t\trequire,\n\t\t\t\tfetch,\n\t\t\t\tprocess,\n\t\t\t\tmodule,\n\t\t\t\t__filename,\n\t\t\t\t__dirname\n\t\t\t);\n\n\t\t\tif (result !== undefined) {\n\t\t\t\tlogRecorder.log(result);\n\t\t\t}\n\n\t\t\treturn {\n\t\t\t\tsuccess: true,\n\t\t\t\tresult,\n\t\t\t\tlogs: logRecorder.logs,\n\t\t\t\terrors: logRecorder.errors\n\t\t\t};\n\t\t}\n\t\tcatch (error) {\n\t\t\treturn {\n\t\t\t\tsuccess: false,\n\t\t\t\terror,\n\t\t\t\tlogs: logRecorder.logs,\n\t\t\t\terrors: logRecorder.errors\n\t\t\t};\n\t\t}\n\t}\n\n\tget Alias () { return this.modules.Alias; }\n\tget Banphrase () { return this.modules.Banphrase; }\n\tget Channel () { return this.modules.Channel; }\n\tget ChannelGroup () { return this.modules.ChannelGroup; }\n\tget Command () { return this.modules.Command; }\n\tget Config () { return this.modules.Config; }\n\tget ExternalInteraction () { return this.modules.ExternalInteraction; }\n\tget Filter () { return this.modules.Filter; }\n\tget Gachi () { return this.modules.Gachi; }\n\tget RemoteCommand () { return this.modules.RemoteCommand; }\n\tget User () { return this.modules.User; }\n\tget UserAlias () { return this.modules.UserAlias; }\n\tget Reminder () { return this.modules.Reminder; }\n\tget Got () { return this.modules.Got; }\n\tget Log () { return this.modules.Log; }\n\tget Chat () { return this.modules.Chat; }\n\tget Error () { return this.modules.Error; }\n\tget Timer () { return this.modules.Timer; }\n\n\tget Template () { return TemplateModule; }\n\tget Utils () { return util; }\n\n\tget version () {\n\t\tconst pjson = path.join(this.basePath, \"package.json\");\n\t\treturn JSON.parse(fs.readFileSync(pjson, \"utf-8\")).version;\n\t}\n}\n\nmodule.exports = CoreModule;\nreturn module.exports;\n})();\n\u0005End File\u0006# Supinic/supibot\n# chat-module/manager.js\nmodule.exports = (function(){\n\"use strict\";\n\nconst User = require(\"../user.js\");\n\nmodule.exports = class ChatManager {\n\tconstructor (chat) {\n\t\tthis.Chat = chat;\n\t\tthis.managers = {};\n\t\tthis.ready = {};\n\t\tthis.lastChannelDelimiter = {};\n\t}\n\n\t/**\n\t * @returns {string[]}\n\t */\n\tget platforms () {\n\t\treturn Object.keys(this.managers);\n\t}\n\n\t/**\n\t * @param {Platform} Platform\n\t * @returns {Promise<Platform>}\n\t */\n\tasync add (Platform) {\n\t\tif (typeof Platform.loadDependency === \"function\") {\n\t\t\ttry {\n\t\t\t\tawait Platform.loadDependency();\n\t\t\t}\n\t\t\tcatch (e) {\n\t\t\t\tconsole.warn(`Skipping platform ${Platform.name} - missing dependencies: ${e.message}`);\n\t\t\t\treturn null;\n\t\t\t}\n\t\t}\n\n\t\t/**\n\t\t * @type {Platform}\n\t\t */\n\t\tconst instance = new Platform({\n\t\t\tchannelTemplate: this.Chat.sb.Channel,\n\t\t\tuserTemplate: this.Chat.sb.User\n\t\t});\n\n\t\tthis.managers[instance.platform] = instance;\n\t\tawait instance.initialize(this.Chat);\n\n\t\t// Only set the \"ready\" flag to true if initialize succeeds\n\t\tthis.ready[instance.platform] = true;\n\n\t\tif (instance.options.useChannelDelimiters === true) {\n\t\t\tthis.lastChannelDelimiter[instance.platform] = [null, null];\n\t\t}\n\n\t\treturn instance;\n\t}\n\n\t/**\n\t * @param {Platform} managerOrID\n\t */\n\tremove (managerOrID) {\n\t\tif (typeof managerOrID === \"object\") {\n\t\t\tif (!managerOrID.destroyed) {\n\t\t\t\tmanagerOrID.destroy();\n\t\t\t}\n\n\t\t\tconst platform = managerOrID.platform;\n\t\t\tdelete this.managers[platform];\n\t\t}\n\t\telse if (typeof managerOrID === \"string\") {\n\t\t\tconst manager = this.managers[managerOrID];\n\t\t\tif (!manager) {\n\t\t\t\tthrow new Error(`Chat manager \"${managerOrID}\" doesn't exist!`);\n\t\t\t}\n\n\t\t\tif (!manager.destroyed) {\n\t\t\t\tmanager.destroy();\n\t\t\t}\n\n\t\t\tdelete this.managers[managerOrID];\n\t\t}\n\t\telse {\n\t\t\tthrow new Error(\"Chat.remove() called without proper platform name or manager\");\n\t\t}\n\n\t\treturn true;\n\t}\n\n\t/**\n\t * @param {string} platform\n\t * @returns {Platform|null}\n\t */\n\tget (platform) {\n\t\treturn this.managers[platform] ?? null;\n\t}\n\n\t/**\n\t * @param {string} platform\n\t * @returns {boolean}\n\t */\n\thas (platform) {\n\t\treturn Boolean(this.managers[platform]);\n\t}\n\n\t/**\n\t * @param {Object} options\n\t * @param {string} options.message\n\t * @param {string} options.platform\n\t * @param {string} options.channel\n\t * @param {Object} [options.user]\n\t * @param {string} [options.user.ID]\n\t * @param {string} [options.user.Name]\n\t */\n\tasync send (options) {\n\t\tconst { platform, channel, message } = options;\n\n\t\tlet user = options.user;\n\t\tif (!user) {\n\t\t\tuser = await User.getByName(\"supibot\");\n\t\t}\n\t\telse if (typeof user === \"object\" && user !== null && !user.Name) {\n\t\t\tif (user.username) {\n\t\t\t\tuser.Name = user.username;\n\t\t\t}\n\t\t\telse if (user.name) {\n\t\t\t\tuser.Name = user.name;\n\t\t\t}\n\t\t}\n\n\t\tif (!platform) {\n\t\t\treturn {\n\t\t\t\tsuccess: false,\n\t\t\t\treply: \"No platform provided!\"\n\t\t\t};\n\t\t}\n\t\telse if (!this.managers[platform]) {\n\t\t\treturn {\n\t\t\t\tsuccess: false,\n\t\t\t\treply: \"Unrecognized platform provided!\"\n\t\t\t};\n\t\t}\n\t\telse if (!message) {\n\t\t\treturn {\n\t\t\t\tsuccess: false,\n\t\t\t\treply: \"No message provided!\"\n\t\t\t};\n\t\t}\n\t\telse if (!channel) {\n\t\t\treturn {\n\t\t\t\tsuccess: false,\n\t\t\t\treply: \"No channel provided!\"\n\t\t\t};\n\t\t}\n\n\t\treturn await this.managers[platform].send(message, channel, {\n\t\t\tuser\n\t\t});\n\t}\n\n\t/**\n\t * @param {string} channelData\n\t * @returns {Object}\n\t */\n\tparseChannelInvocation (channelData) {\n\t\tconst rest = channelData.match(/(?:(\\S+):)?(.+)/);\n\t\tif (!rest) {\n\t\t\treturn {\n\t\t\t\tplatform: null,\n\t\t\t\tchannel: null\n\t\t\t};\n\t\t}\n\n\t\tlet platform = rest[1];\n\t\tlet channel = rest[2];\n\n\t\tif (!platform) {\n\t\t\treturn {\n\t\t\t\tplatform: null,\n\t\t\t\tchannel\n\t\t\t};\n\t\t}\n\n\t\tif (!this.has(platform)) {\n\t\t\tconst existingID = channel;\n\t\t\tplatform = null;\n\t\t\tchannel = existingID;\n\t\t}\n\n\t\treturn {\n\t\t\tplatform: platform?.toLowerCase(),\n\t\t\tchannel\n\t\t};\n\t}\n\n\t/**\n\t * @param {string} messageData\n\t * @returns {{success: boolean, reason: string|null, invocation: Object|null}}\n\t */\n\tparseMessage (messageData) {\n\t\tif (!messageData) {\n\t\t\treturn {\n\t\t\t\tsuccess: false,\n\t\t\t\treason: \"No message data provided\",\n\t\t\t\tinvocation: null\n\t\t\t};\n\t\t}\n\n\t\tconst channelRegex = /(?:(\\S+)?(?:\\:))?([^$]+)?(?:\\$)/;\n\t\tconst channelMatch = messageData.match(channelRegex);\n\t\tif (!channelMatch) {\n\t\t\treturn {\n\t\t\t\tsuccess: false,\n\t\t\t\treason: \"Invalid format - missing channel data\",\n\t\t\t\tinvocation: null\n\t\t\t};\n\t\t}\n\n\t\tlet platform = channelMatch[1] ?? null;\n\t\tconst channelID = channelMatch[2]?.trim() ?? null;\n\n\t\t// Attempt to replace the platform if not provided, but the channel exists\n\t\tif (platform === null && channelID !== null) {\n\t\t\tconst dbChannelData = this.Chat.sb.Channel.get(channelID);\n\t\t\tif (dbChannelData && dbChannelData.Specific_ID) {\n\t\t\t\tplatform = dbChannelData.Platform.Name;\n\t\t\t}\n\t\t}\n\n\t\tif (platform === null) {\n\t\t\treturn {\n\t\t\t\tsuccess: false,\n\t\t\t\treason: \"No platform specified\",\n\t\t\t\tinvocation: null\n\t\t\t};\n\t\t}\n\t\telse if (!this.has(platform)) {\n\t\t\treturn {\n\t\t\t\tsuccess: false,\n\t\t\t\treason: \"Unrecognized platform\",\n\t\t\t\tinvocation: null\n\t\t\t};\n\t\t}\n\t\telse if (channelID === null) {\n\t\t\treturn {\n\t\t\t\tsuccess: false,\n\t\t\t\treason: \"No channel specified\",\n\t\t\t\tinvocation: null\n\t\t\t};\n\t\t}\n\n\t\tplatform = platform.toLowerCase();\n\t\tconst endOfChannelIndex = messageData.indexOf(\"$\") + 1;\n\t\tconst message = messageData.slice(endOfChannelIndex).trim();\n\n\t\tif (!message) {\n\t\t\treturn {\n\t\t\t\tsuccess: false,\n\t\t\t\treason: \"No message provided\",\n\t\t\t\tinvocation: null\n\t\t\t};\n\t\t}\n\n\t\tconst invocation = {\n\t\t\tmessage,\n\t\t\tplatform,\n\t\t\tchannel: channelID\n\t\t};\n\n\t\t// Memorize the last used channel delimiter for use in abbreviated syntax\n\t\tthis.lastChannelDelimiter[platform] = [platform, channelID];\n\n\t\treturn {\n\t\t\tsuccess: true,\n\t\t\treason: null,\n\t\t\tinvocation\n\t\t};\n\t}\n\n\t/**\n\t * @param {Object} options\n\t * @param {string} options.message\n\t * @param {Object} [options.executor = null]\n\t * @param {string} [options.platform = null]\n\t * @param {string} [options.channel = null]\n\t */\n\tasync parseAndSend (options) {\n\t\tif (!options.platform) {\n\t\t\t// If both platform and channel are null, use message data parsing\n\t\t\tif (!options.channel) {\n\t\t\t\t// Using an abbreviated syntax - no channel specifier, only the message\n\t\t\t\t// Relay to the last used channel if possible\n\t\t\t\tif (!options.message.includes(\"$\")) {\n\t\t\t\t\t// If no platform is provided but in options,\n\t\t\t\t\t// and the platform has a config option enabled for using delimiters\n\t\t\t\t\tif (this.lastChannelDelimiter[options.platform]) {\n\t\t\t\t\t\tconst platform = options.platform;\n\t\t\t\t\t\tconst delimiter = this.lastChannelDelimiter[platform];\n\t\t\t\t\t\tif (delimiter?.[0] && delimiter?.[1]) {\n\t\t\t\t\t\t\toptions.platform = delimiter[0];\n\t\t\t\t\t\t\toptions.channel = delimiter[1];\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\treturn {\n\t\t\t\t\t\t\t\tsuccess: false,\n\t\t\t\t\t\t\t\treply: `No last used channel delimiter is available for platform \"${platform}\"`\n\t\t\t\t\t\t\t};\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tconst values = Object.values(this.lastChannelDelimiter);\n\t\t\t\t\t\tif (values.length === 0) {\n\t\t\t\t\t\t\treturn {\n\t\t\t\t\t\t\t\tsuccess: false,\n\t\t\t\t\t\t\t\treply: \"No last used channel delimiter is available\"\n\t\t\t\t\t\t\t};\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if (values.length === 1) {\n\t\t\t\t\t\t\tif (values[0][0] && values[0][1]) {\n\t\t\t\t\t\t\t\toptions.platform = values[0][0];\n\t\t\t\t\t\t\t\toptions.channel = values[0][1];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\treturn {\n\t\t\t\t\t\t\t\t\tsuccess: false,\n\t\t\t\t\t\t\t\t\treply: \"No channel delimiter is available\"\n\t\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\treturn {\n\t\t\t\t\t\t\t\tsuccess: false,\n\t\t\t\t\t\t\t\treply: \"Multiple possible channel delimiters available - please specify one\"\n\t\t\t\t\t\t\t};\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t// Using a full syntax with channel specifier and message\n\t\t\t\telse {\n\t\t\t\t\tconst result = this.parseMessage(options.message);\n\t\t\t\t\tif (!result.success) {\n\t\t\t\t\t\treturn {\n\t\t\t\t\t\t\tsuccess: false,\n\t\t\t\t\t\t\treply: result.reason\n\t\t\t\t\t\t};\n\t\t\t\t\t}\n\n\t\t\t\t\toptions.platform = result.invocation.platform;\n\t\t\t\t\toptions.channel = result.invocation.channel;\n\t\t\t\t\toptions.message = result.invocation.message;\n\t\t\t\t}\n\t\t\t}\n\t\t\t// Using a mixed syntax with a channel specifier in options, but not platform\n\t\t\telse {\n\t\t\t\tconst result = this.parseChannelInvocation(options.channel);\n\t\t\t\tif (!result.platform) {\n\t\t\t\t\treturn {\n\t\t\t\t\t\tsuccess: false,\n\t\t\t\t\t\treply: \"No platform detected from channel name\"\n\t\t\t\t\t};\n\t\t\t\t}\n\n\t\t\t\toptions.platform = result.platform;\n\t\t\t\toptions.channel = result.channel;\n\t\t\t}\n\t\t}\n\t\t// Using a mixed syntax with a platform specifier in options, but not channel\n\t\telse if (!options.channel) {\n\t\t\treturn {\n\t\t\t\tsuccess: false,\n\t\t\t\treply: \"Channel must be provided if platform is provided\"\n\t\t\t};\n\t\t}\n\n\t\tif (!this.has(options.platform)) {\n\t\t\treturn {\n\t\t\t\tsuccess: false,\n\t\t\t\treply: \"Target platform does not exist\"\n\t\t\t};\n\t\t}\n\n\t\tconst platform = this.get(options.platform);\n\t\tif (!platform.controller) {\n\t\t\treturn {\n\t\t\t\tsuccess: false,\n\t\t\t\treply: \"Target platform has no active controller\"\n\t\t\t};\n\t\t}\n\n\t\t// Process banphrases if needed\n\t\tlet message = options.message;\n\t\tif (platform.options.shouldProcessBanphrases) {\n\t\t\tconst { string } = await this.Chat.sb.Banphrase.execute(\n\t\t\t\tmessage,\n\t\t\t\toptions.platform,\n\t\t\t\toptions.channel\n\t\t\t);\n\n\t\t\tmessage = string;\n\t\t}\n\n\t\tconst sendData = {\n\t\t\tchannel: options.channel,\n\t\t\tmessage,\n\t\t\tplatform: options.platform\n\t\t};\n\n\t\tif (options.executor) {\n\t\t\tsendData.user = options.executor;\n\t\t}\n\n\t\tconst result = await this.send(sendData);\n\t\treturn result;\n\t}\n};\n\nreturn module.exports;\n})();\n\u0005End File\u0006# singletons/query/index.js\nmodule.exports = (function () {\n\t\"use strict\";\n\n\t/**\n\t * Query Singleton module. Works as a wrapper for several API requests\n\t * @returns {{}}\n\t */\n\tconst Singleton = require(\"../singleton.js\");\n\tconst qs = require(\"querystring\");\n\tconst request = require(\"request\");\n\tconst { fetchAgent } = require(\"../../utils/request-utils.js\");\n\tconst crypto = require(\"crypto\");\n\tconst cache = new (require(\"../../utils/caches/memory.js\"))({ expirationTime: 300_000 });\n\n\tclass Query extends Singleton {\n\t\tconstructor () {\n\t\t\tsuper();\n\t\t\tthis.initialDelay = 1000;\n\t\t\tthis.retryLimit = 3;\n\t\t\tthis.trackFullErrors = false;\n\t\t\tthis.errors = {};\n\n\t\t\tthis.cache = {};\n\t\t\tthis.languages = {};\n\t\t}\n\n\t\t/**\n\t\t * Runs a request using a specific URL and a custom method.\n\t\t * @param {Object} obj\n\t\t * @param {string} obj.method HTTP method to use\n\t\t * @param {string} obj.url URL to access\n\t\t * @param {Object} [obj.headers] Additional headers to append\n\t\t * @param {string|Object} [obj.body] Body to send\n\t\t * @returns {Promise<Object>}\n\t\t */\n\t\tasync request (obj) {\n\t\t\tconst { method, url, headers = {}, body = null } = obj;\n\t\t\tlet { fullFilePath = null } = obj;\n\n\t\t\tif (fullFilePath) {\n\t\t\t\tif (typeof fullFilePath !== \"string\") {\n\t\t\t\t\tfullFilePath = fullFilePath.path;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (!method || !url) {\n\t\t\t\tthrow new Error(\"Missing HTTP method or URL!\");\n\t\t\t}\n\n\t\t\tlet success = false;\n\t\t\tlet response = null;\n\t\t\tlet attempts = 0;\n\t\t\tlet delay = this.initialDelay;\n\n\t\t\twhile (!success && attempts < this.retryLimit) {\n\t\t\t\ttry {\n\t\t\t\t\tattempts++;\n\n\t\t\t\t\tconst requestObject = {\n\t\t\t\t\t\tmethod,\n\t\t\t\t\t\theaders,\n\t\t\t\t\t\tbody\n\t\t\t\t\t};\n\n\t\t\t\t\tif (fullFilePath) {\n\t\t\t\t\t\tresponse = await new Promise((resolve, reject) => {\n\t\t\t\t\t\t\trequest({\n\t\t\t\t\t\t\t\t...requestObject,\n\t\t\t\t\t\t\t\turl\n\t\t\t\t\t\t\t}, (err, res, body) => {\n\t\t\t\t\t\t\t\tif (err) {\n\t\t\t\t\t\t\t\t\treject(err);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\t\t\tresolve({\n\t\t\t\t\t\t\t\t\t\t\tstatusCode: res.statusCode,\n\t\t\t\t\t\t\t\t\t\t\tbody: JSON.parse(body)\n\t\t\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tcatch (e) {\n\t\t\t\t\t\t\t\t\t\tresolve({\n\t\t\t\t\t\t\t\t\t\t\tstatusCode: res.statusCode,\n\t\t\t\t\t\t\t\t\t\t\tbody\n\t\t\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t})\n\t\t\t\t\t\t\t\t.pipe(require(\"fs\").createWriteStream(fullFilePath));\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tconst responseData = await fetch(url, requestObject);\n\t\t\t\t\t\tconst responseBody = await responseData.text();\n\n\t\t\t\t\t\tresponse = {\n\t\t\t\t\t\t\tstatusCode: responseData.status,\n\t\t\t\t\t\t\tbody: null\n\t\t\t\t\t\t};\n\n\t\t\t\t\t\t// Try parsing as JSON first\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tresponse.body = JSON.parse(responseBody);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcatch {\n\t\t\t\t\t\t\t// If it's not JSON, return the raw text\n\t\t\t\t\t\t\tresponse.body = responseBody;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif (response.statusCode >= 400) {\n\t\t\t\t\t\tthrow new Error(`HTTP ${response.statusCode}`);\n\t\t\t\t\t}\n\n\t\t\t\t\tsuccess = true;\n\t\t\t\t}\n\t\t\t\tcatch (e) {\n\t\t\t\t\t// If specific request attempt exceeds the limit, try again\n\t\t\t\t\tif (e?.code === \"ETIMEDOUT\" || e?.code === \"ESOCKETTIMEDOUT\") {\n\t\t\t\t\t\tdelay *= 2;\n\t\t\t\t\t\tconsole.warn(`Retrying request ${method}:${url}`, { attempt: attempts, error: e });\n\t\t\t\t\t\tawait sb.Utils.sleep(delay);\n\t\t\t\t\t}\n\t\t\t\t\t// If proper 404 or similar, fail right away\n\t\t\t\t\telse if (e instanceof Error && e.message.includes(\"HTTP\")) {\n\t\t\t\t\t\tattempts = Infinity;\n\t\t\t\t\t}\n\t\t\t\t\t// Otherwise, throw immediatelly\n\t\t\t\t\telse {\n\t\t\t\t\t\tattempts = Infinity;\n\t\t\t\t\t\tthrow e;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (!success) {\n\t\t\t\tthrow new Error(\"Request failed - too many attempts!\");\n\t\t\t}\n\n\t\t\treturn response;\n\t\t}\n\n\t\t/**\n\t\t * Fetches a URL via GET, and returns the result.\n\t\t * @param {string} URL\n\t\t * @param {Object} [options]\n\t\t * @param {boolean} [options.resolveWithStatusCode]\n\t\t * @param {Object} [options.headers]\n\t\t * @param {Object} [options.requestOptions]\n\t\t * @param {boolean} [options.throwOnError]\n\t\t * @returns {Promise<Object>}\n\t\t */\n\t\tasync getWebsiteData (URL, options = {}) {\n\t\t\tconst response = await fetchAgent({\n\t\t\t\turl: URL,\n\t\t\t\tresponseType: \"json\",\n\t\t\t\theaders: options.headers ?? {},\n\t\t\t\tthrowHttpErrors: options.throwOnError ?? true,\n\t\t\t\t...options.requestOptions\n\t\t\t});\n\n\t\t\tif (options.resolveWithStatusCode) {\n\t\t\t\treturn {\n\t\t\t\t\tstatusCode: response.statusCode,\n\t\t\t\t\tbody: response.body\n\t\t\t\t};\n\t\t\t}\n\t\t\telse {\n\t\t\t\treturn response.body;\n\t\t\t}\n\t\t}\n\n\t\t/**\n\t\t * Fetches a Paste.ee paste, and returns its data.\n\t\t * If authentication is required, you have to create `.pasteee-key` file in the root directory.\n\t\t * @param {string} id\n\t\t * @returns {Promise<Object>}\n\t\t */\n\t\tasync getPaste (id) {\n\t\t\tconst key = await sb.Utils.getPersistedData(\"pasteee-key\");\n\n\t\t\tconst response = await fetch(`https://api.paste.ee/v1/pastes/${id}`, {\n\t\t\t\theaders: {\n\t\t\t\t\t\"X-Auth-Token\": key\n\t\t\t\t}\n\t\t\t});\n\n\t\t\tconst data = await response.json();\n\t\t\tif (data.success !== true) {\n\t\t\t\tif (data.error) {\n\t\t\t\t\tthrow new Error(`Paste.ee error: ${data.error}`);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tthrow new Error(\"Paste.ee: no success response\");\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn data.paste;\n\t\t}\n\n\t\t/**\n\t\t * Checks if a YouTube API key has been provided via the configuration\n\t\t * @returns {boolean}\n\t\t */\n\t\tget youtubeKey () {\n\t\t\treturn Boolean(sb.Config && sb.Config.get(\"API_GOOGLE_YOUTUBE\"));\n\t\t}\n\n\t\t/**\n\t\t * Fetches a YT video's data using the Google Data API\n\t\t * @param {string} query\n\t\t * @returns {Promise<Object>}\n\t\t */\n\t\tasync fetchYoutubeVideo (query) {\n\t\t\t// Extract Video ID via regex\n\t\t\tconst regex = sb.Utils.linkParser.parseLink(query);\n\t\t\tif (!regex || regex.ID === null) {\n\t\t\t\tconst search = await this.fetchYoutubeSearchResults(query);\n\t\t\t\tif (search.items.length === 0) {\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\n\t\t\t\tconst videoID = search.items[0].id.videoId;\n\t\t\t\tif (videoID === null) {\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\n\t\t\t\tquery = videoID;\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// If non-YT query is provided, use the first result\n\t\t\t\tif (regex.type !== \"youtube\") {\n\t\t\t\t\tconst search = await this.fetchYoutubeSearchResults(query);\n\t\t\t\t\tif (search.items.length === 0) {\n\t\t\t\t\t\treturn null;\n\t\t\t\t\t}\n\n\t\t\t\t\tconst videoID = search.items[0].id.videoId;\n\t\t\t\t\tif (videoID === null) {\n\t\t\t\t\t\treturn null;\n\t\t\t\t\t}\n\n\t\t\t\t\tquery = videoID;\n\t\t\t\t}\n\t\t\t\t// If YT query is provided, just use its ID\n\t\t\t\telse {\n\t\t\t\t\tquery = regex.ID;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tconst videoData = await this.getVideoData(query);\n\t\t\tif (videoData === null) {\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\t// Normalize the data into our own format\n\t\t\treturn {\n\t\t\t\tID: query,\n\t\t\t\tname: videoData.items[0].snippet.title,\n\t\t\t\tviews: Number(videoData.items[0].statistics.viewCount),\n\t\t\t\tlikes: Number(videoData.items[0].statistics.likeCount ?? 0),\n\t\t\t\t// dislikes: Number(videoData.items[0].statistics.dislikeCount ?? 0),\n\t\t\t\tcomments: Number(videoData.items[0].statistics.commentCount),\n\t\t\t\tduration: videoData.items[0].contentDetails.duration,\n\t\t\t\trawLength: sb.Utils.parseISODuration(videoData.items[0].contentDetails.duration),\n\t\t\t\tauthor: videoData.items[0].snippet.channelTitle,\n\t\t\t\tauthorID: videoData.items[0].snippet.channelId,\n\t\t\t\tdescription: videoData.items[0].snippet.description,\n\t\t\t\tposted: new Date(videoData.items[0].snippet.publishedAt),\n\t\t\t\tthumbnails: videoData.items[0].snippet.thumbnails,\n\t\t\t\tisPrivate: Boolean(\n\t\t\t\t\tvideoData.items[0].status?.privacyStatus === \"private\" ||\n\t\t\t\t\tvideoData.items[0].snippet.liveBroadcastContent === \"upcoming\"\n\t\t\t\t),\n\t\t\t\tisUpcoming: Boolean(videoData.items[0].snippet.liveBroadcastContent === \"upcoming\"),\n\t\t\t\tisLive: Boolean(videoData.items[0].snippet.liveBroadcastContent === \"live\"),\n\t\t\t\tpremiereTimestamp: new Date(videoData.items[0].liveStreamingDetails?.scheduledStartTime ?? null)\n\t\t\t};\n\t\t}\n\n\t\t/**\n\t\t * Fetches a YT video's data, directly via its ID.\n\t\t * @param {string} ID\n\t\t * @param {Object} [options] = {}\n\t\t * @param {boolean} [options.ignoreCache] = false\n\t\t * @returns {Promise<Object|null>}\n\t\t */\n\t\tasync getVideoData (ID, options = {}) {\n\t\t\tconst key = sb.Config.get(\"API_GOOGLE_YOUTUBE\");\n\t\t\tconst cacheKey = `video-data-${ID}`;\n\n\t\t\tif (!options.ignoreCache) {\n\t\t\t\tconst cachedData = await cache.get(cacheKey);\n\t\t\t\tif (cachedData) {\n\t\t\t\t\treturn cachedData;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tconst params = new URLSearchParams({\n\t\t\t\tpart: \"snippet,contentDetails,statistics,liveStreamingDetails,status\",\n\t\t\t\tid: ID,\n\t\t\t\tkey: key\n\t\t\t});\n\n\t\t\tconst data = await fetch(`https://www.googleapis.com/youtube/v3/videos?${params.toString()}`);\n\t\t\tconst videoData = await data.json();\n\n\t\t\tif (!videoData) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\telse if (videoData.error) {\n\t\t\t\tconsole.warn(\"Youtube API error\", videoData.error.message, videoData.error.errors);\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\telse if (videoData.items.length === 0) {\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\tawait cache.set(cacheKey, videoData, 36e5);\n\t\t\treturn videoData;\n\t\t}\n\n\t\t/**\n\t\t * Fetches a channel's videos\n\t\t * @param channelID {string}\n\t\t * @param limit {number}\n\t\t * @param searchQuery {string}\n\t\t * @param type {string}\n\t\t * @returns {Promise<*>}\n\t\t */\n\t\tasync fetchChannelVideos (channelID, limit = 1, searchQuery, type = \"video\") {\n\t\t\tconst key = sb.Config.get(\"API_GOOGLE_YOUTUBE\");\n\n\t\t\tconst params = new URLSearchParams({\n\t\t\t\tkey,\n\t\t\t\tpart: \"id,snippet\",\n\t\t\t\tchannelId: channelID,\n\t\t\t\tmaxResults: limit\n\t\t\t});\n\n\t\t\tif (searchQuery) {\n\t\t\t\tparams.append(\"q\", searchQuery);\n\t\t\t\tparams.append(\"order\", \"relevance\");\n\t\t\t}\n\t\t\telse {\n\t\t\t\tparams.append(\"order\", \"date\");\n\t\t\t}\n\n\t\t\tif (type) {\n\t\t\t\tparams.append(\"type\", type);\n\t\t\t}\n\n\t\t\tconst data = await fetch(`https://www.googleapis.com/youtube/v3/search?${params.toString()}`);\n\t\t\tconst channelData = await data.json();\n\n\t\t\tif (!channelData) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\telse if (channelData.error) {\n\t\t\t\tconsole.warn(\"Youtube API error\", channelData.error);\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\telse if (channelData.items.length === 0) {\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\treturn channelData;\n\t\t}\n\n\t\t/**\n\t\t * Fetches a channel's details\n\t\t * @param {string} channelID\n\t\t * @returns {Promise<null|*>}\n\t\t */\n\t\tasync fetchChannelDetails (channelID) {\n\t\t\tconst key = sb.Config.get(\"API_GOOGLE_YOUTUBE\");\n\n\t\t\tconst params = new URLSearchParams({\n\t\t\t\tkey,\n\t\t\t\tpart: \"snippet,statistics\",\n\t\t\t\tid: channelID\n\t\t\t});\n\n\t\t\tconst data = await fetch(`https://www.googleapis.com/youtube/v3/channels?${params.toString()}`);\n\t\t\tconst channelData = await data.json();\n\n\t\t\tif (!channelData) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\telse if (channelData.error) {\n\t\t\t\tconsole.warn(\"Youtube API error\", channelData.error);\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\telse if (channelData.items.length === 0) {\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\treturn channelData;\n\t\t}\n\n\t\t/**\n\t\t * Fetches a list of YT search results\n\t\t * @param {string} query\n\t\t * @param {number} [limit]\n\t\t * @returns {Promise<Object>}\n\t\t */\n\t\tasync fetchYoutubeSearchResults (query, limit = 1) {\n\t\t\tconst key = sb.Config.get(\"API_GOOGLE_YOUTUBE\");\n\n\t\t\tconst params = new URLSearchParams({\n\t\t\t\tkey,\n\t\t\t\tq: query,\n\t\t\t\tpart: \"snippet\",\n\t\t\t\tmaxResults: limit,\n\t\t\t\tsafeSearch: \"none\",\n\t\t\t\ttype: \"video\"\n\t\t\t});\n\n\t\t\tconst data = await fetch(`https://www.googleapis.com/youtube/v3/search?${params.toString()}`);\n\t\t\tconst searchData = await data.json();\n\n\t\t\treturn searchData;\n\t\t}\n\n\t\t/**\n\t\t * Fetches a YT playlist's data via ID.\n\t\t * @param {string} playlistID\n\t\t * @returns {Promise<null|Object>}\n\t\t */\n\t\tasync getPlaylistData (playlistID) {\n\t\t\tconst key = sb.Config.get(\"API_GOOGLE_YOUTUBE\");\n\n\t\t\tconst params = new URLSearchParams({\n\t\t\t\tkey,\n\t\t\t\tplaylistId: playlistID,\n\t\t\t\tpart: \"snippet\",\n\t\t\t\tmaxResults: \"50\"\n\t\t\t});\n\n\t\t\tconst response = await fetch(`https://www.googleapis.com/youtube/v3/playlistItems?${params.toString()}`);\n\t\t\tconst playlistData = await response.json();\n\n\t\t\tif (!playlistData) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\telse if (playlistData.error) {\n\t\t\t\tconsole.warn(\"Youtube API error\", playlistData.error);\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\telse if (playlistData.items.length === 0) {\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\treturn playlistData;\n\t\t}\n\n\t\t/**\n\t\t * Fetches a YT video's chat data\n\t\t * @param {string} videoID\n\t\t * @param {string} [pageToken]\n\t\t * @returns {Promise<Object>}\n\t\t */\n\t\tasync fetchLiveChatMessages (videoID, pageToken) {\n\t\t\tif (!this.youtubeKey) {\n\t\t\t\treturn {\n\t\t\t\t\terror: \"No API key available!\"\n\t\t\t\t};\n\t\t\t}\n\n\t\t\t// Only check if a video exists, and use its active chat, if no page token was provided\n\t\t\tlet chatID = null;\n\t\t\tif (!pageToken) {\n\t\t\t\tconst videoData = await this.getVideoData(videoID);\n\n\t\t\t\tif (!videoData) {\n\t\t\t\t\treturn {\n\t\t\t\t\t\terror: \"No video data found!\"\n\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t\telse if (videoData.items.length === 0) {\n\t\t\t\t\treturn {\n\t\t\t\t\t\terror: \"Video does not exist!\"\n\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t\telse if (!videoData.items[0].snippet.liveBroadcastContent || videoData.items[0].snippet.liveBroadcastContent === \"none\") {\n\t\t\t\t\treturn {\n\t\t\t\t\t\terror: \"Video is not live!\"\n\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t\telse if (videoData.items[0].snippet.liveBroadcastContent === \"upcoming\") {\n\t\t\t\t\treturn {\n\t\t\t\t\t\terror: \"Broadcast is upcoming!\",\n\t\t\t\t\t\tscheduledTime: new Date(videoData.items[0].liveStreamingDetails.scheduledStartTime)\n\t\t\t\t\t};\n\t\t\t\t}\n\n\t\t\t\tchatID = videoData.items[0].liveStreamingDetails.activeLiveChatId;\n\t\t\t}\n\n\t\t\tconst key = sb.Config.get(\"API_GOOGLE_YOUTUBE\");\n\t\t\tconst params = new URLSearchParams({\n\t\t\t\tkey,\n\t\t\t\tliveChatId: chatID ?? \"(irrelevant)\",\n\t\t\t\tpart: \"id,snippet,authorDetails\",\n\t\t\t\tpageToken: pageToken ?? undefined\n\t\t\t});\n\n\t\t\ttry {\n\t\t\t\tconst data = await fetch(`https://www.googleapis.com/youtube/v3/liveChat/messages?${params.toString()}`);\n\t\t\t\tconst messageData = await data.json();\n\n\t\t\t\tif (messageData.error) {\n\t\t\t\t\treturn {\n\t\t\t\t\t\terror: messageData.error.message\n\t\t\t\t\t};\n\t\t\t\t}\n\n\t\t\t\treturn messageData;\n\t\t\t}\n\t\t\tcatch (e) {\n\t\t\t\tconsole.error(e);\n\t\t\t\treturn {\n\t\t\t\t\terror: e.message\n\t\t\t\t};\n\t\t\t}\n\t\t}\n\n\t\t/**\n\t\t * Fetches metadata about a Spotify song.\n\t\t * @param {string} endpoint\n\t\t * @param {string} ID\n\t\t * @param {Object} options = {}\n\t\t * @param {boolean} [options.ignoreCache] = false\n\t\t * @returns {Promise<null|Object>}\n\t\t */\n\t\tasync spotify (endpoint, ID, options = {}) {\n\t\t\tif (!endpoint || !ID) {\n\t\t\t\tthrow new Error(\"missing endpoint or ID\");\n\t\t\t}\n\n\t\t\t// fetch access token if necessary\n\t\t\tif (!sb.Config.loaded || (!this.spotify.token && !sb.Config.get(\"SPOTIFY_ENABLED\"))) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\telse if (!this.spotify.token) {\n\t\t\t\tconst tokenObject = await sb.Config.get(\"SPOTIFY_API_CREDENTIALS\");\n\t\t\t\tconst auth = Buffer.from(`${tokenObject.clientID}:${tokenObject.clientSecret}`).toString(\"base64\");\n\n\t\t\t\tconst response = await fetch(\"https://accounts.spotify.com/api/token\", {\n\t\t\t\t\tmethod: \"POST\",\n\t\t\t\t\theaders: {\n\t\t\t\t\t\tAuthorization: `Basic ${auth}`,\n\t\t\t\t\t\t\"Content-Type\": \"application/x-www-form-urlencoded\"\n\t\t\t\t\t},\n\t\t\t\t\tbody: new URLSearchParams({\n\t\t\t\t\t\tgrant_type: \"client_credentials\"\n\t\t\t\t\t})\n\t\t\t\t});\n\n\t\t\t\tconst tokenData = await response.json();\n\n\t\t\t\tthis.spotify.token = tokenData.access_token;\n\t\t\t\tthis.spotify.expiry = new Date(Date.now() + (tokenData.expires_in * 1000));\n\t\t\t}\n\t\t\telse if (this.spotify.expiry <= new Date()) {\n\t\t\t\tthis.spotify.token = null;\n\t\t\t\tthis.spotify.expiry = null;\n\t\t\t\treturn await this.spotify(endpoint, ID);\n\t\t\t}\n\n\t\t\t// query data\n\t\t\tconst cacheKey = `spotify-${endpoint}-${ID}`;\n\t\t\tif (!options.ignoreCache) {\n\t\t\t\tconst cached = await cache.get(cacheKey);\n\t\t\t\tif (cached) {\n\t\t\t\t\treturn cached;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tconst response = await fetch(`https://api.spotify.com/v1/${endpoint}/${ID}`, {\n\t\t\t\theaders: {\n\t\t\t\t\tAuthorization: `Bearer ${this.spotify.token}`\n\t\t\t\t}\n\t\t\t});\n\n\t\t\tconst data = await response.json();\n\t\t\tif (!data || data.error) {\n\t\t\t\tif (data?.error?.status === 401 && data.error.message === \"The access token expired\") {\n\t\t\t\t\tthis.spotify.token = null;\n\t\t\t\t\tthis.spotify.expiry = null;\n\t\t\t\t\treturn await this.spotify(endpoint, ID);\n\t\t\t\t}\n\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\tawait cache.set(cacheKey, data, {\n\t\t\t\texpiry: 36e5\n\t\t\t});\n\n\t\t\treturn data;\n\t\t}\n\n\t\t/**\n\t\t * Fetches metadata about a Vimeo video\n\t\t * @param {string} ID\n\t\t * @returns {Promise<Object>}\n\t\t */\n\t\tasync vimeo (ID) {\n\t\t\treturn await fetchAgent({\n\t\t\t\turl: `https://vimeo.com/api/v2/video/${ID}.json`,\n\t\t\t\tresponseType: \"json\"\n\t\t\t}).then(i => i.body[0]);\n\t\t}\n\n\t\t/**\n\t\t * Translates from one language to another via Libre Translate.\n\t\t * @param {string} from Source language\n\t\t * @param {string} to Target language\n\t\t * @param {string} text Text to be translated\n\t\t * @param {Object} options\n\t\t * @returns {Promise<Object>}\n\t\t */\n\t\tasync libretranslate (from, to, text, options = {}) {\n\t\t\tif (!from || !to || !text) {\n\t\t\t\treturn {\n\t\t\t\t\tsuccess: false,\n\t\t\t\t\terror: \"Missing source or destination language, or the text itself\"\n\t\t\t\t};\n\t\t\t}\n\n\t\t\tif (typeof this.languages?.libretranslate !== \"object\") {\n\t\t\t\tthis.languages.libretranslate = new Map();\n\t\t\t}\n\n\t\t\tif (this.languages.libretranslate.size === 0) {\n\t\t\t\tconst { body } = await fetchAgent({\n\t\t\t\t\turl: \"https://libretranslate.de/languages\",\n\t\t\t\t\tresponseType: \"json\"\n\t\t\t\t});\n\n\t\t\t\tfor (const language of body) {\n\t\t\t\t\tthis.languages.libretranslate.set(language.code, language.name);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfrom = from.toLowerCase();\n\t\t\tto = to.toLowerCase();\n\n\t\t\tif (!this.languages.libretranslate.has(from)) {\n\t\t\t\treturn {\n\t\t\t\t\tsuccess: false,\n\t\t\t\t\treply: `Source language code \"$(from)\" was not recognized! Try one of the following: ${[...this.languages.libretranslate.keys()].join(\", \")}`,\n\t\t\t\t\tdata: {\n\t\t\t\t\t\tfrom,\n\t\t\t\t\t\tto,\n\t\t\t\t\t\ttext,\n\t\t\t\t\t\tlanguages: [...this.languages.libretranslate.keys()]\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t}\n\n\t\t\tif (!this.languages.libretranslate.has(to)) {\n\t\t\t\treturn {\n\t\t\t\t\tsuccess: false,\n\t\t\t\t\treply: `Target language code \"$(to)\" was not recognized! Try one of the following: ${[...this.languages.libretranslate.keys()].join(\", \")}`,\n\t\t\t\t\tdata: {\n\t\t\t\t\t\tfrom,\n\t\t\t\t\t\tto,\n\t\t\t\t\t\ttext,\n\t\t\t\t\t\tlanguages: [...this.languages.libretranslate.keys()]\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t}\n\n\t\t\tconst response = await fetchAgent({\n\t\t\t\turl: \"https://libretranslate.de/translate\",\n\t\t\t\tmethod: \"POST\",\n\t\t\t\theaders: { \"Content-Type\": \"application/json\" },\n\t\t\t\tresponseType: \"json\",\n\t\t\t\tjson: {\n\t\t\t\t\tq: text,\n\t\t\t\t\tsource: from,\n\t\t\t\t\ttarget: to,\n\t\t\t\t\tformat: \"text\"\n\t\t\t\t}\n\t\t\t});\n\n\t\t\tif (response.statusCode !== 200) {\n\t\t\t\treturn {\n\t\t\t\t\tsuccess: false,\n\t\t\t\t\terror: `Translation failed: Error ${response.statusCode}`\n\t\t\t\t};\n\t\t\t}\n\n\t\t\tconst { body } = response;\n\t\t\tif (!body.translatedText) {\n\t\t\t\treturn {\n\t\t\t\t\tsuccess: false,\n\t\t\t\t\terror: \"Could not translate!\"\n\t\t\t\t};\n\t\t\t}\n\n\t\t\tconst languageFrom = this.languages.libretranslate.get(from);\n\t\t\tconst languageTo = this.languages.libretranslate.get(to);\n\n\t\t\tif (options.detectLanguage) {\n\t\t\t\treturn {\n\t\t\t\t\tsuccess: true,\n\t\t\t\t\tlanguageFrom,\n\t\t\t\t\tlanguageTo,\n\t\t\t\t\toriginalText: text,\n\t\t\t\t\ttranslatedText: body.translatedText\n\t\t\t\t};\n\t\t\t}\n\n\t\t\treturn {\n\t\t\t\tsuccess: true,\n\t\t\t\tlanguageFrom,\n\t\t\t\tlanguageTo,\n\t\t\t\toriginalText: text,\n\t\t\t\ttranslatedText: body.translatedText\n\t\t\t};\n\t\t}\n\n\t\t/**\n\t\t * Translates from one language to another via Google Translate, or similar service\n\t\t * Defaults to translate.argosopentech.com\n\t\t * @param {string} from Source language\n\t\t * @param {string} to Target language\n\t\t * @param {string} text Text to be translated\n\t\t * @param {Object} options\n\t\t * @returns {Promise<Object>}\n\t\t */\n\t\tasync translate (from, to, text, options = {}) {\n\t\t\ttry {\n\t\t\t\tconst result = await this.libretranslate(from, to, text, options);\n\t\t\t\treturn result;\n\t\t\t}\n\t\t\tcatch (e) {\n\t\t\t\tconsole.warn(\"Libretranslate error\", e);\n\t\t\t\treturn {\n\t\t\t\t\tsuccess: false,\n\t\t\t\t\terror: e.message\n\t\t\t\t};\n\t\t\t}\n\t\t}\n\n\t\t/**\n\t\t * Translates text between languages. It automatically tries to resolve the source language before translating.\n\t\t * @param {string} to Target language\n\t\t * @param {string} text Text to be translated\n\t\t * @returns {Promise<Object>}\n\t\t */\n\t\tasync detectAndTranslate (to, text) {\n\t\t\treturn this.translate(\"auto\", to, text, {\n\t\t\t\tdetectLanguage: true\n\t\t\t});\n\t\t}\n\n\t\t/**\n\t\t * Detects language from text via translation API\n\t\t * @param {string} text Text to detect language from\n\t\t * @returns {Promise<Object>}\n\t\t */\n\t\tasync detectLanguage (text) {\n\t\t\ttry {\n\t\t\t\tconst result = await this.translate(\"auto\", \"en\", text, {\n\t\t\t\t\tdetectLanguage: true\n\t\t\t\t});\n\n\t\t\t\treturn {\n\t\t\t\t\tsuccess: true,\n\t\t\t\t\tlanguage: result.languageFrom\n\t\t\t\t};\n\t\t\t}\n\t\t\tcatch (e) {\n\t\t\t\treturn {\n\t\t\t\t\tsuccess: false,\n\t\t\t\t\tcause: e\n\t\t\t\t};\n\t\t\t}\n\t\t}\n\n\t\t/**\n\t\t * Handles URL requests that need to be proxied behind the Supinic API\n\t\t * @param {string} type\n\t\t * @param {string|Object} input\n\t\t * @returns {Promise<*>}\n\t\t */\n\t\tasync handleProxiedRequest (type, input) {\n\t\t\tlet endpoint = \"\";\n\t\t\tlet payload = \"\";\n\n\t\t\tif (type === \"proxy\") {\n\t\t\t\tif (typeof input !== \"string\") {\n\t\t\t\t\tthrow new Error(\"Input must be a string for proxy requests\");\n\t\t\t\t}\n\n\t\t\t\tconst result = await fetch(input);\n\t\t\t\treturn await result.text();\n\t\t\t}\n\t\t\telse if (type === \"youtube-dl\") {\n\t\t\t\tif (typeof input !== \"string\") {\n\t\t\t\t\tthrow new Error(\"Input must be a string for youtube-dl requests\");\n\t\t\t\t}\n\n\t\t\t\tendpoint = \"https://supinic.com/api/bot/proxy/youtube-dl\";\n\t\t\t\tpayload = input;\n\t\t\t}\n\t\t\telse if (type === \"tiktok\") {\n\t\t\t\tif (typeof input !== \"string\") {\n\t\t\t\t\tthrow new Error(\"Input must be a string for tiktok requests\");\n\t\t\t\t}\n\n\t\t\t\tendpoint = \"https://supinic.com/api/bot/proxy/tiktok\";\n\t\t\t\tpayload = input;\n\t\t\t}\n\t\t\telse if (type === \"jisho\") {\n\t\t\t\tif (typeof input !== \"string\") {\n\t\t\t\t\tthrow new Error(\"Input must be a string for jisho requests\");\n\t\t\t\t}\n\n\t\t\t\tendpoint = \"https://supinic.com/api/bot/proxy/jisho\";\n\t\t\t\tpayload = input;\n\t\t\t}\n\n\t\t\tif (!endpoint) {\n\t\t\t\tthrow new Error(\"Unknown proxy type\");\n\t\t\t}\n\n\t\t\tconst auth = await sb.Utils.getPersistedData(\"supinic-api\", { scope: \"bot\" });\n\t\t\tif (!auth) {\n\t\t\t\tthrow new Error(\"No Supinic.com API key found\");\n\t\t\t}\n\n\t\t\tconst response = await fetch(endpoint, {\n\t\t\t\tmethod: \"POST\",\n\t\t\t\theaders: {\n\t\t\t\t\t\"Content-Type\": \"application/json\",\n\t\t\t\t\tAuthorization: `Basic ${auth.userKey}:${auth.appKey}`\n\t\t\t\t},\n\t\t\t\tbody: JSON.stringify({ url: payload })\n\t\t\t});\n\n\t\t\treturn await response.json();\n\t\t}\n\n\t\t/**\n\t\t * Calculates temperature conversion automatically\n\t\t * @param {string|number} number\n\t\t * @param {string} [sourceUnit]\n\t\t * @returns {Promise<Object>}\n\t\t */\n\t\tasync temperature (number, sourceUnit) {\n\t\t\tlet value = Number(number);\n\t\t\tif (!Number.isFinite(value)) {\n\t\t\t\tthrow new Error(\"Invalid input for temperature conversion\");\n\t\t\t}\n\n\t\t\tif (sourceUnit) {\n\t\t\t\tif (sourceUnit === \"C\") {\n\t\t\t\t\t// no need to convert\n\t\t\t\t}\n\t\t\t\telse if (sourceUnit === \"F\") {\n\t\t\t\t\tvalue = (value - 32) * (5 / 9);\n\t\t\t\t}\n\t\t\t\telse if (sourceUnit === \"K\") {\n\t\t\t\t\tvalue -= 273.15;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tthrow new Error(\"Invalid source unit for temperature conversion\");\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn {\n\t\t\t\tC: value,\n\t\t\t\tF: value * (9 / 5) + 32,\n\t\t\t\tK: value + 273.15\n\t\t\t};\n\t\t}\n\n\t\t/**\n\t\t * Fetches a random fact.\n\t\t * @returns {Promise<string>}\n\t\t */\n\t\tasync randomFact () {\n\t\t\tconst data = await fetchAgent({\n\t\t\t\turl: \"https://uselessfacts.jsph.pl/random.json?language=en\",\n\t\t\t\tresponseType: \"json\"\n\t\t\t});\n\n\t\t\treturn data.body.text;\n\t\t}\n\n\t\t/**\n\t\t * Fetches a random cat image.\n\t\t * @returns {Promise<Object>}\n\t\t */\n\t\tasync randomCat () {\n\t\t\tconst data = await fetchAgent({\n\t\t\t\turl: \"https://api.thecatapi.com/v1/images/search\",\n\t\t\t\tresponseType: \"json\"\n\t\t\t});\n\n\t\t\treturn data.body[0];\n\t\t}\n\n\t\t/**\n\t\t * Fetches a random cat image.\n\t\t * @returns {Promise<Object>}\n\t\t */\n\t\tasync randomDog () {\n\t\t\tconst data = await fetchAgent({\n\t\t\t\turl: \"https://api.thedogapi.com/v1/images/search\",\n\t\t\t\tresponseType: \"json\"\n\t\t\t});\n\n\t\t\treturn data.body[0];\n\t\t}\n\n\t\t/**\n\t\t * Fetches a random cat fact.\n\t\t * @returns {Promise<string>}\n\t\t */\n\t\tasync randomCatFact () {\n\t\t\tconst data = await fetchAgent({\n\t\t\t\turl: \"https://meowfacts.herokuapp.com\",\n\t\t\t\tresponseType: \"json\"\n\t\t\t});\n\n\t\t\treturn data.body.data[0];\n\t\t}\n\n\t\t/**\n\t\t * Fetches a random dog fact.\n\t\t * @returns {Promise<string>}\n\t\t */\n\t\tasync randomDogFact () {\n\t\t\tconst data = await fetchAgent({\n\t\t\t\turl: \"https://dogapi.dog/api/v2/facts\",\n\t\t\t\tresponseType: \"json\"\n\t\t\t});\n\n\t\t\treturn data.body.data[0].attributes.body;\n\t\t}\n\n\t\t/**\n\t\t * Fetches a random joke.\n\t\t * @returns {Promise<Object>}\n\t\t */\n\t\tasync randomJoke () {\n\t\t\tconst data = await fetchAgent({\n\t\t\t\turl: \"https://official-joke-api.appspot.com/random_joke\",\n\t\t\t\tresponseType: \"json\"\n\t\t\t});\n\n\t\t\treturn data.body;\n\t\t}\n\n\t\t/**\n\t\t * Fetches a random Chuck Norris joke.\n\t\t * @returns {Promise<Object>}\n\t\t */\n\t\tasync randomChuckNorrisJoke () {\n\t\t\tconst data = await fetchAgent({\n\t\t\t\turl: \"https://api.chucknorris.io/jokes/random\",\n\t\t\t\tresponseType: \"json\"\n\t\t\t});\n\n\t\t\treturn {\n\t\t\t\tid: data.body.id,\n\t\t\t\tjoke: data.body.value,\n\t\t\t\tcategories: data.body.categories\n\t\t\t};\n\t\t}\n\n\t\t/**\n\t\t * Fetches a random advice.\n\t\t * @returns {Promise<string>}\n\t\t */\n\t\tasync randomAdvice () {\n\t\t\tconst data = await fetchAgent({\n\t\t\t\turl: \"https://api.adviceslip.com/advice\",\n\t\t\t\tresponseType: \"text\"\n\t\t\t});\n\n\t\t\treturn JSON.parse(data.body).slip.advice;\n\t\t}\n\n\t\t/**\n\t\t * Fetches a random \"on this day\" fact.\n\t\t * @returns {Promise<Object>}\n\t\t */\n\t\tasync randomTodayInHistory () {\n\t\t\tconst date = new Date();\n\t\t\tconst month = date.getMonth() + 1;\n\t\t\tconst day = date.getDate();\n\n\t\t\tconst data = await fetchAgent({\n\t\t\t\turl: `https://byabbe.se/on-this-day/${month}/${day}/events.json`,\n\t\t\t\tresponseType: \"json\"\n\t\t\t});\n\n\t\t\tconst randomIndex = Math.floor(Math.random() * data.body.events.length);\n\t\t\treturn data.body.events[randomIndex];\n\t\t}\n\n\t\t/**\n\t\t * Fetches a random quote.\n\t\t * @returns {Promise<Object>}\n\t\t */\n\t\tasync randomQuote () {\n\t\t\tconst data = await fetchAgent({\n\t\t\t\turl: \"https://api.quotable.io/random\",\n\t\t\t\tresponseType: \"json\"\n\t\t\t});\n\n\t\t\treturn {\n\t\t\t\tid: data.body._id,\n\t\t\t\tquote: data.body.content,\n\t\t\t\tauthor: data.body.author,\n\t\t\t\ttags: data.body.tags\n\t\t\t};\n\t\t}\n\n\t\t/**\n\t\t * Fetches a random Dad joke\n\t\t * @returns {Promise<string>}\n\t\t */\n\t\tasync randomDadJoke () {\n\t\t\tconst { body } = await fetchAgent({\n\t\t\t\turl: \"https://icanhazdadjoke.com/\",\n\t\t\t\theaders: {\n\t\t\t\t\tAccept: \"application/json\"\n\t\t\t\t},\n\t\t\t\tresponseType: \"json\"\n\t\t\t});\n\n\t\t\treturn body.joke;\n\t\t}\n\n\t\t/**\n\t\t * Fetches a random affirmation\n\t\t * @returns {Promise<string>}\n\t\t */\n\t\tasync randomAffirmation () {\n\t\t\tconst { body } = await fetchAgent({\n\t\t\t\turl: \"https://www.affirmations.dev/\",\n\t\t\t\tresponseType: \"json\"\n\t\t\t});\n\n\t\t\treturn body.affirmation;\n\t\t}\n\n\t\t/**\n\t\t * Retrieves details about a specific game from IGDB\n\t\t * @param {string} gameName\n\t\t * @returns {Promise<Object>}\n\t\t */\n\t\tasync getIGDBGame (gameName) {\n\t\t\tconst twitchAuth = await sb.Config.get(\"TWITCH_CLIENT_CREDENTIALS\");\n\t\t\tif (!twitchAuth || !twitchAuth.accessToken) {\n\t\t\t\tthrow new Error(\"No Twitch client credentials available!\");\n\t\t\t}\n\n\t\t\t// Prefer cache access\n\t\t\tconst cacheKey = `igdb-game-${crypto.createHash(\"md5\").update(gameName).digest(\"hex\")}`;\n\t\t\tconst cacheData = await cache.get(cacheKey);\n\t\t\tif (cacheData) {\n\t\t\t\treturn cacheData;\n\t\t\t}\n\n\t\t\tconst response = await fetch(\"https://api.igdb.com/v4/games\", {\n\t\t\t\tmethod: \"POST\",\n\t\t\t\theaders: {\n\t\t\t\t\tAccept: \"application/json\",\n\t\t\t\t\t\"Client-ID\": twitchAuth.clientID,\n\t\t\t\t\tAuthorization: `Bearer ${twitchAuth.accessToken}`\n\t\t\t\t},\n\t\t\t\tbody: `search \"${gameName}\"; fields name,first_release_date,aggregated_rating,rating,summary,url; limit 1;`\n\t\t\t});\n\n\t\t\tconst data = await response.json();\n\t\t\tif (!data || data.length === 0) {\n\t\t\t\tthrow new Error(\"No game found\");\n\t\t\t}\n\n\t\t\tawait cache.set(cacheKey, data[0], {\n\t\t\t\texpiry: 24 * 60 * 60 * 1000 // 24 hours\n\t\t\t});\n\n\t\t\treturn data[0];\n\t\t}\n\n\t\t/**\n\t\t * Fetches the history of recode.\n\t\t * @param {string|null} [date]\n\t\t * @returns {Promise<Object>}\n\t\t */\n\t\tasync recode (date = null) {\n\t\t\tconst endpoint = (date === null)\n\t\t\t\t? \"https://recode.warthunder.com/api/calendar\"\n\t\t\t\t: `https://recode.warthunder.com/api/calendar/${date}`;\n\n\t\t\tconst response = await fetch(endpoint);\n\t\t\treturn await response.json();\n\t\t}\n\n\t\t/**\n\t\t * Initialize - creates unimplemented methods\n\t\t */\n\t\tstatic async initialize () {\n\t\t\treturn new Promise((resolve) => {\n\t\t\t\tif (!sb.Config) {\n\t\t\t\t\tconsole.warn(\"sb.Config module is not available!\");\n\t\t\t\t}\n\n\t\t\t\tthis.module = new Query();\n\t\t\t\tthis.module.cache = { /* Should this exist? */ };\n\t\t\t\tthis.module.languages = { /* Should be filled if needed */ };\n\t\t\t\tthis.module.spotify = { /* Should be filled if needed */ };\n\n\t\t\t\tresolve();\n\t\t\t});\n\t\t}\n\n\t\t/**\n\t\t * Handles client error - adds to counter\n\t\t * @param {Error} error\n\t\t * @param {string} type\n\t\t */\n\t\tstatic addError (error, type) {\n\t\t\tthis.module.errors[type] = this.module.errors[type] ?? 0;\n\t\t\tthis.module.errors[type]++;\n\n\t\t\tif (this.module.trackFullErrors) {\n\t\t\t\tthis.module.fullErrors = this.module.fullErrors ?? [];\n\t\t\t\tthis.module.fullErrors.push({\n\t\t\t\t\ttype,\n\t\t\t\t\terror,\n\t\t\t\t\ttimestamp: new Date()\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\n\t\t/**\n\t\t * Destroys the module\n\t\t */\n\t\tstatic destroy () {\n\t\t\tthis.module = null;\n\t\t}\n\t}\n\n\treturn Query;\n})();\n\u0005End File\u0006module.exports = (function () {\n\t\"use strict\";\n\n\tconst { WebhookClient } = require(\"discord.js\");\n\n\tconst CustomError = require(\"../../objects/error.js\");\n\tconst Singleton = require(\"../singleton.js\");\n\tconst TriggerEventManager = require(\"./event-manager.js\");\n\n\tclass TriggerController extends Singleton {\n\t\tconstructor () {\n\t\t\tsuper();\n\n\t\t\tthis.logging = {\n\t\t\t\tdiscord: null,\n\t\t\t\t// events: false\n\t\t\t};\n\n\t\t\tthis.eventManager = new TriggerEventManager();\n\t\t}\n\n\t\t/**\n\t\t * Sets up the ability of Discord error logging\n\t\t * @param {Object} config\n\t\t * @returns {Promise<void>}\n\t\t */\n\t\tasync setupDiscordLogging (config) {\n\t\t\tif (!config || !config.ID || !config.token) {\n\t\t\t\tthrow new CustomError({\n\t\t\t\t\tmessage: \"Discord webhook configuration must exist and have an ID and token\"\n\t\t\t\t});\n\t\t\t}\n\n\t\t\tthis.logging.discord = new WebhookClient({\n\t\t\t\tid: config.ID,\n\t\t\t\ttoken: config.token\n\t\t\t});\n\t\t}\n\n\t\t/**\n\t\t * Handles a Discord error log\n\t\t * @param {Error|Object} error\n\t\t * @param {Object} [options] = {}\n\t\t * @param {string} [options.type] \"error\" || \"warning\" || \"information\"\n\t\t * @param {Object} [options.userID]\n\t\t * @param {string} [options.description]\n\t\t * @returns {Promise<boolean>}\n\t\t */\n\t\tasync handleErrorLog (error, options = {}) {\n\t\t\tif (!this.logging.discord) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\tconst isObject = (error && typeof error === \"object\");\n\t\t\tif (!isObject) {\n\t\t\t\tconsole.warn(\"Trigger error log is not an object\", { error });\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\tlet color = null;\n\t\t\tif (!options.type || options.type === \"error\") {\n\t\t\t\tcolor = 15073281; // red\n\t\t\t}\n\t\t\telse if (options.type === \"warning\") {\n\t\t\t\tcolor = 15050468; // yellow\n\t\t\t}\n\t\t\telse if (options.type === \"information\") {\n\t\t\t\tcolor = 5614830; // green\n\t\t\t}\n\n\t\t\tconst embed = {\n\t\t\t\tcolor,\n\t\t\t\ttitle: error.message ?? error.name ?? \"(no message provided)\",\n\t\t\t\tdescription: options.description ?? error.description ?? error.stack ?? \"(no description provided)\",\n\t\t\t\ttimestamp: new Date().toISOString(),\n\t\t\t\tfooter: {}\n\t\t\t};\n\n\t\t\tif (options.userID) {\n\t\t\t\ttry {\n\t\t\t\t\tconst userData = await sb.User.get(options.userID);\n\t\t\t\t\tif (userData) {\n\t\t\t\t\t\tembed.footer.text = `Triggered by: ${userData.Name} (ID ${userData.ID})`;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcatch {\n\t\t\t\t\tembed.footer.text = `Triggered by unknown user with ID ${options.userID}`;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\tawait this.logging.discord.send({\n\t\t\t\t\tembeds: [embed]\n\t\t\t\t});\n\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\tcatch {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\n\t\t/**\n\t\t * Attempts to normalize trigger definition and arguments into a uniform format\n\t\t * @param {string|string[]} definition\n\t\t * @param {Object|null} [params]\n\t\t * @returns {{definition: string, params: Object|null}}\n\t\t */\n\t\tstatic normalizeTriggerDefinition (definition, params = null) {\n\t\t\tlet triggerDefinition = definition;\n\t\t\tif (Array.isArray(definition) && definition.length === 1) {\n\t\t\t\ttriggerDefinition = definition[0];\n\t\t\t}\n\n\t\t\tif (typeof triggerDefinition === \"string\") {\n\t\t\t\treturn {\n\t\t\t\t\tdefinition: triggerDefinition,\n\t\t\t\t\tparams\n\t\t\t\t};\n\t\t\t}\n\t\t\telse if (Array.isArray(triggerDefinition)) {\n\t\t\t\treturn {\n\t\t\t\t\tdefinition: triggerDefinition[0],\n\t\t\t\t\tparams: triggerDefinition[1] ?? params\n\t\t\t\t};\n\t\t\t}\n\t\t\telse {\n\t\t\t\tthrow new CustomError({\n\t\t\t\t\tmessage: \"Invalid trigger definition provided\",\n\t\t\t\t\targs: {\n\t\t\t\t\t\tdefinition,\n\t\t\t\t\t\tparams\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\n\t\t/**\n\t\t * Initializes the Trigger controller.\n\t\t * @returns {Promise<TriggerController>}\n\t\t */\n\t\tstatic async initialize () {\n\t\t\tconst instance = new TriggerController();\n\n\t\t\t// If available, set up Discord logging\n\t\t\tif (sb.Config) {\n\t\t\t\tconst loggingConfig = await sb.Config.get(\"TRIGGER_LOGGING_DISCORD\");\n\t\t\t\tif (loggingConfig) {\n\t\t\t\t\tawait instance.setupDiscordLogging(loggingConfig);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn instance;\n\t\t}\n\n\t\t/**\n\t\t * Destroys the Trigger controller\n\t\t */\n\t\tstatic destroy () {\n\t\t\tthis.module = null;\n\t\t}\n\t}\n\n\treturn TriggerController;\n})();\n\u0005End File\u0006# Supinic/supibot\n# singletons/query-variables/index.js\nmodule.exports = (function () {\n\t\"use strict\";\n\n\t/**\n\t * Query variables. Used to make reusing SQL snippets easier.\n\t * @memberof sb\n\t * @namespace QueryVariables\n\t */\n\n\tconst Singleton = require(\"../singleton.js\");\n\t/**\n\t * @class\n\t * @name sb.QueryVariables\n\t * @memberof sb\n\t */\n\treturn class QueryVariables extends Singleton {\n\t\t/**\n\t\t * @returns {Object<string, string>|{}}\n\t\t */\n\t\tstatic get variables () {\n\t\t\treturn (this.module) ? this.module.data : {};\n\t\t}\n\n\t\t/**\n\t\t * @param {string} name\n\t\t * @returns {string|null}\n\t\t */\n\t\tstatic get (name) {\n\t\t\tif (!this.module) {\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\treturn this.module.get(name);\n\t\t}\n\n\t\t/**\n\t\t * Initializes the singleton module with existing variables.\n\t\t * @returns {Promise<Object>}\n\t\t */\n\t\tstatic async initialize () {\n\t\t\tawait this.loadData();\n\n\t\t\treturn this.module;\n\t\t}\n\n\t\t/**\n\t\t * Refreshes the internal data from the database.\n\t\t * @returns {Promise<Object>}\n\t\t */\n\t\tstatic async loadData () {\n\t\t\tif (!sb.Query) {\n\t\t\t\tthrow new sb.Error({\n\t\t\t\t\tmessage: \"Query builder is not ready!\"\n\t\t\t\t});\n\t\t\t}\n\n\t\t\tthis.module = new QueryVariables();\n\t\t\tthis.module.data = {};\n\n\t\t\tconst data = await sb.Query.getRecordset(rs => rs\n\t\t\t\t.select(\"*\")\n\t\t\t\t.from(\"chat_data\", \"Query_Variable\")\n\t\t\t);\n\n\t\t\tfor (const row of data) {\n\t\t\t\tthis.module.data[row.Name] = row.Value;\n\t\t\t}\n\n\t\t\treturn this.module.data;\n\t\t}\n\n\t\tconstructor () {\n\t\t\tsuper();\n\n\t\t\tthis.data = {};\n\t\t}\n\n\t\t/**\n\t\t * Returns a variable value, or null if it doesn't exist.\n\t\t * @param {string} name Variable name\n\t\t * @returns {string|null}\n\t\t */\n\t\tget (name) {\n\t\t\treturn this.data[name] ?? null;\n\t\t}\n\n\t\t/**\n\t\t * Sets a variable value. Mirrors it in the database as well.\n\t\t * @param {string} name Variable name\n\t\t * @param {string} value New value\n\t\t * @returns {Promise<boolean>} True if save succeeded, false if not.\n\t\t */\n\t\tasync set (name, value) {\n\t\t\tconst exists = await sb.Query.getRecordset(rs => rs\n\t\t\t\t.select(\"Name\")\n\t\t\t\t.from(\"chat_data\", \"Query_Variable\")\n\t\t\t\t.where(\"Name = %s\", name)\n\t\t\t\t.limit(1)\n\t\t\t\t.single()\n\t\t\t\t.flat(\"Name\")\n\t\t\t);\n\n\t\t\tif (exists) {\n\t\t\t\tconst row = await sb.Query.getRow(\"chat_data\", \"Query_Variable\");\n\t\t\t\tawait row.load({ Name: name });\n\n\t\t\t\trow.values.Value = value;\n\t\t\t\tawait row.save();\n\t\t\t}\n\t\t\telse {\n\t\t\t\tconst row = await sb.Query.getRow(\"chat_data\", \"Query_Variable\");\n\t\t\t\trow.values.Name = name;\n\t\t\t\trow.values.Value = value;\n\t\t\t\tawait row.save();\n\t\t\t}\n\n\t\t\tthis.data[name] = value;\n\t\t\treturn true;\n\t\t}\n\n\t\t/**\n\t\t * Removes a variable. Mirrors it in the database as well.\n\t\t * @param {string} name Variable name\n\t\t * @returns {Promise<boolean>} True if delete succeeded, false if not.\n\t\t */\n\t\tasync delete (name) {\n\t\t\tif (typeof this.data[name] === \"undefined\") {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\tawait sb.Query.raw(`DELETE FROM chat_data.Query_Variable WHERE Name = '${name}'`);\n\t\t\tdelete this.data[name];\n\n\t\t\treturn true;\n\t\t}\n\n\t\t/**\n\t\t * Destroys the singleton module.\n\t\t */\n\t\tstatic destroy () {\n\t\t\tthis.module = null;\n\t\t}\n\t};\n})();\n\u0005End File\u0006module.exports = (function () {\n\t\"use strict\";\n\n\t/**\n\t * Redis client wrapper singleton class\n\t */\n\tconst Redis = require(\"ioredis\");\n\tconst Singleton = require(\"../singleton.js\");\n\tconst SecretCache = require(\"../../secret-cache.js\");\n\n\treturn class RedisManager extends Singleton {\n\t\t/**\n\t\t * Sets up Redis client singleton\n\t\t * @returns {Promise<RedisManager>}\n\t\t */\n\t\tstatic async initialize () {\n\t\t\tconst auth = await SecretCache.get(\"Redis\");\n\t\t\tconst [provider, ...loginNameTokens] = auth.login.split(\" \");\n\t\t\tlet client = null;\n\n\t\t\tif (provider === \"redis-stack\") {\n\t\t\t\tconst [host, port] = loginNameTokens;\n\n\t\t\t\tclient = new Redis({\n\t\t\t\t\thost,\n\t\t\t\t\tport,\n\t\t\t\t\tusername: auth.username,\n\t\t\t\t\tpassword: auth.password,\n\t\t\t\t\tlazyConnect: true\n\t\t\t\t});\n\t\t\t}\n\t\t\telse if (provider === \"redis\") {\n\t\t\t\tconst [host, port] = loginNameTokens;\n\n\t\t\t\tclient = new Redis({\n\t\t\t\t\thost,\n\t\t\t\t\tport,\n\t\t\t\t\tusername: auth.username,\n\t\t\t\t\tpassword: auth.password,\n\t\t\t\t\tlazyConnect: true\n\t\t\t\t});\n\t\t\t}\n\t\t\telse if (provider === \"redis-cloud\") {\n\t\t\t\tclient = new Redis({\n\t\t\t\t\thost: loginNameTokens.join(\" \"),\n\t\t\t\t\tusername: auth.username,\n\t\t\t\t\tpassword: auth.password,\n\t\t\t\t\tlazyConnect: true\n\t\t\t\t});\n\t\t\t}\n\t\t\telse if (provider === \"redis-sentinel\") {\n\t\t\t\tconst nodes = loginNameTokens.map(i => {\n\t\t\t\t\tconst [host, port] = i.split(\":\");\n\t\t\t\t\treturn { host, port };\n\t\t\t\t});\n\n\t\t\t\tclient = new Redis({\n\t\t\t\t\tsentinels: nodes,\n\t\t\t\t\tsentinelUsername: auth.sentinelUsername ?? auth.username,\n\t\t\t\t\tsentinelPassword: auth.sentinelPassword ?? auth.password,\n\t\t\t\t\tusername: auth.username,\n\t\t\t\t\tpassword: auth.password,\n\t\t\t\t\tname: auth.sentinelName ?? \"master\",\n\t\t\t\t\tlazyConnect: true\n\t\t\t\t});\n\t\t\t}\n\t\t\telse {\n\t\t\t\tconsole.warn(\"Unexpected Redis provider definition:\", provider);\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\t// Set up connection timeouts and error handling\n\t\t\ttry {\n\t\t\t\tclient.options.connectTimeout = 10_000;\n\t\t\t\tclient.options.maxRetriesPerRequest = 2;\n\t\t\t\tclient.options.retryStrategy = (times) => Math.min(times * 250, 10_000);\n\n\t\t\t\tclient.on(\"error\", (err) => {\n\t\t\t\t\tif (err.code === \"ECONNRESET\") {\n\t\t\t\t\t\tconsole.warn(\"Redis connection reset\");\n\t\t\t\t\t}\n\t\t\t\t\telse if (err.code === \"ECONNREFUSED\") {\n\t\t\t\t\t\tconsole.warn(\"Redis connection refused\");\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tconsole.error(\"Redis error\", err);\n\t\t\t\t\t}\n\t\t\t\t});\n\n\t\t\t\tclient.on(\"close\", () => {\n\t\t\t\t\tconsole.warn(\"Redis connection closed\");\n\t\t\t\t});\n\n\t\t\t\tawait client.connect();\n\n\t\t\t\tconst instance = new RedisManager();\n\t\t\t\tinstance.client = client;\n\t\t\t\tinstance.initialized = true;\n\n\t\t\t\treturn instance;\n\t\t\t}\n\t\t\tcatch (e) {\n\t\t\t\tconsole.error(\"Redis initialization error\", e);\n\t\t\t\tthrow new Error(\"Redis initialization failed\");\n\t\t\t}\n\t\t}\n\n\t\tconstructor () {\n\t\t\tsuper();\n\t\t\tthis.client = null;\n\t\t\tthis.initialized = false;\n\t\t}\n\n\t\t/**\n\t\t * @param {string} key\n\t\t * @returns {Promise<string|null>}\n\t\t */\n\t\tasync get (key) {\n\t\t\tif (!this.initialized || !this.client.status === \"ready\") {\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\treturn await this.client.get(key);\n\t\t}\n\n\t\t/**\n\t\t * @param {string} key\n\t\t * @param {*} value\n\t\t * @param {Object} [options]\n\t\t * @param {number} [options.expiry] Expiration time in ms\n\t\t * @returns {Promise<void>}\n\t\t */\n\t\tasync set (key, value, options = {}) {\n\t\t\tif (!this.initialized || !this.client.status === \"ready\") {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (options.expiry) {\n\t\t\t\tawait this.client.set(key, value, \"PX\", options.expiry);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tawait this.client.set(key, value);\n\t\t\t}\n\t\t}\n\n\t\t/**\n\t\t * @param {string} key\n\t\t * @returns {Promise<boolean>}\n\t\t */\n\t\tasync delete (key) {\n\t\t\tif (!this.initialized || !this.client.status === \"ready\") {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\tconst result = await this.client.del(key);\n\t\t\treturn (result === 1);\n\t\t}\n\n\t\t/**\n\t\t * @param {string} pattern\n\t\t * @returns {Promise<string[]>}\n\t\t */\n\t\tasync listKeys (pattern) {\n\t\t\tif (!this.initialized || !this.client.status === \"ready\") {\n\t\t\t\treturn [];\n\t\t\t}\n\n\t\t\treturn await this.client.keys(pattern);\n\t\t}\n\n\t\t/**\n\t\t * @param {string} key\n\t\t * @param {number} value\n\t\t * @returns {Promise<number>}\n\t\t */\n\t\tasync increment (key, value = 1) {\n\t\t\tif (!this.initialized || !this.client.status === \"ready\") {\n\t\t\t\treturn 0;\n\t\t\t}\n\n\t\t\treturn await this.client.incrby(key, value);\n\t\t}\n\n\t\t/**\n\t\t * @param {string} key\n\t\t * @param {number} value\n\t\t * @returns {Promise<number>}\n\t\t */\n\t\tasync decrement (key, value = 1) {\n\t\t\tif (!this.initialized || !this.client.status === \"ready\") {\n\t\t\t\treturn 0;\n\t\t\t}\n\n\t\t\treturn await this.client.decrby(key, value);\n\t\t}\n\n\t\t/**\n\t\t * Destroys the singleton.\n\t\t * @returns {Promise<void>}\n\t\t */\n\t\tstatic async destroy () {\n\t\t\tif (this.module) {\n\t\t\t\tif (this.module.client?.status === \"ready\") {\n\t\t\t\t\tawait this.module.client.quit();\n\t\t\t\t}\n\n\t\t\t\tthis.module = null;\n\t\t\t}\n\t\t}\n\t};\n})();\n\u0005End File\u0006# Supinic/supibot\n# singletons/date-and-time/index.js\nmodule.exports = (function () {\n\t\"use strict\";\n\n\t/**\n\t * Date/Time utilities class.\n\t * @memberof sb\n\t * @namespace DateAndTime\n\t */\n\n\tconst DAY_MS = 864e5;\n\tconst WEEK_MS = 7 * DAY_MS;\n\tconst YEAR_MS = 365.25 * DAY_MS;\n\n\tconst Singleton = require(\"../singleton.js\");\n\tconst Temporal = require(\"@js-temporal/polyfill\");\n\n\treturn class DateAndTime extends Singleton {\n\t\t/**\n\t\t * Returns current datetime in ISO format.\n\t\t * @returns {string}\n\t\t */\n\t\tstatic getISO () {\n\t\t\treturn new Date().toISOString().split(\"T\").join(\" \").replace(\"Z\", \"\");\n\t\t}\n\n\t\t/**\n\t\t * Returns current day's midnight.\n\t\t * @returns {sb.Date}\n\t\t */\n\t\tstatic getTodayObject () {\n\t\t\tconst now = new sb.Date();\n\t\t\tnow.setUTCHours(0);\n\t\t\tnow.setUTCMinutes(0);\n\t\t\tnow.setUTCSeconds(0);\n\t\t\tnow.setUTCMilliseconds(0);\n\t\t\treturn now;\n\t\t}\n\n\t\t/**\n\t\t * Returns current day's midnight.\n\t\t * @returns {string}\n\t\t */\n\t\tstatic getToday () {\n\t\t\treturn new Date().toISOString().split(\"T\")[0];\n\t\t}\n\n\t\t/**\n\t\t * Returns a pseudo-random number between two bounds.\n\t\t * @param {Number} min Lower inclusive bound\n\t\t * @param {Number} max Upper inclusive bound\n\t\t * @returns {number}\n\t\t */\n\t\tstatic randomInteger (min, max) {\n\t\t\treturn Math.floor(Math.random() * (max - min + 1) + min);\n\t\t}\n\n\t\t/**\n\t\t * Parses human readable time expressions to a time difference in milliseconds\n\t\t * Example: \"5m 30s\" => 330000\n\t\t * @param {string} string\n\t\t * @param {boolean} [permissive] If true, no error will be thrown when parsing strings with a date\n\t\t * @returns {number}\n\t\t * @throws {sb.Error} If the parsing of the date-time fails\n\t\t */\n\t\tstatic parseDuration (string, permissive = false) {\n\t\t\tif (!string) {\n\t\t\t\treturn 0;\n\t\t\t}\n\n\t\t\tif (typeof string !== \"string\") {\n\t\t\t\tthrow new sb.Error({\n\t\t\t\t\tmessage: \"Invalid parameter type, only string allowed\",\n\t\t\t\t\targs: { type: typeof string }\n\t\t\t\t});\n\t\t\t}\n\n\t\t\tstring = string.replace(/and/g, \"\").trim();\n\t\t\tif (string === \"none\" || string === \"\") {\n\t\t\t\treturn 0;\n\t\t\t}\n\n\t\t\tconst parts = string.match(/[0-9]+[^0-9]+/g) ?? [];\n\t\t\tif (string.replace(/\\s+/g, \"\").match(/[0-9]$/) !== null) {\n\t\t\t\tparts.push(string.match(/[0-9]+$/)[0] + \"s\");\n\t\t\t}\n\n\t\t\tif (parts.length === 0) {\n\t\t\t\tthrow new sb.Error({\n\t\t\t\t\tmessage: \"Input string is not a valid time expression\",\n\t\t\t\t\targs: string\n\t\t\t\t});\n\t\t\t}\n\t\t\tif (!permissive) {\n\t\t\t\tconst dayRegex = parts.find(i => i.match(/([0-9]+(d|mo|mon|month|months|y|year|years))/));\n\t\t\t\tif (dayRegex) {\n\t\t\t\t\tthrow new sb.Error({\n\t\t\t\t\t\tmessage: \"Cannot use month/year for relative times\",\n\t\t\t\t\t\targs: dayRegex\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tlet delta = 0;\n\t\t\tfor (const i of parts) {\n\t\t\t\tconst part = i.trim();\n\t\t\t\tlet temp = part.replace(/[^0-9]/g, \"\");\n\t\t\t\tconst number = Number(temp);\n\n\t\t\t\tif (part.includes(\"ms\") || part.includes(\"millisecond\")) {\n\t\t\t\t\tdelta += number;\n\t\t\t\t}\n\t\t\t\telse if (part.includes(\"s\") && !part.includes(\"m\") && !part.includes(\"h\")) {\n\t\t\t\t\tdelta += number * 1000;\n\t\t\t\t}\n\t\t\t\telse if (part.includes(\"m\") && !part.includes(\"h\")) {\n\t\t\t\t\tdelta += number * 60000;\n\t\t\t\t}\n\t\t\t\telse if (part.includes(\"h\")) {\n\t\t\t\t\tdelta += number * 3600000;\n\t\t\t\t}\n\t\t\t\telse if (part.includes(\"d\")) {\n\t\t\t\t\tdelta += number * 86400000;\n\t\t\t\t}\n\t\t\t\telse if (part.match(/(mo|mon|month|months)/)) {\n\t\t\t\t\tdelta += number * 2628001000;\n\t\t\t\t}\n\t\t\t\telse if (part.match(/(y|year|years)/)) {\n\t\t\t\t\tdelta += number * 31536000000;\n\t\t\t\t}\n\t\t\t\telse if (part.match(/(week|weeks|wk|w)(?!e)/)) {\n\t\t\t\t\tdelta += number * 604800000;\n\t\t\t\t}\n\t\t\t\telse if (part.includes(\"season\")) {\n\t\t\t\t\tdelta += number * 7776000000;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tthrow new sb.Error({\n\t\t\t\t\t\tmessage: \"Unrecognized unit in time expression\",\n\t\t\t\t\t\targs: { part, deltaAtThisPart: delta }\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn delta;\n\t\t}\n\n\t\t/**\n\t\t * Parse a given string and results with a Date object, or null if unparseable.\n\t\t * Also accepts an ISO string or a number in milliseconds.\n\t\t * @param {String|Number} string String to parse as date, or number in milliseconds\n\t\t * @param {Boolean} relaxed If false, require ISO format. If true, try and use Javascript parser.\n\t\t * @returns {Date|null}\n\t\t */\n\t\tstatic parseDate (string, relaxed) {\n\t\t\tif (typeof string === \"number\") {\n\t\t\t\treturn new Date(string);\n\t\t\t}\n\t\t\telse if (typeof string !== \"string\") {\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\t// If the string contains a slash, a space or dash immediately followed by a number, or the start of the string immediately has a number\n\t\t\t// it will be considered a date or date-time instead of a duration.\n\t\t\t// If it doesn't contain a slash, but still contains a number, it will be considered a duration.\n\t\t\tif (string.match(/^[0-9]+$/) !== null) {\n\t\t\t\treturn new Date(Number(string));\n\t\t\t}\n\t\t\telse if (!string.includes(\"/\") && !string.includes(\"T\") && !string.match(/(\\s+|-)[0-9]+/) && !string.match(/^[0-9]+/)) {\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\t// If the string contains \"in X days\", parse it accordingly\n\t\t\tconst futureMatch = string.match(/in ([0-9]+) days/);\n\t\t\tif (futureMatch) {\n\t\t\t\tconst now = new Date();\n\t\t\t\tnow.setDate(now.getDate() + Number(futureMatch[1]));\n\t\t\t\treturn now;\n\t\t\t}\n\n\t\t\t// Same but for \"X days ago\"\n\t\t\tconst pastMatch = string.match(/([0-9]+) days ago/);\n\t\t\tif (pastMatch) {\n\t\t\t\tconst now = new Date();\n\t\t\t\tnow.setDate(now.getDate() - Number(pastMatch[1]));\n\t\t\t\treturn now;\n\t\t\t}\n\n\t\t\tlet date = null;\n\t\t\ttry {\n\t\t\t\tif (relaxed) {\n\t\t\t\t\tdate = new Date(string);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tdate = new Date(string.replace(/ /g, \"T\") + \"Z\");\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (e) {\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\tif (!relaxed && date.toString() === \"Invalid Date\") {\n\t\t\t\tdate = null;\n\t\t\t}\n\n\t\t\treturn date;\n\t\t}\n\n\t\t/**\n\t\t * Parses a relative time format and returns a Unix timestamp of when it happens\n\t\t * @param {string} string\n\t\t * @returns {number}\n\t\t */\n\t\tstatic parseRelativeTime (string) {\n\t\t\tconst ms = this.parseDuration(string, false);\n\t\t\treturn Date.now() + ms;\n\t\t}\n\n\t\t/**\n\t\t * Compares date to source\n\t\t * @param {Date} date\n\t\t * @param {Date} [sourceDate] defaults to current date\n\t\t * @returns {string} humanized difference, e.g. \"3 days ago\", \"in 5 minutes\"\n\t\t */\n\t\tstatic getRelativeTime (date, sourceDate) {\n\t\t\tsourceDate = sourceDate ?? new Date();\n\n\t\t\tconst magnitude = Math.round(Math.abs(date.valueOf() - sourceDate.valueOf()) / 1000);\n\t\t\tlet noun = null;\n\t\t\tlet adjective = null;\n\t\t\tlet precise = false;\n\n\t\t\tif (magnitude < 60) {\n\t\t\t\tnoun = \"second\";\n\t\t\t\tadjective = magnitude;\n\t\t\t}\n\t\t\telse if (magnitude >= 60 && magnitude < 3600) {\n\t\t\t\tnoun = \"minute\";\n\t\t\t\tadjective = Math.floor(magnitude / 60);\n\t\t\t}\n\t\t\telse if (magnitude >= 3600 && magnitude < 86400) {\n\t\t\t\tnoun = \"hour\";\n\t\t\t\tadjective = Math.floor(magnitude / 3600);\n\t\t\t}\n\t\t\telse if (magnitude >= 86400 && magnitude < 2678400) {\n\t\t\t\tnoun = \"day\";\n\t\t\t\tadjective = Math.floor(magnitude / 86400);\n\t\t\t}\n\t\t\telse if (magnitude >= 2678400 && magnitude < 31536000) {\n\t\t\t\tnoun = \"month\";\n\t\t\t\tadjective = Math.floor(magnitude / 2678400);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tconst diff = magnitude / 31536000;\n\t\t\t\tnoun = \"year\";\n\t\t\t\tadjective = Math.floor(diff);\n\n\t\t\t\t// For time differences spanning multiple years, e.g.: 3 years and 5 months or 1 year and 7 months\n\t\t\t\t// use a more precise format.\n\t\t\t\tif (diff > 1.25) {\n\t\t\t\t\tconst months = Math.round((diff - Math.floor(diff)) * 12);\n\t\t\t\t\tif (months !== 0) {\n\t\t\t\t\t\tprecise = true;\n\t\t\t\t\t\tadjective = `${Math.floor(diff)} ${noun}${Math.floor(diff) === 1 ? \"\" : \"s\"} and ${months} month${months === 1 ? \"\" : \"s\"}`;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// If not precise, pluralize if needed\n\t\t\tif (!precise && adjective !== 1) {\n\t\t\t\tnoun += \"s\";\n\t\t\t}\n\n\t\t\tconst operator = (date.valueOf() < sourceDate.valueOf()) ? \"ago\" : \"in\";\n\t\t\tconst humanized = precise ? `${operator} ${adjective}` : `${operator} ${adjective} ${noun}`;\n\t\t\treturn humanized;\n\t\t}\n\n\t\t/**\n\t\t * Returns a humanized string based on number of milliseconds\n\t\t * @param {number} deltaMilliseconds Delta in milliseconds\n\t\t * @param {string} [format] If none provided, defaults to long. Available: \"long\", \"short\", \"digital\" or \"list\".\n\t\t * @returns {string}\n\t\t */\n\t\tstatic humanize (deltaMilliseconds, format = \"long\") {\n\t\t\tif (typeof deltaMilliseconds !== \"number\") {\n\t\t\t\tthrow new Error(\"humanize: Delta must be a number\");\n\t\t\t}\n\t\t\tif (deltaMilliseconds < 0) {\n\t\t\t\tthrow new Error(\"humanize: Delta must be a positive number\");\n\t\t\t}\n\n\t\t\tconst step = Math.floor(deltaMilliseconds / 1000);\n\t\t\tif (step < 0) {\n\t\t\t\treturn \"0 seconds\";\n\t\t\t}\n\n\t\t\tlet seconds = step % 60;\n\t\t\tlet minutes = Math.floor(step / 60) % 60;\n\t\t\tlet hours = Math.floor(step / 3600) % 24;\n\t\t\tlet days = Math.floor(step / 86400) % 7;\n\t\t\tlet weeks = Math.floor(step / 604800) % 4;\n\t\t\tlet months = Math.floor(step / 2592000) % 12;\n\t\t\tconst years = Math.floor(step / 31536000);\n\n\t\t\tif (years > 0 && months > 0 && format === \"long\") {\n\t\t\t\tmonths = Math.round((deltaMilliseconds - (years * YEAR_MS)) / 2592000000);\n\t\t\t\tweeks = days = hours = minutes = seconds = 0;\n\t\t\t}\n\t\t\telse if (months > 0 && days > 0 && format === \"long\") {\n\t\t\t\tdays = Math.round(((deltaMilliseconds - (months * 2592000000)) % WEEK_MS) / DAY_MS);\n\t\t\t\tweeks = hours = minutes = seconds = 0;\n\t\t\t}\n\t\t\telse if (days > 0 && hours > 0 && format === \"long\") {\n\t\t\t\thours = Math.round(((deltaMilliseconds - (days * DAY_MS)) % DAY_MS) / 3600000);\n\t\t\t\tminutes = seconds = 0;\n\t\t\t}\n\t\t\telse if (hours > 0 && minutes > 0 && format === \"long\") {\n\t\t\t\tminutes = Math.round(((deltaMilliseconds - (hours * 3600000)) % 3600000) / 60000);\n\t\t\t\tseconds = 0;\n\t\t\t}\n\t\t\telse if (minutes > 0 && seconds > 0 && format === \"long\") {\n\t\t\t\tseconds = Math.round(((deltaMilliseconds - (minutes * 60000)) % 60000) / 1000);\n\t\t\t}\n\n\t\t\tlet string;\n\t\t\tif (format === \"digital\") {\n\t\t\t\t// transform hours, minutes, seconds, etc to have a padding zero if they're less than 10\n\t\t\t\t// disregard years, months, weeks\n\t\t\t\t[hours, minutes, seconds] = [hours, minutes, seconds].map(i => (i < 10) ? `0${i}` : `${i}`);\n\n\t\t\t\tif (days > 0) {\n\t\t\t\t\tconst dayString = (days === 1) ? \"day\" : \"days\";\n\t\t\t\t\tstring = `${days} ${dayString}, ${hours}:${minutes}:${seconds}`;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tstring = `${hours}:${minutes}:${seconds}`;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (format === \"list\") {\n\t\t\t\tconst values = [];\n\n\t\t\t\tif (years > 0) {\n\t\t\t\t\tvalues.push(`${years}y`);\n\t\t\t\t}\n\t\t\t\tif (months > 0) {\n\t\t\t\t\tvalues.push(`${months}mo`);\n\t\t\t\t}\n\t\t\t\tif (weeks > 0) {\n\t\t\t\t\tvalues.push(`${weeks}w`);\n\t\t\t\t}\n\t\t\t\tif (days > 0) {\n\t\t\t\t\tvalues.push(`${days}d`);\n\t\t\t\t}\n\t\t\t\tif (hours > 0) {\n\t\t\t\t\tvalues.push(`${hours}h`);\n\t\t\t\t}\n\t\t\t\tif (minutes > 0) {\n\t\t\t\t\tvalues.push(`${minutes}m`);\n\t\t\t\t}\n\t\t\t\tif (seconds > 0) {\n\t\t\t\t\tvalues.push(`${seconds}s`);\n\t\t\t\t}\n\n\t\t\t\tstring = values.join(\", \");\n\t\t\t}\n\t\t\telse if (format === \"short\") {\n\t\t\t\tlet count = 0;\n\t\t\t\tconst obj = { years, months, weeks, days, hours, minutes, seconds };\n\t\t\t\tconst suffixes = {\n\t\t\t\t\tyears: \"y\", months: \"mo\", weeks: \"w\", days: \"d\", hours: \"h\", minutes: \"m\", seconds: \"s\"\n\t\t\t\t};\n\n\t\t\t\tconst resultArray = [];\n\t\t\t\tfor (const [key, value] of Object.entries(obj)) {\n\t\t\t\t\tif (value > 0) {\n\t\t\t\t\t\tcount++;\n\t\t\t\t\t\tresultArray.push(`${value}${suffixes[key]}`);\n\t\t\t\t\t}\n\n\t\t\t\t\tif (count >= 2) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (resultArray.length === 0) {\n\t\t\t\t\tresultArray.push(\"0s\");\n\t\t\t\t}\n\n\t\t\t\tstring = resultArray.join(\" \");\n\t\t\t}\n\t\t\telse if (format === \"long\") {\n\t\t\t\tconst amounts = { years, months, weeks, days, hours, minutes, seconds };\n\t\t\t\tconst wordForms = {\n\t\t\t\t\tyears: [\"year\", \"years\"],\n\t\t\t\t\tmonths: [\"month\", \"months\"],\n\t\t\t\t\tweeks: [\"week\", \"weeks\"],\n\t\t\t\t\tdays: [\"day\", \"days\"],\n\t\t\t\t\thours: [\"hour\", \"hours\"],\n\t\t\t\t\tminutes: [\"minute\", \"minutes\"],\n\t\t\t\t\tseconds: [\"second\", \"seconds\"]\n\t\t\t\t};\n\n\t\t\t\tconst resultArray = [];\n\t\t\t\tfor (const [key, value] of Object.entries(amounts)) {\n\t\t\t\t\tif (value <= 0) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\tconst proper = (value === 1) ? wordForms[key][0] : wordForms[key][1];\n\t\t\t\t\tresultArray.push(`${value} ${proper}`);\n\t\t\t\t}\n\n\t\t\t\tif (resultArray.length === 0) {\n\t\t\t\t\tresultArray.push(\"0 seconds\");\n\t\t\t\t}\n\n\t\t\t\tstring = resultArray.join(\", \");\n\t\t\t}\n\t\t\telse {\n\t\t\t\tthrow new Error(`Unknown format \"${format}\" provided`);\n\t\t\t}\n\n\t\t\treturn string;\n\t\t}\n\n\t\t/**\n\t\t * Returns a \"YYYY-MM-DD\" date string for a given Date instance.\n\t\t * @param {Date|number} date If not specified, today will be used.\n\t\t * @param {string} format Target format, default: \"YYYY-MM-DD\"\n\t\t * @returns {string}\n\t\t */\n\t\tstatic formatDate (date = new Date(), format = \"YYYY-MM-DD\") {\n\t\t\tif (typeof date === \"number\") {\n\t\t\t\tdate = new Date(date);\n\t\t\t}\n\t\t\telse if (!(date instanceof Date)) {\n\t\t\t\tthrow new Error(\"Target date must be a Date object\");\n\t\t\t}\n\t\t\telse if (date.toString() === \"Invalid Date\") {\n\t\t\t\tthrow new Error(\"Target date is not a valid date\");\n\t\t\t}\n\n\t\t\treturn format\n\t\t\t\t.replace(/YYYY/g, String(date.getUTCFullYear()))\n\t\t\t\t.replace(/YY/g, String(date.getUTCFullYear()).slice(2))\n\t\t\t\t.replace(/MM/g, String(date.getUTCMonth() + 1).padStart(2, \"0\"))\n\t\t\t\t.replace(/DD/g, String(date.getUTCDate()).padStart(2, \"0\"))\n\t\t\t\t.replace(/hh/g, String(date.getUTCHours()).padStart(2, \"0\"))\n\t\t\t\t.replace(/mm/g, String(date.getUTCMinutes()).padStart(2, \"0\"))\n\t\t\t\t.replace(/ss/g, String(date.getUTCSeconds()).padStart(2, \"0\"))\n\t\t\t\t.replace(/M/g, String(date.getUTCMonth() + 1))\n\t\t\t\t.replace(/D/g, String(date.getUTCDate()))\n\t\t\t\t.replace(/h/g, String(date.getUTCHours()))\n\t\t\t\t.replace(/m/g, String(date.getUTCMinutes()))\n\t\t\t\t.replace(/s/g, String(date.getUTCSeconds()));\n\t\t}\n\n\t\t/**\n\t\t * Returns an array of dates that is created by starting with startDate, and then adding the interval X times, where X is the number of occurrences.\n\t\t * @param {Object} params\n\t\t * @param {Object} params.startDate\n\t\t * @param {Object} params.interval\n\t\t * @param {Object} params.occurrences\n\t\t * @returns {Array}\n\t\t */\n\t\tstatic createBatch (params) {\n\t\t\tconst dates = [];\n\t\t\tlet date = new Date(params.startDate);\n\t\t\tfor (let i = 0; i < params.occurrences; i++) {\n\t\t\t\tdates.push(new Date(date));\n\t\t\t\tdate = new Date(date.valueOf() + params.interval);\n\t\t\t}\n\n\t\t\treturn dates;\n\t\t}\n\n\t\t/**\n\t\t * Creates a daily batch of dates, where each date is set to a given time of day.\n\t\t * @param {Object} params\n\t\t * @param {Object} params.startDate\n\t\t * @param {Object} params.occurrences\n\t\t * @param {number} params.hours\n\t\t * @param {number} params.minutes\n\t\t * @param {number} params.seconds\n\t\t * @returns {Array}\n\t\t */\n\t\tstatic createDailyBatchAtTime (params) {\n\t\t\tconst dates = [];\n\t\t\tconst { hours, minutes, seconds } = params;\n\t\t\tlet date = new Date(params.startDate);\n\t\t\tdate.setHours(hours);\n\t\t\tdate.setMinutes(minutes);\n\t\t\tdate.setSeconds(seconds);\n\n\t\t\tfor (let i = 0; i < params.occurrences; i++) {\n\t\t\t\tdates.push(new Date(date));\n\t\t\t\tdate.setDate(date.getDate() + 1);\n\t\t\t}\n\n\t\t\treturn dates;\n\t\t}\n\n\t\t/**\n\t\t * Initializes the DateAndTime class\n\t\t * @returns {DateAndTime}\n\t\t */\n\t\tstatic initialize () {\n\t\t\tconst DateAndTimeModule = require(\"./date-and-time.js\");\n\t\t\tthis.module = new DateAndTimeModule();\n\n\t\t\t/**\n\t\t\t * Class extending Date with some utility methods\n\t\t\t * @extends {Date}\n\t\t\t */\n\t\t\tsb.Date = class ExtendedDate extends Date {\n\t\t\t\t/**\n\t\t\t\t * Creates a new Date, while copying the value of another\n\t\t\t\t * @param {Date} date\n\t\t\t\t * @returns {sb.Date}\n\t\t\t\t */\n\t\t\t\tstatic copyDate (date) {\n\t\t\t\t\treturn new sb.Date(date.valueOf());\n\t\t\t\t}\n\n\t\t\t\t/**\n\t\t\t\t * Returns \"floor-ish\" dates for comparison.\n\t\t\t\t * @example\n\t\t\t\t * // let date = (today);\n\t\t\t\t * let [start, end] = sb.Date.getUTCBoundaries(\"month\");\n\t\t\t\t * // start = beginning of current month, (YYYY-MM-01 00:00:00.000Z)\n\t\t\t\t * // end = end of current month, (YYYY-MM-31 23:59:59.999Z)\n\t\t\t\t * @param {\"day\"|\"month\"|\"year\"} period Target period to get the boundaries of\n\t\t\t\t * @param {Date|number} [date] If not provided, today is used\n\t\t\t\t * @returns {[ExtendedDate, ExtendedDate]}\n\t\t\t\t */\n\t\t\t\tstatic getUTCBoundaries (period, date) {\n\t\t\t\t\tif (typeof date === \"number\") {\n\t\t\t\t\t\tdate = new Date(date);\n\t\t\t\t\t}\n\t\t\t\t\telse if (date === undefined || date === null) {\n\t\t\t\t\t\tdate = new Date();\n\t\t\t\t\t}\n\t\t\t\t\telse if (!(date instanceof Date)) {\n\t\t\t\t\t\tthrow new Error(\"Date must be a Date object or a timestamp\");\n\t\t\t\t\t}\n\n\t\t\t\t\tif (period === \"day\") {\n\t\t\t\t\t\tconst start = new sb.Date(Date.UTC(\n\t\t\t\t\t\t\tdate.getUTCFullYear(),\n\t\t\t\t\t\t\tdate.getUTCMonth(),\n\t\t\t\t\t\t\tdate.getUTCDate(),\n\t\t\t\t\t\t\t0, 0, 0, 0\n\t\t\t\t\t\t));\n\t\t\t\t\t\tconst end = new sb.Date(start.valueOf() + 86399999);\n\t\t\t\t\t\treturn [start, end];\n\t\t\t\t\t}\n\t\t\t\t\telse if (period === \"month\") {\n\t\t\t\t\t\t// First day of current month\n\t\t\t\t\t\tconst start = new sb.Date(Date.UTC(\n\t\t\t\t\t\t\tdate.getUTCFullYear(),\n\t\t\t\t\t\t\tdate.getUTCMonth(),\n\t\t\t\t\t\t\t1,\n\t\t\t\t\t\t\t0, 0, 0, 0\n\t\t\t\t\t\t));\n\n\t\t\t\t\t\t// First day of next month\n\t\t\t\t\t\tconst end = new sb.Date(Date.UTC(\n\t\t\t\t\t\t\tdate.getUTCFullYear(),\n\t\t\t\t\t\t\tdate.getUTCMonth() + 1,\n\t\t\t\t\t\t\t1,\n\t\t\t\t\t\t\t0, 0, 0, 0\n\t\t\t\t\t\t));\n\t\t\t\t\t\tend.setMilliseconds(-1); // last day of current month\n\n\t\t\t\t\t\treturn [start, end];\n\t\t\t\t\t}\n\t\t\t\t\telse if (period === \"year\") {\n\t\t\t\t\t\t// First day of current year\n\t\t\t\t\t\tconst start = new sb.Date(Date.UTC(\n\t\t\t\t\t\t\tdate.getUTCFullYear(),\n\t\t\t\t\t\t\t0,\n\t\t\t\t\t\t\t1,\n\t\t\t\t\t\t\t0, 0, 0, 0\n\t\t\t\t\t\t));\n\n\t\t\t\t\t\t// First day of next year\n\t\t\t\t\t\tconst end = new sb.Date(Date.UTC(\n\t\t\t\t\t\t\tdate.getUTCFullYear() + 1,\n\t\t\t\t\t\t\t0,\n\t\t\t\t\t\t\t1,\n\t\t\t\t\t\t\t0, 0, 0, 0\n\t\t\t\t\t\t));\n\t\t\t\t\t\tend.setMilliseconds(-1); // last day of current year\n\n\t\t\t\t\t\treturn [start, end];\n\t\t\t\t\t}\n\n\t\t\t\t\tthrow new Error(\"Invalid period provided\");\n\t\t\t\t}\n\n\t\t\t\t/**\n\t\t\t\t * Returns a formatted date string.\n\t\t\t\t * @returns {string}\n\t\t\t\t */\n\t\t\t\tformat (format) {\n\t\t\t\t\treturn sb.DateAndTime.formatDate(this, format);\n\t\t\t\t}\n\n\t\t\t\t/**\n\t\t\t\t * Gets the first second of a given date.\n\t\t\t\t * @example\n\t\t\t\t * let day = new sb.Date();\n\t\t\t\t * day.getFullYear(); day.getMonth(); day.getDate();\n\t\t\t\t * // => 2020, 5, 25\n\t\t\t\t * let midnight = day.getMidnight();\n\t\t\t\t * midnight.toISOString();\n\t\t\t\t * // => 2020-06-25T00:00:00.000Z\n\t\t\t\t * @returns {sb.Date}\n\t\t\t\t */\n\t\t\t\tgetMidnight () {\n\t\t\t\t\tconst result = new sb.Date(\n\t\t\t\t\t\tthis.getFullYear(),\n\t\t\t\t\t\tthis.getMonth(),\n\t\t\t\t\t\tthis.getDate(),\n\t\t\t\t\t\t0, 0, 0, 0\n\t\t\t\t\t);\n\t\t\t\t\treturn result;\n\t\t\t\t}\n\n\t\t\t\t/**\n\t\t\t\t * Compares the date to current time and returns a humanized string.\n\t\t\t\t * @param {Date} [sourceDate] Defaults to the current date.\n\t\t\t\t * @returns {string}\n\t\t\t\t */\n\t\t\t\tgetRelativeTime (sourceDate) {\n\t\t\t\t\treturn sb.DateAndTime.getRelativeTime(this, sourceDate);\n\t\t\t\t}\n\n\t\t\t\t/**\n\t\t\t\t * Adds a given amount of days to the date.\n\t\t\t\t * @param {number} days\n\t\t\t\t * @returns {sb.Date}\n\t\t\t\t */\n\t\t\t\taddDays (days) {\n\t\t\t\t\tconst result = new sb.Date(this.valueOf());\n\t\t\t\t\tresult.setUTCDate(this.getUTCDate() + days);\n\t\t\t\t\treturn result;\n\t\t\t\t}\n\n\t\t\t\t/**\n\t\t\t\t * Adds a given amount of seconds to the date.\n\t\t\t\t * @param {number} seconds\n\t\t\t\t * @returns {sb.Date}\n\t\t\t\t */\n\t\t\t\taddSeconds (seconds) {\n\t\t\t\t\tconst result = new sb.Date(this.valueOf());\n\t\t\t\t\tresult.setUTCSeconds(this.getUTCSeconds() + seconds);\n\t\t\t\t\treturn result;\n\t\t\t\t}\n\n\t\t\t\t/**\n\t\t\t\t * Checks if a given date is equal to the current one (regardless of time).\n\t\t\t\t * @param {Date} date\n\t\t\t\t * @returns {boolean}\n\t\t\t\t */\n\t\t\t\tequalOnlyDate (date) {\n\t\t\t\t\tif (!(date instanceof Date)) {\n\t\t\t\t\t\tthrow new Error(\"Date must be a Date object\");\n\t\t\t\t\t}\n\n\t\t\t\t\tconst thisDay = this.getUTCDate();\n\t\t\t\t\tconst thisMonth = this.getUTCMonth();\n\t\t\t\t\tconst thisYear = this.getUTCFullYear();\n\t\t\t\t\tconst otherDay = date.getUTCDate();\n\t\t\t\t\tconst otherMonth = date.getUTCMonth();\n\t\t\t\t\tconst otherYear = date.getUTCFullYear();\n\n\t\t\t\t\treturn (thisDay === otherDay && thisMonth === otherMonth && thisYear === otherYear);\n\t\t\t\t}\n\t\t\t};\n\n\t\t\t// Add the Temporal API\n\t\t\tsb.Temporal = Temporal;\n\n\t\t\treturn this.module;\n\t\t}\n\n\t\t/**\n\t\t * Destroys the singleton class.\n\t\t */\n\t\tstatic destroy () {\n\t\t\tthis.module = null;\n\t\t\tdelete sb.Date;\n\t\t\tdelete sb.Temporal;\n\t\t}\n\t};\n})();\n\u0005End File\u0006# Supinic/supibot\nmodule.exports = (function () {\n\t\"use strict\";\n\n\tconst Singleton = require(\"../singleton.js\");\n\tconst ModuleManager = require(\"./manager.js\");\n\tconst EventEmitter = require(\"events\");\n\n\tclass EventModule extends EventEmitter {\n\t\tconstructor () {\n\t\t\tsuper();\n\t\t\tthis.manager = new ModuleManager();\n\t\t}\n\n\t\t/**\n\t\t * Registers a global event module\n\t\t * @param {Object} options\n\t\t * @param {string} options.Type\n\t\t * @param {string} options.Name\n\t\t * @param {string} options.Description\n\t\t * @param {string} options.Events\n\t\t * @param {Function} options.Code\n\t\t * @returns {Promise<void>}\n\t\t */\n\t\tasync register (options) {\n\t\t\tconst { Type, Name, Description, Events, Code } = options;\n\t\t\tif (!Type || !Name || !Events || !Code) {\n\t\t\t\tthrow new Error(\"Missing required event module parameters (Type, Name, Events, Code)\");\n\t\t\t}\n\n\t\t\tif (this.manager.isRegistered(Type, Name)) {\n\t\t\t\tthrow new Error(`Event module ${Type}.${Name} is already registered`);\n\t\t\t}\n\n\t\t\t// If events is an array, register multiple events\n\t\t\tconst events = Array.isArray(Events) ? Events : [Events];\n\t\t\tawait this.manager.register({\n\t\t\t\ttype: Type,\n\t\t\t\tname: Name,\n\t\t\t\tdescription: Description ?? \"\",\n\t\t\t\tevents,\n\t\t\t\tcode: Code\n\t\t\t});\n\n\t\t\tfor (const event of events) {\n\t\t\t\tthis.on(event, async (...args) => {\n\t\t\t\t\ttry {\n\t\t\t\t\t\treturn await Code(...args);\n\t\t\t\t\t}\n\t\t\t\t\tcatch (e) {\n\t\t\t\t\t\tconsole.error(`Error in event module ${Type}.${Name}:`, e);\n\t\t\t\t\t\treturn null;\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\n\t\t/**\n\t\t * Unregisters a global event module\n\t\t * @param {string} type\n\t\t * @param {string} name\n\t\t * @returns {Promise<boolean>} Returns true if the module was unregistered, false otherwise\n\t\t */\n\t\tasync unregister (type, name) {\n\t\t\t// Check if module exists first\n\t\t\tif (!this.manager.isRegistered(type, name)) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\tconst module = this.manager.get(type, name);\n\t\t\tif (!module) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\t// Unregister all event listeners\n\t\t\tfor (const event of module.events) {\n\t\t\t\tthis.removeAllListeners(event);\n\n\t\t\t\t// Re-register other event modules for this event\n\t\t\t\tconst otherModules = this.manager.getAll().filter(m => (\n\t\t\t\t\tm.events.includes(event) && (m.type !== type || m.name !== name)\n\t\t\t\t));\n\n\t\t\t\tfor (const otherModule of otherModules) {\n\t\t\t\t\tthis.on(event, async (...args) => {\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\treturn await otherModule.code(...args);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcatch (e) {\n\t\t\t\t\t\t\tconsole.error(`Error in event module ${otherModule.type}.${otherModule.name}:`, e);\n\t\t\t\t\t\t\treturn null;\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Remove the module from the manager\n\t\t\treturn await this.manager.unregister(type, name);\n\t\t}\n\n\t\t/**\n\t\t * Calls an event with the given parameters\n\t\t * @param {string} event\n\t\t * @param {Array} args\n\t\t * @returns {Promise<*>}\n\t\t */\n\t\tasync call (event, ...args) {\n\t\t\treturn await this.emit(event, ...args);\n\t\t}\n\n\t\t/**\n\t\t * Lists all registered event modules\n\t\t * @returns {Object}\n\t\t */\n\t\tlist () {\n\t\t\treturn this.manager.getAll();\n\t\t}\n\n\t\t/**\n\t\t * Destroys the module\n\t\t */\n\t\tdestroy () {\n\t\t\tthis.removeAllListeners();\n\t\t\tthis.manager = null;\n\t\t}\n\t}\n\n\treturn class Events extends Singleton {\n\t\t/**\n\t\t * @returns {Promise<EventModule>}\n\t\t */\n\t\tstatic async initialize () {\n\t\t\tthis.module = new EventModule();\n\t\t\treturn this.module;\n\t\t}\n\n\t\t/**\n\t\t * Destroys the module\n\t\t */\n\t\tstatic destroy () {\n\t\t\tif (this.module) {\n\t\t\t\tthis.module.destroy();\n\t\t\t}\n\t\t\tthis.module = null;\n\t\t}\n\t};\n})();\n\u0005End File\u0006# Supinic/supibot\nmodule.exports = (function () {\n\t\"use strict\";\n\n\tconst Singleton = require(\"../singleton.js\");\n\tconst { getLongTimeout } = require(\"../../utils/long-timeout.js\");\n\n\treturn class Cooldown extends Singleton {\n\t\t/**\n\t\t * Initializes the cooldown system.\n\t\t * @returns {Promise<Cooldown>}\n\t\t */\n\t\tstatic async initialize () {\n\t\t\tconst cooldown = new Cooldown();\n\t\t\tcooldown.commandMap = new Map();\n\t\t\tcooldown.pendingCommandMap = new Map();\n\t\t\tcooldown.channelMap = new Map();\n\t\t\tcooldown.userCommandMap = new Map();\n\t\t\tcooldown.userCommandGlobalMap = new Map();\n\t\t\tcooldown.globalCommandMap = new Map();\n\t\t\tcooldown.userMap = new Map();\n\t\t\tcooldown.userChannelCommandMap = new Map();\n\t\t\tcooldown.activeTimeouts = new Map();\n\n\t\t\treturn cooldown;\n\t\t}\n\n\t\t/**\n\t\t * Checks if a given combination of user, command and channel is currently on cooldown.\n\t\t * @param {Object} options\n\t\t * @param {sb.User} options.userID\n\t\t * @param {string} options.command\n\t\t * @param {sb.Command} [options.commandData] Command data instance - does not require fetching the command again\n\t\t * @param {sb.Channel} options.channel\n\t\t * @param {sb.Platform} options.platform\n\t\t * @param {Object} [options.options] Additional options\n\t\t * @param {boolean} [options.options.skipBanphrase] If true, banphrases will not be checked. Defaults to false.\n\t\t * @param {boolean} [options.options.skipPending] If true, pending commands will not be checked. Defaults to false.\n\t\t * @returns {Promise<boolean|Object>} True: Command is available to use; Object: Command is on cooldown,\n\t\t * or another error has occurred.\n\t\t */\n\t\tasync check (options) {\n\t\t\tconst {\n\t\t\t\tuserID, command, commandData, channel, platform, options: checkOptions = {}\n\t\t\t} = options;\n\n\t\t\tconst now = sb.Date.now();\n\t\t\tconst type = \"cooldown\";\n\t\t\tconst uid = String(userID);\n\n\t\t\t// Fetch command data - necessary for cooldowns\n\t\t\tlet data = commandData;\n\t\t\tif (!data) {\n\t\t\t\tdata = sb.Command.get(command);\n\t\t\t\tif (!data) {\n\t\t\t\t\treturn {\n\t\t\t\t\t\tsuccess: false,\n\t\t\t\t\t\treason: \"no-command\",\n\t\t\t\t\t\treply: \"Command doesn't exist!\"\n\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Commands that are marked as \"system\" - such as \"ban\" or \"specialusers\" - cannot be directly invoked.\n\t\t\tif (data.System) {\n\t\t\t\treturn {\n\t\t\t\t\tsuccess: false,\n\t\t\t\t\treason: \"system-command\",\n\t\t\t\t\treply: \"Command cannot be used directly!\"\n\t\t\t\t};\n\t\t\t}\n\n\t\t\t// Check if the command is not disabled\n\t\t\tif (data.Flags.disabled) {\n\t\t\t\treturn {\n\t\t\t\t\tsuccess: false,\n\t\t\t\t\treason: \"disabled-command\",\n\t\t\t\t\treply: \"Command has been marked as disabled. Probably means maintenance or a fix needs to be made.\"\n\t\t\t\t};\n\t\t\t}\n\n\t\t\t// Return if skipPending is not set and a command is currently being executed\n\t\t\tif (!checkOptions.skipPending && this.pendingCommandMap.has(command)) {\n\t\t\t\treturn {\n\t\t\t\t\tsuccess: false,\n\t\t\t\t\treason: \"pending-command\",\n\t\t\t\t\treply: `Command \"${command}\" is currently being executed!`\n\t\t\t\t};\n\t\t\t}\n\n\t\t\tif (channel && channel.Flags.COMMAND_DISABLED !== null && channel.Flags.COMMAND_DISABLED) {\n\t\t\t\treturn {\n\t\t\t\t\tsuccess: false,\n\t\t\t\t\treason: \"command-from-disabled-channel\",\n\t\t\t\t\treply: null\n\t\t\t\t};\n\t\t\t}\n\n\t\t\t// Try and get User data using their ID, if outside of a channel - allow it.\n\t\t\tif (platform) {\n\t\t\t\tconst userCheck = await sb.Filter.checkUser(userID, platform.name);\n\t\t\t\tif (!userCheck.success) {\n\t\t\t\t\treturn {\n\t\t\t\t\t\tsuccess: false,\n\t\t\t\t\t\treason: userCheck.reason,\n\t\t\t\t\t\treply: userCheck.reply\n\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// If specified channel does exist, check for channel-specific cooldowns\n\t\t\tif (channel && !channel.Flags.skipBanphrases && !checkOptions.skipBanphrase) {\n\t\t\t\tconst banphraseCheck = await sb.Filter.checkBanphrases(\n\t\t\t\t\t{ userID, command, platform: platform.name, channelID: channel.ID }\n\t\t\t\t);\n\t\t\t\tif (!banphraseCheck.success) {\n\t\t\t\t\treturn {\n\t\t\t\t\t\tsuccess: false,\n\t\t\t\t\t\treason: banphraseCheck.reason,\n\t\t\t\t\t\treply: banphraseCheck.reply\n\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// If bot is in read-only mode, check if the command is also applicable in this mode.\n\t\t\tif (sb.Config && sb.Config.get(\"READ_ONLY_MODE\") && !data.Flags.readOnly) {\n\t\t\t\tconst reply = sb.Config.get(\"READ_ONLY_MODE_TIMEOUT_REPLY\") ?? \"I'm currently in read-only mode, new commands will not be executed\";\n\t\t\t\treturn {\n\t\t\t\t\tsuccess: false,\n\t\t\t\t\treason: \"read-only-mode\",\n\t\t\t\t\treply\n\t\t\t\t};\n\t\t\t}\n\n\t\t\t// Check for command-specific cooldown - This is the usual case\n\t\t\tif (this.commandMap.has(command)) {\n\t\t\t\tconst date = this.commandMap.get(command);\n\t\t\t\tif (now < date) {\n\t\t\t\t\treturn {\n\t\t\t\t\t\tsuccess: false,\n\t\t\t\t\t\treason: type,\n\t\t\t\t\t\tcommand,\n\t\t\t\t\t\tremaining: Math.abs(Math.ceil((now - date) / 1000)) + 1,\n\t\t\t\t\t\treply: null\n\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Check for user-specific cooldown - should be rare\n\t\t\tif (this.userMap.has(uid)) {\n\t\t\t\tconst date = this.userMap.get(uid);\n\t\t\t\tif (now < date) {\n\t\t\t\t\treturn {\n\t\t\t\t\t\tsuccess: false,\n\t\t\t\t\t\treason: type,\n\t\t\t\t\t\tcommand: \"user\",\n\t\t\t\t\t\tremaining: Math.abs(Math.ceil((now - date) / 1000)) + 1,\n\t\t\t\t\t\treply: null\n\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Check for user-platform-command-specific cooldown\n\t\t\tconst userCommandGlobalKey = `${uid}-${command}`;\n\t\t\tif (this.userCommandGlobalMap.has(userCommandGlobalKey)) {\n\t\t\t\tconst date = this.userCommandGlobalMap.get(userCommandGlobalKey);\n\t\t\t\tif (now < date) {\n\t\t\t\t\treturn {\n\t\t\t\t\t\tsuccess: false,\n\t\t\t\t\t\treason: type,\n\t\t\t\t\t\tcommand: `${command} (your)`,\n\t\t\t\t\t\tremaining: Math.abs(Math.ceil((now - date) / 1000)) + 1,\n\t\t\t\t\t\treply: null\n\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Check for global-command-specific cooldown (limiter)\n\t\t\tif (this.globalCommandMap.has(command)) {\n\t\t\t\tconst date = this.globalCommandMap.get(command);\n\t\t\t\tif (now < date) {\n\t\t\t\t\treturn {\n\t\t\t\t\t\tsuccess: false,\n\t\t\t\t\t\treason: \"cooldown-limiter\",\n\t\t\t\t\t\tcommand,\n\t\t\t\t\t\tremaining: Math.abs(Math.ceil((now - date) / 1000)) + 1,\n\t\t\t\t\t\treply: null\n\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// If the command has a mentions limit set, check if the user is above or below it\n\t\t\tif (data.Flags.mentions && sb.AwayFromKeyboard && userID) {\n\t\t\t\tconst limit = data.Flags.mentions;\n\t\t\t\tconst check = await sb.AwayFromKeyboard.getMentionStatus(userID);\n\n\t\t\t\tif (check !== null && check >= limit) {\n\t\t\t\t\treturn {\n\t\t\t\t\t\tsuccess: false,\n\t\t\t\t\t\treason: \"afk-limit\",\n\t\t\t\t\t\tlimit,\n\t\t\t\t\t\tcommand,\n\t\t\t\t\t\tafkCount: check,\n\t\t\t\t\t\treply: null\n\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// No cooldown exists on the command, and it can be used right now\n\t\t\treturn true;\n\t\t}\n\n\t\t/**\n\t\t * Sets a command on cooldown.\n\t\t * If channel is null, a cooldown will only be set on the command directly.\n\t\t * @param {Object} options\n\t\t * @param {sb.User|number} options.userID\n\t\t * @param {string} options.command\n\t\t * @param {number} options.cooldown\n\t\t * @param {sb.Command} [options.commandData]\n\t\t * @param {sb.Channel} [options.channel]\n\t\t * @param {string} [options.source]\n\t\t * @returns {Promise<void>}\n\t\t */\n\t\tasync set (options) {\n\t\t\tconst {\n\t\t\t\tuserID, command, cooldown, commandData = null, channel = null, source = null\n\t\t\t} = options;\n\n\t\t\tconst data = commandData ?? sb.Command.get(command);\n\t\t\tif (!data) {\n\t\t\t\tconsole.error(\"non-existent command\", command);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tconst now = sb.Date.now();\n\t\t\tconst uid = String(userID);\n\n\t\t\t// Global command cooldown - Prevent the command from being used by anyone (by default: 3 seconds)\n\t\t\t// This is because of high-traffic scenarios like the Forsen chat where spamming the cooldown can happen\n\t\t\t// Can be overridden by Command flags, or the cooldown paramater\n\t\t\tif (data.Flags.cooldown) {\n\t\t\t\tthis.commandMap.set(command, now + cooldown);\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// Override the default if a cooldown time is provided\n\t\t\t\tif (cooldown) {\n\t\t\t\t\tthis.commandMap.set(command, now + cooldown);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\t// 3 seconds is a sane default to not *completely* avoid spam\n\t\t\t\t\t// but also to not annoy the user too much\n\t\t\t\t\tthis.commandMap.set(command, now + 3000);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Apply cooldown from Command flags\n\t\t\t// cooldown is calculated as: (seconds -> ms)\n\t\t\tif (data.Cooldown) {\n\t\t\t\tconst commandCooldown = now + (data.Cooldown * 1000);\n\t\t\t\tconst userCommandKey = `${uid}-${command}`;\n\n\t\t\t\t// Cooldown for any channel\n\t\t\t\tif (data.Flags.userCooldown || data.Flags.guildCooldown) {\n\t\t\t\t\tthis.userCommandGlobalMap.set(userCommandKey, commandCooldown);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (source === \"command\") {\n\t\t\t\tthis.pendingCommandMap.set(command, true);\n\t\t\t}\n\t\t}\n\n\t\t/**\n\t\t * Sets a user on cooldown.\n\t\t * @param {sb.User|number} userID\n\t\t * @param {number} cooldown\n\t\t */\n\t\tsetUser (userID, cooldown) {\n\t\t\tconst uid = String(userID);\n\t\t\tthis.userMap.set(uid, sb.Date.now() + cooldown);\n\t\t}\n\n\t\t/**\n\t\t * Unsets a pending command.\n\t\t * @param {string} command\n\t\t */\n\t\tunset (command) {\n\t\t\tif (this.pendingCommandMap.has(command)) {\n\t\t\t\tthis.pendingCommandMap.delete(command);\n\t\t\t}\n\t\t}\n\n\t\t/**\n\t\t * Sets a user on cooldown for a specific command for a specified amount of time\n\t\t * @param {sb.User|number} userID\n\t\t * @param {string} command\n\t\t * @param {number} cooldown\n\t\t * @param {string} [reason]\n\t\t */\n\t\tasync block (userID, command, cooldown, reason) {\n\t\t\tconst uid = String(userID);\n\t\t\tconst now = sb.Date.now();\n\t\t\tconst timestamp = now + cooldown;\n\t\t\tconst userCommandKey = `${uid}-${command}`;\n\t\t\tthis.userCommandGlobalMap.set(userCommandKey, timestamp);\n\n\t\t\tconst timeoutName = `${uid}:${command}:${now}`;\n\t\t\tconst timeoutFn = () => {\n\t\t\t\tthis.unblock(userID, command);\n\t\t\t\tthis.activeTimeouts.delete(timeoutName);\n\t\t\t};\n\n\t\t\t// timeout could be longer than the max delay time - 2^31 - 1 ms (~24 days)\n\t\t\tconst timeout = getLongTimeout(timeoutFn, cooldown);\n\t\t\tthis.activeTimeouts.set(timeoutName, {\n\t\t\t\ttimeout,\n\t\t\t\tfrom: now,\n\t\t\t\tto: timestamp,\n\t\t\t\treason: reason ?? null\n\t\t\t});\n\t\t}\n\n\t\t/**\n\t\t * Removes a user from a specific command cooldown\n\t\t * @param {sb.User|number} userID\n\t\t * @param {string} command\n\t\t */\n\t\tunblock (userID, command) {\n\t\t\tconst uid = String(userID);\n\t\t\tconst userCommandKey = `${uid}-${command}`;\n\t\t\tthis.userCommandGlobalMap.delete(userCommandKey);\n\n\t\t\t// Find and clear any matching timeouts\n\t\t\tfor (const [name, data] of this.activeTimeouts.entries()) {\n\t\t\t\tif (name.startsWith(`${uid}:${command}:`)) {\n\t\t\t\t\tclearTimeout(data.timeout);\n\t\t\t\t\tthis.activeTimeouts.delete(name);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t/**\n\t\t * Lists all active cooldowns for a specific user\n\t\t * @param {sb.User|number} userID\n\t\t */\n\t\tgetActiveBlocks (userID) {\n\t\t\tconst uid = String(userID);\n\t\t\tconst results = [];\n\n\t\t\tfor (const [key, timestamp] of this.userCommandGlobalMap.entries()) {\n\t\t\t\tconst [targetID, command] = key.split(\"-\");\n\t\t\t\tif (targetID === uid) {\n\t\t\t\t\t// Find any matching timeout data\n\t\t\t\t\tlet timeoutData = null;\n\t\t\t\t\tfor (const [name, data] of this.activeTimeouts.entries()) {\n\t\t\t\t\t\tif (name.startsWith(`${uid}:${command}:`)) {\n\t\t\t\t\t\t\ttimeoutData = data;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tconst now = sb.Date.now();\n\t\t\t\t\tif (timestamp > now) {\n\t\t\t\t\t\tresults.push({\n\t\t\t\t\t\t\tcommand,\n\t\t\t\t\t\t\texpiry: new sb.Date(timestamp),\n\t\t\t\t\t\t\tremainingMS: timestamp - now,\n\t\t\t\t\t\t\treason: timeoutData ? timeoutData.reason : null\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn results;\n\t\t}\n\n\t\t/**\n\t\t * Clears all command cooldowns.\n\t\t */\n\t\tclearAll () {\n\t\t\tthis.commandMap.clear();\n\t\t\tthis.pendingCommandMap.clear();\n\t\t\tthis.channelMap.clear();\n\t\t\tthis.userCommandMap.clear();\n\t\t\tthis.userCommandGlobalMap.clear();\n\t\t\tthis.globalCommandMap.clear();\n\t\t\tthis.userMap.clear();\n\t\t\tthis.userChannelCommandMap.clear();\n\n\t\t\t// Clear any active timeouts\n\t\t\tfor (const [name, data] of this.activeTimeouts.entries()) {\n\t\t\t\tclearTimeout(data.timeout);\n\t\t\t\tthis.activeTimeouts.delete(name);\n\t\t\t}\n\t\t}\n\n\t\t/**\n\t\t * Destroys the cooldown module.\n\t\t */\n\t\tstatic destroy () {\n\t\t\tthis.module = null;\n\t\t}\n\t};\n})();\n\u0005End File\u0006# singletons/internal-request/index.js\nmodule.exports = (function () {\n\t\"use strict\";\n\n\t/**\n\t * @module internal-request\n\t * @description Handles requests between Supibot instances\n\t */\n\n\tconst crypto = require(\"crypto\");\n\tconst { URL } = require(\"url\");\n\tconst Singleton = require(\"../singleton.js\");\n\tconst SecretCache = require(\"../../secret-cache.js\");\n\n\treturn class InternalRequest extends Singleton {\n\t\tstatic async initialize () {\n\t\t\tthis.module = new InternalRequest();\n\t\t\treturn this.module;\n\t\t}\n\n\t\tconstructor () {\n\t\t\tsuper();\n\t\t\tthis.requestMap = new Map();\n\t\t\tthis.requestExpiration = 60_000;\n\t\t\tthis.initialized = false;\n\t\t\tthis.secretKey = null;\n\t\t}\n\n\t\t/**\n\t\t * @returns {Promise<void>}\n\t\t */\n\t\tasync loadSecretKey () {\n\t\t\ttry {\n\t\t\t\tconst key = await SecretCache.get(\"InternalRequestKey\");\n\t\t\t\tif (!key) {\n\t\t\t\t\tthrow new Error(\"No internal request key found\");\n\t\t\t\t}\n\n\t\t\t\tthis.secretKey = key;\n\t\t\t\tthis.initialized = true;\n\t\t\t}\n\t\t\tcatch (e) {\n\t\t\t\tconsole.warn(\"Failed to load internal request key\", e);\n\t\t\t}\n\t\t}\n\n\t\t/**\n\t\t * @param {Object} data\n\t\t * @returns {Promise<Object>}\n\t\t */\n\t\tasync createRequest (data) {\n\t\t\tif (!this.initialized) {\n\t\t\t\tawait this.loadSecretKey();\n\t\t\t}\n\n\t\t\tconst id = crypto.randomBytes(16).toString(\"hex\");\n\t\t\tconst timestamp = Date.now();\n\t\t\tconst hmacData = `${id}:${timestamp}`;\n\t\t\tconst hmac = crypto.createHmac(\"sha256\", this.secretKey.secret)\n\t\t\t\t.update(hmacData)\n\t\t\t\t.digest(\"hex\");\n\n\t\t\tthis.requestMap.set(id, {\n\t\t\t\tid,\n\t\t\t\ttimestamp,\n\t\t\t\thmac,\n\t\t\t\tdata,\n\t\t\t\tstatus: \"pending\"\n\t\t\t});\n\n\t\t\t// Auto-expire after timeout\n\t\t\tsetTimeout(() => {\n\t\t\t\tif (this.requestMap.has(id) && this.requestMap.get(id).status === \"pending\") {\n\t\t\t\t\tthis.requestMap.get(id).status = \"expired\";\n\t\t\t\t}\n\t\t\t}, this.requestExpiration);\n\n\t\t\treturn {\n\t\t\t\tid,\n\t\t\t\ttimestamp,\n\t\t\t\thmac\n\t\t\t};\n\t\t}\n\n\t\t/**\n\t\t * @param {string} id\n\t\t * @returns {Object|null}\n\t\t */\n\t\tgetRequest (id) {\n\t\t\tif (!this.requestMap.has(id)) {\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\tconst request = this.requestMap.get(id);\n\t\t\tif (request.status !== \"pending\") {\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\treturn request;\n\t\t}\n\n\t\t/**\n\t\t * @param {string} id\n\t\t * @param {string} status\n\t\t * @param {*} result\n\t\t * @returns {boolean}\n\t\t */\n\t\tsetRequestStatus (id, status, result = null) {\n\t\t\tif (!this.requestMap.has(id)) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\tconst request = this.requestMap.get(id);\n\t\t\trequest.status = status;\n\t\t\trequest.result = result;\n\t\t\treturn true;\n\t\t}\n\n\t\t/**\n\t\t * @param {string} id\n\t\t * @param {string} hmac\n\t\t * @returns {boolean}\n\t\t */\n\t\tvalidateRequest (id, hmac) {\n\t\t\tif (!this.initialized) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\tif (!this.requestMap.has(id)) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\tconst request = this.requestMap.get(id);\n\t\t\tif (request.status !== \"pending\") {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\tif (request.hmac !== hmac) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\t// Check if expired\n\t\t\tif (Date.now() - request.timestamp > this.requestExpiration) {\n\t\t\t\trequest.status = \"expired\";\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\treturn true;\n\t\t}\n\n\t\t/**\n\t\t * @param {string} targetURL URL to invoke the command on\n\t\t * @param {Object} data Request payload\n\t\t * @returns {Promise<Object>}\n\t\t */\n\t\tasync send (targetURL, data) {\n\t\t\tif (!this.initialized) {\n\t\t\t\tawait this.loadSecretKey();\n\t\t\t}\n\n\t\t\t// 1. Get authentication tokens from the target\n\t\t\tconst parsedURL = new URL(targetURL);\n\t\t\tconst auth = await this.createRequest(data);\n\n\t\t\t// 2. Send the command to the target system\n\t\t\tconst response = await fetch(targetURL, {\n\t\t\t\tmethod: \"POST\",\n\t\t\t\theaders: {\n\t\t\t\t\t\"Content-Type\": \"application/json\"\n\t\t\t\t},\n\t\t\t\tbody: JSON.stringify({\n\t\t\t\t\tid: auth.id,\n\t\t\t\t\thmac: auth.hmac,\n\t\t\t\t\ttimestamp: auth.timestamp,\n\t\t\t\t\t...data\n\t\t\t\t})\n\t\t\t});\n\n\t\t\t// 3. Process the response\n\t\t\tconst result = await response.json();\n\t\t\treturn result;\n\t\t}\n\n\t\t/**\n\t\t * @param {string} id\n\t\t * @returns {Promise<Object|null>}\n\t\t */\n\t\tasync waitForResponse (id) {\n\t\t\treturn new Promise((resolve) => {\n\t\t\t\tconst checkInterval = 100;\n\t\t\t\tconst maxChecks = this.requestExpiration / checkInterval;\n\t\t\t\tlet checks = 0;\n\n\t\t\t\tconst check = () => {\n\t\t\t\t\tif (!this.requestMap.has(id)) {\n\t\t\t\t\t\tresolve(null);\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\n\t\t\t\t\tconst request = this.requestMap.get(id);\n\t\t\t\t\tif (request.status === \"completed\") {\n\t\t\t\t\t\tresolve(request.result);\n\t\t\t\t\t}\n\t\t\t\t\telse if (request.status === \"expired\" || request.status === \"failed\") {\n\t\t\t\t\t\tresolve(null);\n\t\t\t\t\t}\n\t\t\t\t\telse if (checks >= maxChecks) {\n\t\t\t\t\t\tthis.setRequestStatus(id, \"expired\");\n\t\t\t\t\t\tresolve(null);\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tchecks++;\n\t\t\t\t\t\tsetTimeout(check, checkInterval);\n\t\t\t\t\t}\n\t\t\t\t};\n\n\t\t\t\tcheck();\n\t\t\t});\n\t\t}\n\n\t\t/**\n\t\t * @param {Object} req\n\t\t * @returns {Promise<boolean>}\n\t\t */\n\t\tasync authenticate (req) {\n\t\t\tif (!this.initialized) {\n\t\t\t\tawait this.loadSecretKey();\n\t\t\t}\n\n\t\t\tconst { id, hmac, timestamp } = req.body;\n\t\t\tif (!id || !hmac || !timestamp) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\t// Verify the timestamp is recent\n\t\t\tconst now = Date.now();\n\t\t\tif (now - timestamp > this.requestExpiration) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\t// Verify the HMAC\n\t\t\tconst hmacData = `${id}:${timestamp}`;\n\t\t\tconst calculatedHmac = crypto.createHmac(\"sha256\", this.secretKey.secret)\n\t\t\t\t.update(hmacData)\n\t\t\t\t.digest(\"hex\");\n\n\t\t\treturn calculatedHmac === hmac;\n\t\t}\n\n\t\tstatic async destroy () {\n\t\t\tthis.module = null;\n\t\t}\n\t};\n})();\n\u0005End File\u0006# Supinic/supibot\nmodule.exports = (function () {\n\t\"use strict\";\n\n\t/**\n\t * @module command-queue\n\t * @description Handling queued invocations of commands, e.g. from a chat message containing a playlist\n\t */\n\n\tconst Singleton = require(\"../singleton.js\");\n\tconst EventEmitter = require(\"events\");\n\n\t/**\n\t * @class CommandQueue\n\t * @description CommandQueue singleton class\n\t */\n\treturn class CommandQueue extends Singleton {\n\t\t/**\n\t\t * @returns {Promise<CommandQueue>}\n\t\t */\n\t\tstatic async initialize () {\n\t\t\tconst instance = new CommandQueueSingleton();\n\t\t\treturn instance;\n\t\t}\n\n\t\t/**\n\t\t * @returns {void}\n\t\t */\n\t\tstatic destroy () {\n\t\t\tthis.module = null;\n\t\t}\n\t};\n\n\t/**\n\t * @typedef CommandQueueItem\n\t * @property {string} command\n\t * @property {string[]} args\n\t * @property {string} platform\n\t * @property {string} channel\n\t * @property {number} user\n\t * @property {string} data.invocation\n\t * @property {number} index\n\t * @property {number} total\n\t */\n\n\t/**\n\t * @class CommandQueueSingleton\n\t * @description The actual queue implementation\n\t */\n\tclass CommandQueueSingleton extends EventEmitter {\n\t\tconstructor () {\n\t\t\tsuper();\n\t\t\tthis.queue = {};\n\t\t}\n\n\t\t/**\n\t\t * Creates a new queue or adds items to an existing queue\n\t\t * @param {Object} data\n\t\t * @param {string} data.userID\n\t\t * @param {CommandQueueItem[]} data.items\n\t\t * @param {string} [data.queueID] If provided, items will be added to an existing queue\n\t\t * @returns {string} Queue ID\n\t\t */\n\t\tadd (data) {\n\t\t\tif (!data?.userID || !data?.items || !Array.isArray(data.items) || data.items.length === 0) {\n\t\t\t\tthrow new Error(\"Invalid queue data\");\n\t\t\t}\n\n\t\t\t// If a queue ID is provided, add to that queue if it exists\n\t\t\tif (data.queueID && this.queue[data.queueID]) {\n\t\t\t\tconst queueID = data.queueID;\n\t\t\t\tconst { total } = this.queue[queueID];\n\t\t\t\tconst offset = total;\n\t\t\t\tconst items = data.items.map((item, i) => ({\n\t\t\t\t\t...item,\n\t\t\t\t\tindex: offset + i,\n\t\t\t\t\ttotal: offset + data.items.length\n\t\t\t\t}));\n\n\t\t\t\tthis.queue[queueID].items.push(...items);\n\t\t\t\tthis.queue[queueID].total += data.items.length;\n\n\t\t\t\t// Emit event for each new item\n\t\t\t\tfor (const item of items) {\n\t\t\t\t\tthis.emit(\"add\", {\n\t\t\t\t\t\tqueueID,\n\t\t\t\t\t\titem\n\t\t\t\t\t});\n\t\t\t\t}\n\n\t\t\t\treturn queueID;\n\t\t\t}\n\n\t\t\t// Otherwise create a new queue\n\t\t\tconst queueID = this.generateQueueID();\n\t\t\tconst mappedItems = data.items.map((item, i) => ({\n\t\t\t\t...item,\n\t\t\t\tindex: i,\n\t\t\t\ttotal: data.items.length\n\t\t\t}));\n\n\t\t\tthis.queue[queueID] = {\n\t\t\t\tuserID: data.userID,\n\t\t\t\titems: mappedItems,\n\t\t\t\ttotal: data.items.length,\n\t\t\t\tcreatedAt: Date.now()\n\t\t\t};\n\n\t\t\t// Emit event for each item\n\t\t\tfor (const item of mappedItems) {\n\t\t\t\tthis.emit(\"add\", {\n\t\t\t\t\tqueueID,\n\t\t\t\t\titem\n\t\t\t\t});\n\t\t\t}\n\n\t\t\t// Set automatic expiration\n\t\t\tsetTimeout(() => {\n\t\t\t\tif (this.queue[queueID]) {\n\t\t\t\t\tthis.remove(queueID);\n\t\t\t\t}\n\t\t\t}, 1000 * 60 * 60); // 1 hour\n\n\t\t\treturn queueID;\n\t\t}\n\n\t\t/**\n\t\t * Removes a queue by ID\n\t\t * @param {string} queueID\n\t\t * @returns {boolean} Whether the queue existed and was removed\n\t\t */\n\t\tremove (queueID) {\n\t\t\tif (!this.queue[queueID]) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\tthis.emit(\"remove\", {\n\t\t\t\tqueueID,\n\t\t\t\tqueue: this.queue[queueID]\n\t\t\t});\n\n\t\t\tdelete this.queue[queueID];\n\t\t\treturn true;\n\t\t}\n\n\t\t/**\n\t\t * Gets a queue by ID\n\t\t * @param {string} queueID\n\t\t * @returns {Object|null} Queue or null if not found\n\t\t */\n\t\tget (queueID) {\n\t\t\treturn this.queue[queueID] || null;\n\t\t}\n\n\t\t/**\n\t\t * Gets all queues by user ID\n\t\t * @param {string} userID\n\t\t * @returns {Object} Object of { queueID: queueData }\n\t\t */\n\t\tgetByUser (userID) {\n\t\t\tconst result = {};\n\t\t\tfor (const [id, queue] of Object.entries(this.queue)) {\n\t\t\t\tif (queue.userID === userID) {\n\t\t\t\t\tresult[id] = queue;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn result;\n\t\t}\n\n\t\t/**\n\t\t * Processes the next item in a queue\n\t\t * @param {string} queueID\n\t\t * @returns {CommandQueueItem|null} The item that was processed, or null if queue is empty\n\t\t */\n\t\tprocessNext (queueID) {\n\t\t\tif (!this.queue[queueID] || this.queue[queueID].items.length === 0) {\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\tconst item = this.queue[queueID].items.shift();\n\t\t\tthis.emit(\"process\", {\n\t\t\t\tqueueID,\n\t\t\t\titem\n\t\t\t});\n\n\t\t\t// If queue is now empty, remove it\n\t\t\tif (this.queue[queueID].items.length === 0) {\n\t\t\t\tthis.remove(queueID);\n\t\t\t}\n\n\t\t\treturn item;\n\t\t}\n\n\t\t/**\n\t\t * Generates a unique queue ID\n\t\t * @returns {string}\n\t\t */\n\t\tgenerateQueueID () {\n\t\t\tconst characters = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789\";\n\t\t\tlet id;\n\n\t\t\tdo {\n\t\t\t\tid = \"\";\n\t\t\t\tfor (let i = 0; i < 10; i++) {\n\t\t\t\t\tid += characters.charAt(Math.floor(Math.random() * characters.length));\n\t\t\t\t}\n\t\t\t} while (this.queue[id]);\n\n\t\t\treturn id;\n\t\t}\n\n\t\t/**\n\t\t * Clears all queues\n\t\t */\n\t\tclear () {\n\t\t\tfor (const queueID of Object.keys(this.queue)) {\n\t\t\t\tthis.remove(queueID);\n\t\t\t}\n\t\t}\n\t}\n})();\n\u0005End File\u0006module.exports = (function () {\n\t\"use strict\";\n\n\tconst crypto = require(\"crypto\");\n\tconst WebSocket = require(\"ws\");\n\tconst Singleton = require(\"../singleton.js\");\n\n\tclass WebsocketManager extends Singleton {\n\t\tconstructor () {\n\t\t\tsuper();\n\t\t\tthis.clients = new Map();\n\t\t\tthis.clientsByChannel = new Map();\n\t\t\tthis.authenticatedClients = new Map();\n\t\t\tthis.ignoredMessageTypes = [\"ping\", \"pong\"];\n\t\t\tthis.logStatus = false;\n\t\t\tthis.server = null;\n\t\t}\n\n\t\t/**\n\t\t * Sets up the WebSocket server\n\t\t * @param {Object} options\n\t\t * @param {number} options.port Port to use for the WebSocket server\n\t\t * @param {boolean} [options.keepAlive] Whether to use keep-alive pings\n\t\t * @param {number} [options.keepAliveInterval] Interval between keep-alive pings in ms\n\t\t * @param {boolean} [options.logStatus] Whether to log status changes\n\t\t * @returns {Promise<void>}\n\t\t */\n\t\tasync setupServer (options) {\n\t\t\tif (this.server) {\n\t\t\t\tthrow new Error(\"WebSocket server already exists\");\n\t\t\t}\n\n\t\t\t// Create server\n\t\t\tconst wss = new WebSocket.Server({ port: options.port });\n\t\t\tthis.server = wss;\n\t\t\tthis.logStatus = options.logStatus ?? false;\n\t\t\tthis.logger = (msg) => (this.logStatus) ? console.log(msg) : null;\n\n\t\t\t// Set up connection handler\n\t\t\twss.on(\"connection\", (ws, req) => {\n\t\t\t\ttry {\n\t\t\t\t\tthis.handleConnection(ws, req);\n\t\t\t\t}\n\t\t\t\tcatch (err) {\n\t\t\t\t\tconsole.error(\"WebSocket connection error:\", err);\n\t\t\t\t}\n\t\t\t});\n\n\t\t\t// Set up keep-alive if needed\n\t\t\tif (options.keepAlive) {\n\t\t\t\tconst interval = options.keepAliveInterval ?? 30000;\n\t\t\t\tsetInterval(() => {\n\t\t\t\t\twss.clients.forEach((client) => {\n\t\t\t\t\t\tif (client.readyState === WebSocket.OPEN) {\n\t\t\t\t\t\t\tclient.ping();\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t}, interval);\n\t\t\t}\n\n\t\t\tconsole.log(`WebSocket server started on port ${options.port}`);\n\t\t}\n\n\t\t/**\n\t\t * Handles a new WebSocket connection\n\t\t * @param {WebSocket} ws WebSocket client\n\t\t * @param {Object} req HTTP request\n\t\t */\n\t\thandleConnection (ws, req) {\n\t\t\t// Generate a unique ID for this client\n\t\t\tconst clientID = crypto.randomUUID();\n\t\t\tws.clientID = clientID;\n\t\t\tws.subscriptions = new Set();\n\t\t\tws.authenticated = false;\n\n\t\t\t// Store client\n\t\t\tthis.clients.set(clientID, ws);\n\t\t\tthis.logger(`Client connected: ${clientID}`);\n\n\t\t\t// Connection info\n\t\t\tif (req.socket.remoteAddress) {\n\t\t\t\tws.remoteAddress = req.socket.remoteAddress;\n\t\t\t}\n\n\t\t\t// Set up message handler\n\t\t\tws.on(\"message\", (message) => {\n\t\t\t\ttry {\n\t\t\t\t\tthis.handleMessage(ws, message);\n\t\t\t\t}\n\t\t\t\tcatch (err) {\n\t\t\t\t\tconsole.error(\"WebSocket message error:\", err);\n\t\t\t\t\tws.send(JSON.stringify({\n\t\t\t\t\t\ttype: \"error\",\n\t\t\t\t\t\terror: \"Internal server error processing message\"\n\t\t\t\t\t}));\n\t\t\t\t}\n\t\t\t});\n\n\t\t\t// Set up close handler\n\t\t\tws.on(\"close\", () => {\n\t\t\t\tthis.handleClose(ws);\n\t\t\t});\n\n\t\t\t// Initial welcome message\n\t\t\tws.send(JSON.stringify({\n\t\t\t\ttype: \"welcome\",\n\t\t\t\tclientID\n\t\t\t}));\n\t\t}\n\n\t\t/**\n\t\t * Handles a message from a WebSocket client\n\t\t * @param {WebSocket} ws WebSocket client\n\t\t * @param {string|Buffer} message Message received\n\t\t */\n\t\thandleMessage (ws, message) {\n\t\t\tlet data;\n\t\t\ttry {\n\t\t\t\tdata = JSON.parse(message);\n\t\t\t}\n\t\t\tcatch (err) {\n\t\t\t\tws.send(JSON.stringify({\n\t\t\t\t\ttype: \"error\",\n\t\t\t\t\terror: \"Invalid JSON\"\n\t\t\t\t}));\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Ignore certain message types\n\t\t\tif (this.ignoredMessageTypes.includes(data.type)) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Handle authentication\n\t\t\tif (data.type === \"authenticate\") {\n\t\t\t\tthis.handleAuthentication(ws, data);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Handle subscription\n\t\t\tif (data.type === \"subscribe\") {\n\t\t\t\tthis.handleSubscription(ws, data);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Handle unsubscription\n\t\t\tif (data.type === \"unsubscribe\") {\n\t\t\t\tthis.handleUnsubscription(ws, data);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Handle command execution (requires authentication)\n\t\t\tif (data.type === \"command\") {\n\t\t\t\tthis.handleCommand(ws, data);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Unknown message type\n\t\t\tws.send(JSON.stringify({\n\t\t\t\ttype: \"error\",\n\t\t\t\terror: `Unknown message type: ${data.type}`\n\t\t\t}));\n\t\t}\n\n\t\t/**\n\t\t * Handles a client disconnection\n\t\t * @param {WebSocket} ws WebSocket client\n\t\t */\n\t\thandleClose (ws) {\n\t\t\t// Remove from clients map\n\t\t\tthis.clients.delete(ws.clientID);\n\t\t\tthis.logger(`Client disconnected: ${ws.clientID}`);\n\n\t\t\t// Remove authentication if authenticated\n\t\t\tif (ws.authenticated) {\n\t\t\t\tthis.authenticatedClients.delete(ws.userID);\n\t\t\t}\n\n\t\t\t// Remove from all channel subscriptions\n\t\t\tfor (const channel of ws.subscriptions) {\n\t\t\t\tconst channelClients = this.clientsByChannel.get(channel);\n\t\t\t\tif (channelClients) {\n\t\t\t\t\tchannelClients.delete(ws.clientID);\n\t\t\t\t\tif (channelClients.size === 0) {\n\t\t\t\t\t\tthis.clientsByChannel.delete(channel);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t/**\n\t\t * Handles client authentication\n\t\t * @param {WebSocket} ws WebSocket client\n\t\t * @param {Object} data Authentication data\n\t\t */\n\t\tasync handleAuthentication (ws, data) {\n\t\t\t// Check for token\n\t\t\tif (!data.token) {\n\t\t\t\tws.send(JSON.stringify({\n\t\t\t\t\ttype: \"error\",\n\t\t\t\t\terror: \"Authentication requires a token\"\n\t\t\t\t}));\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\t// Verify token (implement your token verification logic here)\n\t\t\t\tconst userID = await this.verifyToken(data.token);\n\t\t\t\tif (!userID) {\n\t\t\t\t\tws.send(JSON.stringify({\n\t\t\t\t\t\ttype: \"auth_fail\",\n\t\t\t\t\t\terror: \"Invalid authentication token\"\n\t\t\t\t\t}));\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\t// Set as authenticated\n\t\t\t\tws.authenticated = true;\n\t\t\t\tws.userID = userID;\n\t\t\t\tthis.authenticatedClients.set(userID, ws);\n\n\t\t\t\tws.send(JSON.stringify({\n\t\t\t\t\ttype: \"auth_success\",\n\t\t\t\t\tuserID\n\t\t\t\t}));\n\t\t\t}\n\t\t\tcatch (err) {\n\t\t\t\tconsole.error(\"Authentication error:\", err);\n\t\t\t\tws.send(JSON.stringify({\n\t\t\t\t\ttype: \"auth_fail\",\n\t\t\t\t\terror: \"Authentication failed\"\n\t\t\t\t}));\n\t\t\t}\n\t\t}\n\n\t\t/**\n\t\t * Verifies an authentication token\n\t\t * @param {string} token Authentication token\n\t\t * @returns {Promise<string|null>} User ID if valid, null otherwise\n\t\t */\n\t\tasync verifyToken (token) {\n\t\t\t// This is a placeholder. Implement your actual token verification logic here.\n\t\t\t// You should verify the token and return the associated user ID if valid.\n\t\t\tif (sb.User && sb.User.getByToken) {\n\t\t\t\ttry {\n\t\t\t\t\tconst userData = await sb.User.getByToken(token);\n\t\t\t\t\treturn userData ? String(userData.ID) : null;\n\t\t\t\t}\n\t\t\t\tcatch (err) {\n\t\t\t\t\tconsole.error(\"Token verification error:\", err);\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn null;\n\t\t}\n\n\t\t/**\n\t\t * Handles a subscription request\n\t\t * @param {WebSocket} ws WebSocket client\n\t\t * @param {Object} data Subscription data\n\t\t */\n\t\thandleSubscription (ws, data) {\n\t\t\t// Validate channel\n\t\t\tif (!data.channel) {\n\t\t\t\tws.send(JSON.stringify({\n\t\t\t\t\ttype: \"error\",\n\t\t\t\t\terror: \"Subscription requires a channel\"\n\t\t\t\t}));\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tconst channel = data.channel;\n\n\t\t\t// Add client to channel\n\t\t\tif (!this.clientsByChannel.has(channel)) {\n\t\t\t\tthis.clientsByChannel.set(channel, new Map());\n\t\t\t}\n\t\t\tthis.clientsByChannel.get(channel).set(ws.clientID, ws);\n\n\t\t\t// Add channel to client's subscriptions\n\t\t\tws.subscriptions.add(channel);\n\n\t\t\tws.send(JSON.stringify({\n\t\t\t\ttype: \"subscribed\",\n\t\t\t\tchannel\n\t\t\t}));\n\t\t}\n\n\t\t/**\n\t\t * Handles an unsubscription request\n\t\t * @param {WebSocket} ws WebSocket client\n\t\t * @param {Object} data Unsubscription data\n\t\t */\n\t\thandleUnsubscription (ws, data) {\n\t\t\t// Validate channel\n\t\t\tif (!data.channel) {\n\t\t\t\tws.send(JSON.stringify({\n\t\t\t\t\ttype: \"error\",\n\t\t\t\t\terror: \"Unsubscription requires a channel\"\n\t\t\t\t}));\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tconst channel = data.channel;\n\n\t\t\t// Remove client from channel\n\t\t\tif (this.clientsByChannel.has(channel)) {\n\t\t\t\tthis.clientsByChannel.get(channel).delete(ws.clientID);\n\t\t\t\tif (this.clientsByChannel.get(channel).size === 0) {\n\t\t\t\t\tthis.clientsByChannel.delete(channel);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Remove channel from client's subscriptions\n\t\t\tws.subscriptions.delete(channel);\n\n\t\t\tws.send(JSON.stringify({\n\t\t\t\ttype: \"unsubscribed\",\n\t\t\t\tchannel\n\t\t\t}));\n\t\t}\n\n\t\t/**\n\t\t * Handles a command execution request\n\t\t * @param {WebSocket} ws WebSocket client\n\t\t * @param {Object} data Command data\n\t\t */\n\t\thandleCommand (ws, data) {\n\t\t\t// Require authentication for commands\n\t\t\tif (!ws.authenticated) {\n\t\t\t\tws.send(JSON.stringify({\n\t\t\t\t\ttype: \"error\",\n\t\t\t\t\terror: \"Authentication required for command execution\"\n\t\t\t\t}));\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Validate command\n\t\t\tif (!data.command) {\n\t\t\t\tws.send(JSON.stringify({\n\t\t\t\t\ttype: \"error\",\n\t\t\t\t\terror: \"Command execution requires a command name\"\n\t\t\t\t}));\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Execute command (implement your command execution logic here)\n\t\t\tthis.executeCommand(ws, data.command, data.args || {})\n\t\t\t\t.then(result => {\n\t\t\t\t\tws.send(JSON.stringify({\n\t\t\t\t\t\ttype: \"command_result\",\n\t\t\t\t\t\tcommand: data.command,\n\t\t\t\t\t\tresult\n\t\t\t\t\t}));\n\t\t\t\t})\n\t\t\t\t.catch(err => {\n\t\t\t\t\tws.send(JSON.stringify({\n\t\t\t\t\t\ttype: \"command_error\",\n\t\t\t\t\t\tcommand: data.command,\n\t\t\t\t\t\terror: err.message || \"Command execution failed\"\n\t\t\t\t\t}));\n\t\t\t\t});\n\t\t}\n\n\t\t/**\n\t\t * Executes a command\n\t\t * @param {WebSocket} ws WebSocket client\n\t\t * @param {string} command Command name\n\t\t * @param {Object} args Command arguments\n\t\t * @returns {Promise<Object>} Command result\n\t\t */\n\t\tasync executeCommand (ws, command, args) {\n\t\t\t// This is a placeholder. Implement your actual command execution logic here.\n\t\t\t// For example, you might route this to a command handler system.\n\t\t\tthrow new Error(\"Command execution not implemented\");\n\t\t}\n\n\t\t/**\n\t\t * Broadcasts a message to all subscribed clients\n\t\t * @param {string} channel Channel to broadcast to\n\t\t * @param {Object} message Message to broadcast\n\t\t */\n\t\tbroadcast (channel, message) {\n\t\t\tif (!this.clientsByChannel.has(channel)) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tconst channelClients = this.clientsByChannel.get(channel);\n\t\t\tconst messageString = JSON.stringify({\n\t\t\t\ttype: \"broadcast\",\n\t\t\t\tchannel,\n\t\t\t\tdata: message\n\t\t\t});\n\n\t\t\tfor (const [, client] of channelClients) {\n\t\t\t\tif (client.readyState === WebSocket.OPEN) {\n\t\t\t\t\tclient.send(messageString);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t/**\n\t\t * Sends a direct message to a specific client\n\t\t * @param {string} clientID Client ID to send to\n\t\t * @param {Object} message Message to send\n\t\t * @returns {boolean} Whether the message was sent\n\t\t */\n\t\tsendToClient (clientID, message) {\n\t\t\tif (!this.clients.has(clientID)) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\tconst client = this.clients.get(clientID);\n\t\t\tif (client.readyState !== WebSocket.OPEN) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\tclient.send(JSON.stringify({\n\t\t\t\ttype: \"direct\",\n\t\t\t\tdata: message\n\t\t\t}));\n\t\t\treturn true;\n\t\t}\n\n\t\t/**\n\t\t * Sends a message to a specific user by user ID\n\t\t * @param {string} userID User ID to send to\n\t\t * @param {Object} message Message to send\n\t\t * @returns {boolean} Whether the message was sent\n\t\t */\n\t\tsendToUser (userID, message) {\n\t\t\tif (!this.authenticatedClients.has(userID)) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\tconst client = this.authenticatedClients.get(userID);\n\t\t\tif (client.readyState !== WebSocket.OPEN) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\tclient.send(JSON.stringify({\n\t\t\t\ttype: \"direct\",\n\t\t\t\tdata: message\n\t\t\t}));\n\t\t\treturn true;\n\t\t}\n\n\t\t/**\n\t\t * Gets statistics about the WebSocket server\n\t\t * @returns {Object} Statistics\n\t\t */\n\t\tgetStats () {\n\t\t\treturn {\n\t\t\t\ttotalClients: this.clients.size,\n\t\t\t\tauthenticatedClients: this.authenticatedClients.size,\n\t\t\t\tchannels: Array.from(this.clientsByChannel.keys()),\n\t\t\t\tchannelCounts: Array.from(this.clientsByChannel.entries()).map(([channel, clients]) => ({\n\t\t\t\t\tchannel,\n\t\t\t\t\tcount: clients.size\n\t\t\t\t}))\n\t\t\t};\n\t\t}\n\n\t\t/**\n\t\t * Closes the WebSocket server\n\t\t */\n\t\tclose () {\n\t\t\tif (this.server) {\n\t\t\t\tthis.server.close();\n\t\t\t\tthis.server = null;\n\t\t\t\tthis.clients.clear();\n\t\t\t\tthis.clientsByChannel.clear();\n\t\t\t\tthis.authenticatedClients.clear();\n\t\t\t\tconsole.log(\"WebSocket server closed\");\n\t\t\t}\n\t\t}\n\n\t\t/**\n\t\t * Initializes the WebSocket manager\n\t\t * @param {Object} [options] Configuration options\n\t\t * @param {number} [options.port=8080] Port to use for the WebSocket server\n\t\t * @param {boolean} [options.keepAlive=true] Whether to use keep-alive pings\n\t\t * @param {number} [options.keepAliveInterval=30000] Interval between keep-alive pings in ms\n\t\t * @param {boolean} [options.logStatus=false] Whether to log status changes\n\t\t * @returns {Promise<WebsocketManager>}\n\t\t */\n\t\tstatic async initialize (options = {}) {\n\t\t\tconst manager = new WebsocketManager();\n\n\t\t\t// Only set up the server if port is provided\n\t\t\tif (options.port) {\n\t\t\t\tawait manager.setupServer({\n\t\t\t\t\tport: options.port,\n\t\t\t\t\tkeepAlive: options.keepAlive ?? true,\n\t\t\t\t\tkeepAliveInterval: options.keepAliveInterval ?? 30000,\n\t\t\t\t\tlogStatus: options.logStatus ?? false\n\t\t\t\t});\n\t\t\t}\n\n\t\t\treturn manager;\n\t\t}\n\n\t\t/**\n\t\t * Destroys the WebSocket manager\n\t\t */\n\t\tstatic destroy () {\n\t\t\tif (this.module) {\n\t\t\t\tthis.module.close();\n\t\t\t\tthis.module = null;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn WebsocketManager;\n})();\n\u0005End File\u0006module.exports = (function () {\n\t\"use strict\";\n\n\t/**\n\t * @module system-log\n\t * @description Logs system events to the database\n\t */\n\n\tconst Singleton = require(\"../singleton.js\");\n\tconst PlatformIconData = require(\"../../data/twitch-emotes.js\");\n\n\tclass SystemLog extends Singleton {\n\t\t/**\n\t\t * @param {string} type\n\t\t * @returns {string|null}\n\t\t */\n\t\tstatic getPlatformIcon (type) {\n\t\t\tif (PlatformIconData[type]) {\n\t\t\t\treturn PlatformIconData[type];\n\t\t\t}\n\t\t\treturn null;\n\t\t}\n\n\t\t/**\n\t\t * Initializes the system logger\n\t\t * @returns {Promise<SystemLog>}\n\t\t */\n\t\tstatic async initialize () {\n\t\t\tthis.module = new SystemLog();\n\t\t\treturn this.module;\n\t\t}\n\n\t\tconstructor () {\n\t\t\tsuper();\n\t\t\tthis.channelDataCache = new Map();\n\t\t\tthis.channelEmojiCache = new Map();\n\t\t}\n\n\t\t/**\n\t\t * @param {Object} options\n\t\t * @param {string} options.type\n\t\t * @param {string} options.message\n\t\t * @param {number} [options.channelID]\n\t\t * @param {string} [options.platformName]\n\t\t * @param {number} [options.userID]\n\t\t * @returns {Promise<boolean>}\n\t\t */\n\t\tasync log (options) {\n\t\t\tconst { type, message, channelID = null, platformName = null, userID = null } = options;\n\n\t\t\tif (!sb.Query) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\t// Create the system log entry\n\t\t\tconst row = await sb.Query.getRow(\"chat_data\", \"System_Log\");\n\t\t\trow.setValues({\n\t\t\t\tUser_Alias: userID,\n\t\t\t\tChannel: channelID,\n\t\t\t\tPlatform: platformName,\n\t\t\t\tType: type,\n\t\t\t\tText: message,\n\t\t\t\tTimestamp: new Date()\n\t\t\t});\n\n\t\t\tawait row.save();\n\t\t\treturn true;\n\t\t}\n\n\t\t/**\n\t\t * @param {Object} options\n\t\t * @param {string} options.event\n\t\t * @param {Object} options.data\n\t\t * @returns {Promise<boolean>}\n\t\t */\n\t\tasync logUserEvent (options) {\n\t\t\tconst { event, data } = options;\n\t\t\tif (!event || !data) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\tconst payload = JSON.stringify(data);\n\t\t\ttry {\n\t\t\t\tconst row = await sb.Query.getRow(\"chat_data\", \"User_Event_Log\");\n\t\t\t\trow.setValues({\n\t\t\t\t\tEvent: event,\n\t\t\t\t\tUser_Alias: data.userID ?? null,\n\t\t\t\t\tData: payload,\n\t\t\t\t\tTimestamp: new Date()\n\t\t\t\t});\n\t\t\t\tawait row.save();\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\tcatch (e) {\n\t\t\t\tconsole.error(\"Error logging user event\", e);\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\n\t\t/**\n\t\t * Logs a user message to the specified Discord channel\n\t\t * @param {Object} options\n\t\t * @param {string} options.message\n\t\t * @param {string} options.type\n\t\t * @param {Object} options.user\n\t\t * @param {Object} options.channel\n\t\t * @param {Object} options.platform\n\t\t * @returns {Promise<boolean>}\n\t\t */\n\t\tasync sendDiscordUserMessage (options) {\n\t\t\tconst { message, type, user, channel, platform } = options;\n\t\t\ttry {\n\t\t\t\t// If user doesn't exist, don't log\n\t\t\t\tif (!user) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\n\t\t\t\tconst channelString = channel ? `${channel.Name} (${channel.ID})` : \"Private messages\";\n\t\t\t\tlet platformIcon = SystemLog.getPlatformIcon(platform.Name);\n\t\t\t\tif (!platformIcon) {\n\t\t\t\t\tplatformIcon = \"\";\n\t\t\t\t}\n\n\t\t\t\tconst embed = {\n\t\t\t\t\ttitle: `${platformIcon} New ${type} in ${channelString}:`,\n\t\t\t\t\tdescription: message,\n\t\t\t\t\tcolor: 0x4CAF50,\n\t\t\t\t\tfooter: {\n\t\t\t\t\t\ttext: `${user.Name} (ID ${user.ID})`\n\t\t\t\t\t}\n\t\t\t\t};\n\n\t\t\t\tconst key = `${platform.Name}-${channel?.ID ?? \"PM\"}`;\n\t\t\t\tif (!this.channelEmojiCache.has(key)) {\n\t\t\t\t\tthis.channelEmojiCache.set(key, platformIcon);\n\t\t\t\t}\n\n\t\t\t\t// Get the correct webhook URL from the config\n\t\t\t\tlet webhookURL = null;\n\t\t\t\tif (sb.Config) {\n\t\t\t\t\tconst configKey = \"SYSTEM_LOG_DISCORD_WEBHOOK\";\n\t\t\t\t\twebhookURL = await sb.Config.get(configKey);\n\t\t\t\t}\n\n\t\t\t\tif (!webhookURL) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\n\t\t\t\t// Send the webhook message\n\t\t\t\tawait fetch(webhookURL, {\n\t\t\t\t\tmethod: \"POST\",\n\t\t\t\t\theaders: {\n\t\t\t\t\t\t\"Content-Type\": \"application/json\"\n\t\t\t\t\t},\n\t\t\t\t\tbody: JSON.stringify({\n\t\t\t\t\t\tembeds: [embed]\n\t\t\t\t\t})\n\t\t\t\t});\n\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\tcatch (e) {\n\t\t\t\tconsole.error(\"Error sending Discord message\", e);\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\n\t\t/**\n\t\t * @param {Object} options\n\t\t * @param {string} options.message\n\t\t * @param {string} options.type\n\t\t * @param {string} options.command\n\t\t * @param {Object} options.user\n\t\t * @param {Object} options.channel\n\t\t * @param {Object} options.platform\n\t\t * @returns {Promise<boolean>}\n\t\t */\n\t\tasync sendDiscordCommandExecution (options) {\n\t\t\tconst { message, type, command, user, channel, platform } = options;\n\t\t\ttry {\n\t\t\t\t// If user doesn't exist, don't log\n\t\t\t\tif (!user) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\n\t\t\t\tconst channelString = channel ? `${channel.Name} (${channel.ID})` : \"Private messages\";\n\t\t\t\tlet platformIcon = SystemLog.getPlatformIcon(platform.Name);\n\t\t\t\tif (!platformIcon) {\n\t\t\t\t\tplatformIcon = \"\";\n\t\t\t\t}\n\n\t\t\t\tconst embed = {\n\t\t\t\t\ttitle: `${platformIcon} Command ${command} executed in ${channelString}`,\n\t\t\t\t\tdescription: message,\n\t\t\t\t\tcolor: 0x2196F3,\n\t\t\t\t\tfooter: {\n\t\t\t\t\t\ttext: `${user.Name} (ID ${user.ID})`\n\t\t\t\t\t}\n\t\t\t\t};\n\n\t\t\t\t// Get the correct webhook URL from the config\n\t\t\t\tlet webhookURL = null;\n\t\t\t\tif (sb.Config) {\n\t\t\t\t\tconst configKey = \"SYSTEM_LOG_DISCORD_WEBHOOK\";\n\t\t\t\t\twebhookURL = await sb.Config.get(configKey);\n\t\t\t\t}\n\n\t\t\t\tif (!webhookURL) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\n\t\t\t\t// Send the webhook message\n\t\t\t\tawait fetch(webhookURL, {\n\t\t\t\t\tmethod: \"POST\",\n\t\t\t\t\theaders: {\n\t\t\t\t\t\t\"Content-Type\": \"application/json\"\n\t\t\t\t\t},\n\t\t\t\t\tbody: JSON.stringify({\n\t\t\t\t\t\tembeds: [embed]\n\t\t\t\t\t})\n\t\t\t\t});\n\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\tcatch (e) {\n\t\t\t\tconsole.error(\"Error sending Discord command execution\", e);\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\n\t\t/**\n\t\t * @param {Object} options\n\t\t * @param {string} options.message\n\t\t * @param {number} [options.color=0xFFA500]\n\t\t * @returns {Promise<boolean>}\n\t\t */\n\t\tasync sendDiscordSystemMessage (options) {\n\t\t\tconst { message, color = 0xFFA500 } = options;\n\t\t\ttry {\n\t\t\t\tconst embed = {\n\t\t\t\t\ttitle: \"System event\",\n\t\t\t\t\tdescription: message,\n\t\t\t\t\tcolor\n\t\t\t\t};\n\n\t\t\t\t// Get the correct webhook URL from the config\n\t\t\t\tlet webhookURL = null;\n\t\t\t\tif (sb.Config) {\n\t\t\t\t\tconst configKey = \"SYSTEM_LOG_DISCORD_WEBHOOK\";\n\t\t\t\t\twebhookURL = await sb.Config.get(configKey);\n\t\t\t\t}\n\n\t\t\t\tif (!webhookURL) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\n\t\t\t\t// Send the webhook message\n\t\t\t\tawait fetch(webhookURL, {\n\t\t\t\t\tmethod: \"POST\",\n\t\t\t\t\theaders: {\n\t\t\t\t\t\t\"Content-Type\": \"application/json\"\n\t\t\t\t\t},\n\t\t\t\t\tbody: JSON.stringify({\n\t\t\t\t\t\tembeds: [embed]\n\t\t\t\t\t})\n\t\t\t\t});\n\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\tcatch (e) {\n\t\t\t\tconsole.error(\"Error sending Discord system message\", e);\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\n\t\t/**\n\t\t * Logs an error message to a Discord channel\n\t\t * @param {Object} options\n\t\t * @param {Error} options.error\n\t\t * @param {string} [options.context]\n\t\t * @returns {Promise<boolean>}\n\t\t */\n\t\tasync sendDiscordErrorMessage (options) {\n\t\t\tconst { error, context } = options;\n\t\t\ttry {\n\t\t\t\tconst embed = {\n\t\t\t\t\ttitle: \"Error occurred\",\n\t\t\t\t\tdescription: error.message,\n\t\t\t\t\tcolor: 0xFF0000,\n\t\t\t\t\tfields: [\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tname: \"Stack trace\",\n\t\t\t\t\t\t\tvalue: `\\`\\`\\`${error.stack}\\`\\`\\``\n\t\t\t\t\t\t}\n\t\t\t\t\t]\n\t\t\t\t};\n\n\t\t\t\tif (context) {\n\t\t\t\t\tembed.fields.unshift({\n\t\t\t\t\t\tname: \"Context\",\n\t\t\t\t\t\tvalue: context\n\t\t\t\t\t});\n\t\t\t\t}\n\n\t\t\t\t// Get the correct webhook URL from the config\n\t\t\t\tlet webhookURL = null;\n\t\t\t\tif (sb.Config) {\n\t\t\t\t\tconst configKey = \"SYSTEM_LOG_DISCORD_WEBHOOK\";\n\t\t\t\t\twebhookURL = await sb.Config.get(configKey);\n\t\t\t\t}\n\n\t\t\t\tif (!webhookURL) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\n\t\t\t\t// Send the webhook message\n\t\t\t\tawait fetch(webhookURL, {\n\t\t\t\t\tmethod: \"POST\",\n\t\t\t\t\theaders: {\n\t\t\t\t\t\t\"Content-Type\": \"application/json\"\n\t\t\t\t\t},\n\t\t\t\t\tbody: JSON.stringify({\n\t\t\t\t\t\tembeds: [embed]\n\t\t\t\t\t})\n\t\t\t\t});\n\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\tcatch (e) {\n\t\t\t\tconsole.error(\"Error sending Discord error message\", e);\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\n\t\t/**\n\t\t * Fetches channel data for a given channel\n\t\t * @param {number} channelID\n\t\t * @returns {Promise<Object>}\n\t\t */\n\t\tasync getChannelData (channelID) {\n\t\t\tif (!channelID) {\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\tif (this.channelDataCache.has(channelID)) {\n\t\t\t\treturn this.channelDataCache.get(channelID);\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\tconst channelData = await sb.Query.getRecordset(rs => rs\n\t\t\t\t\t.select(\"ID\", \"Name\", \"Platform\")\n\t\t\t\t\t.from(\"chat_data\", \"Channel\")\n\t\t\t\t\t.where(\"ID = %n\", channelID)\n\t\t\t\t\t.single()\n\t\t\t\t);\n\n\t\t\t\tif (channelData) {\n\t\t\t\t\tthis.channelDataCache.set(channelID, channelData);\n\t\t\t\t}\n\n\t\t\t\treturn channelData;\n\t\t\t}\n\t\t\tcatch (e) {\n\t\t\t\tconsole.error(\"Error fetching channel data\", e);\n\t\t\t\treturn null;\n\t\t\t}\n\t\t}\n\n\t\t/**\n\t\t * Destroys the singleton instance\n\t\t */\n\t\tstatic destroy () {\n\t\t\tthis.module = null;\n\t\t}\n\t}\n\n\treturn SystemLog;\n})();\n\u0005End File\u0006# Supinic/supibot\n# singletons/utils/index.js\nmodule.exports = (function () {\n\t\"use strict\";\n\n\t/**\n\t * Utility object containing various utility methods.\n\t * @memberof sb\n\t * @namespace Utils\n\t */\n\n\tconst Singleton = require(\"../singleton.js\");\n\tconst UtilsCustomError = require(\"./error.js\");\n\tconst LRUCache = require(\"../../utils/caches/lru.js\");\n\tconst persistedDataCache = new LRUCache({\n\t\tmaxSize: 100,\n\t\texpirationTime: 600_000\n\t});\n\n\tlet linkParserRegex = null;\n\n\t// This is a function to have live checking for process.env and sb.Config\n\tconst getConfig = (key) => {\n\t\tif (typeof process.env[key] !== \"undefined\") {\n\t\t\treturn process.env[key];\n\t\t}\n\t\telse if (typeof sb !== \"undefined\" && sb.Config) {\n\t\t\treturn sb.Config.get(key);\n\t\t}\n\t\telse {\n\t\t\treturn null;\n\t\t}\n\t};\n\n\tconst Utils = {\n\t\t/**\n\t\t * Promisified setTimeout function.\n\t\t * @param {number} time time (ms) to sleep for\n\t\t * @returns {Promise<void>}\n\t\t */\n\t\tasync sleep (time) {\n\t\t\treturn new Promise(resolve => setTimeout(() => resolve(), time));\n\t\t},\n\n\t\t/**\n\t\t * Wrap a function with a timeout, so it fails if it takes too long.\n\t\t * @param {Function} fn The function to wrap\n\t\t * @param {number} ms The timeout in milliseconds\n\t\t * @returns {Promise<*>}\n\t\t */\n\t\tasync withTimeout (fn, ms) {\n\t\t\tconst timeout = new Promise((_, reject) => {\n\t\t\t\tsetTimeout(() => {\n\t\t\t\t\treject(new Error(`Timed out after ${ms}ms`));\n\t\t\t\t}, ms);\n\t\t\t});\n\n\t\t\treturn Promise.race([fn(), timeout]);\n\t\t},\n\n\t\t/**\n\t\t * Create a promise that resolves after a certain time.\n\t\t * @param {number} ms The time to wait in milliseconds\n\t\t * @returns {Promise<void>}\n\t\t */\n\t\tasync waitUntil (ms) {\n\t\t\treturn new Promise(resolve => {\n\t\t\t\tsetTimeout(resolve, ms);\n\t\t\t});\n\t\t},\n\n\t\t/**\n\t\t * Turn a callback-based function into a promise-based one.\n\t\t * @param {Function} fn The function to promisify\n\t\t * @returns {Function} A function that returns a promise\n\t\t */\n\t\tpromisify (fn) {\n\t\t\treturn (...args) => {\n\t\t\t\treturn new Promise((resolve, reject) => {\n\t\t\t\t\tfn(...args, (err, result) => {\n\t\t\t\t\t\tif (err) {\n\t\t\t\t\t\t\treject(err);\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tresolve(result);\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t});\n\t\t\t};\n\t\t},\n\n\t\t/**\n\t\t * Returns a random integer between min and max, inclusively.\n\t\t * @param {number} min\n\t\t * @param {number} max\n\t\t * @returns {number}\n\t\t */\n\t\trandom (min, max) {\n\t\t\tif (!max) {\n\t\t\t\tmax = min;\n\t\t\t\tmin = 0;\n\t\t\t}\n\n\t\t\tmin = Math.ceil(min);\n\t\t\tmax = Math.floor(max);\n\t\t\treturn Math.floor(Math.random() * (max - min + 1)) + min;\n\t\t},\n\n\t\t/**\n\t\t * Chooses a random element from input array.\n\t\t * @param {Array} arr\n\t\t * @returns {*}\n\t\t */\n\t\trandArray (arr) {\n\t\t\treturn arr[this.random(0, arr.length - 1)];\n\t\t},\n\n\t\t/**\n\t\t * Formats an array into a string, by joining elements with a pre-determined separator\n\t\t * The final separator can be different than the rest.\n\t\t * Options: { prefix, suffix, separator, finalSeparator }\n\t\t * @param {Array} arr Array of strings.\n\t\t * @param {Object} options Formatting options.\n\t\t * @returns {string}\n\t\t */\n\t\tformatList (arr, options = {}) {\n\t\t\tif (!Array.isArray(arr)) {\n\t\t\t\tthrow new Error(\"Input must be an array\");\n\t\t\t}\n\n\t\t\tconst {\n\t\t\t\tprefix = \"\",\n\t\t\t\tsuffix = \"\",\n\t\t\t\tseparator = \", \",\n\t\t\t\tfinalSeparator = \" and \"\n\t\t\t} = options;\n\n\t\t\tif (arr.length === 0) {\n\t\t\t\treturn \"\";\n\t\t\t}\n\t\t\telse if (arr.length === 1) {\n\t\t\t\treturn `${prefix}${arr[0]}${suffix}`;\n\t\t\t}\n\t\t\telse {\n\t\t\t\treturn `${prefix}${arr.slice(0, -1).join(separator)}${finalSeparator}${arr[arr.length - 1]}${suffix}`;\n\t\t\t}\n\t\t},\n\n\t\t/**\n\t\t * Combines two arrays and returns their Cartesian product.\n\t\t * @param {Array} a First array\n\t\t * @param {Array} b Second array\n\t\t * @returns {Array}\n\t\t */\n\t\tcartesianProduct (a, b) {\n\t\t\treturn a.reduce((arr, item) => {\n\t\t\t\treturn arr.concat(b.map(ite => {\n\t\t\t\t\treturn [item, ite];\n\t\t\t\t}));\n\t\t\t}, []);\n\t\t},\n\n\t\t/**\n\t\t * Shuffles an array in place by using the Fisher-Yates algorithm.\n\t\t * @param {Array} arr Target array.\n\t\t * @returns {Array} Modified array, also the same reference as input.\n\t\t */\n\t\tshuffleArray (arr) {\n\t\t\tif (!Array.isArray(arr)) {\n\t\t\t\tthrow new Error(\"shuffleArray requires an array as its only argument\");\n\t\t\t}\n\n\t\t\tfor (let i = arr.length - 1; i > 0; i--) {\n\t\t\t\tconst j = Math.floor(Math.random() * (i + 1));\n\t\t\t\t[arr[i], arr[j]] = [arr[j], arr[i]];\n\t\t\t}\n\n\t\t\treturn arr;\n\t\t},\n\n\t\t/**\n\t\t * Creates a deep copy of an object. This is suitable for common objects, but will fail with self-references.\n\t\t * Non-generic objects will get stringified, e.g. Date => String.\n\t\t * @param {Object} obj\n\t\t * @returns {Object}\n\t\t */\n\t\tdeepClone (obj) {\n\t\t\treturn JSON.parse(JSON.stringify(obj));\n\t\t},\n\n\t\t/**\n\t\t * Creates a shallow copy of an object.\n\t\t * @param {Object} obj\n\t\t * @returns {Object}\n\t\t */\n\t\tclone (obj) {\n\t\t\treturn { ...obj };\n\t\t},\n\n\t\t/**\n\t\t * Returns the first element that doesn't evaluate to false or null/undefined\n\t\t * @param {Array} args\n\t\t * @returns {*}\n\t\t */\n\t\tcoalesce (...args) {\n\t\t\tfor (const arg of args) {\n\t\t\t\tif (arg) {\n\t\t\t\t\treturn arg;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn null;\n\t\t},\n\n\t\t/**\n\t\t * Returns a number clamped between a minimum and a maximum\n\t\t * @param {number} num\n\t\t * @param {number} min\n\t\t * @param {number} max\n\t\t * @returns {number}\n\t\t */\n\t\tclamp (num, min, max) {\n\t\t\treturn Math.min(Math.max(num, min), max);\n\t\t},\n\n\t\t/**\n\t\t * Rounds to specified decimal places.\n\t\t * @param {number} num\n\t\t * @param {number} places\n\t\t * @returns {number}\n\t\t */\n\t\tround (num, places) {\n\t\t\tconst mult = 10 ** places;\n\t\t\treturn Math.round(num * mult) / mult;\n\t\t},\n\n\t\t/**\n\t\t * Capitalizes the first character of the input string.\n\t\t * @param {string} input\n\t\t * @returns {string}\n\t\t */\n\t\tcapitalize (input) {\n\t\t\treturn input.charAt(0).toUpperCase() + input.slice(1);\n\t\t},\n\n\t\t/**\n\t\t * Returns current unix timestamp in seconds.\n\t\t * @returns {number}\n\t\t */\n\t\tgetTimestamp () {\n\t\t\treturn Math.floor(Date.now() / 1000);\n\t\t},\n\n\t\t/**\n\t\t * Compares two timestamps in the same format.\n\t\t * Used for comparing sb.Date to other dates, to skip the TZ offset.\n\t\t * @param {Date|sb.Date} first\n\t\t * @param {Date|sb.Date} second\n\t\t * @param {string} format See 'format' docs on MDN\n\t\t * @returns {boolean}\n\t\t */\n\t\tcompareDateStrings (first, second, format = \"en-US\") {\n\t\t\treturn first.toLocaleString(format) === second.toLocaleString(format);\n\t\t},\n\n\t\t/**\n\t\t * Wraps the input string into the given amount of characters per line.\n\t\t * @param {string} string\n\t\t * @param {number} [length]\n\t\t * @returns {string}\n\t\t */\n\t\twrapString (string, length = 80) {\n\t\t\treturn string.replace(\n\t\t\t\tnew RegExp(`(?![^\\\\n]{1,${length}}$)([^\\\\n]{1,${length}})\\\\s`, \"g\"),\n\t\t\t\t\"$1\\n\"\n\t\t\t);\n\t\t},\n\n\t\t/**\n\t\t * Removes all non-ASCII characters from string.\n\t\t * @param {string} string\n\t\t * @param {boolean} [rejectEmojis]\n\t\t * @returns {string}\n\t\t */\n\t\tremoveNonASCII (string, rejectEmojis = true) {\n\t\t\tconst emojiRegex = /[\\u{1F300}-\\u{1F6FF}\\u{2600}-\\u{26FF}]/gu;\n\t\t\tif (rejectEmojis) {\n\t\t\t\tstring = string.replace(emojiRegex, \"\");\n\t\t\t}\n\n\t\t\treturn string.replace(/[^\\x00-\\x7F]/g, \"\");\n\t\t},\n\n\t\t/**\n\t\t * Creates a string (with fixed length) with a number, padded zeroes on the left side.\n\t\t * @param {number} number\n\t\t * @param {number} length\n\t\t * @returns {string}\n\t\t */\n\t\tzf (number, length) {\n\t\t\treturn (\"0\".repeat(length) + number).slice(-length);\n\t\t},\n\n\t\t/**\n\t\t * Time-ago-style date in human readable form.\n\t\t * @param {sb.Date|Date} date\n\t\t * @returns {string}\n\t\t */\n\t\trelativeTime (date) {\n\t\t\tconst now = new sb.Date();\n\t\t\tlet delta = Math.floor(now - date);\n\t\t\tif (delta < 0) {\n\t\t\t\tdelta = 0;\n\t\t\t}\n\n\t\t\tconst seconds = Math.floor(delta / 1000);\n\t\t\tif (seconds < 60) {\n\t\t\t\treturn `${seconds} second${(seconds === 1) ? \"\" : \"s\"} ago`;\n\t\t\t}\n\n\t\t\tconst minutes = Math.floor(seconds / 60);\n\t\t\tif (minutes < 60) {\n\t\t\t\treturn `${minutes} minute${(minutes === 1) ? \"\" : \"s\"} ago`;\n\t\t\t}\n\n\t\t\tconst hours = Math.floor(minutes / 60);\n\t\t\tif (hours < 24) {\n\t\t\t\treturn `${hours} hour${(hours === 1) ? \"\" : \"s\"} ago`;\n\t\t\t}\n\n\t\t\tconst days = Math.floor(hours / 24);\n\t\t\tif (days < 30) {\n\t\t\t\treturn `${days} day${(days === 1) ? \"\" : \"s\"} ago`;\n\t\t\t}\n\n\t\t\tconst months = Math.floor(days / 30);\n\t\t\tif (months < 12) {\n\t\t\t\treturn `${months} month${(months === 1) ? \"\" : \"s\"} ago`;\n\t\t\t}\n\n\t\t\tconst years = Math.floor(days / 365.25);\n\t\t\treturn `${years} year${(years === 1) ? \"\" : \"s\"} ago`;\n\t\t},\n\n\t\t/**\n\t\t * Function determining if a link is potentially unsafe. This is used to determine if some user-provided links should be\n\t\t * embedded or not.\n\t\t * @param {string} string\n\t\t * @returns {boolean}\n\t\t */\n\t\tisUnsafeLink (string) {\n\t\t\tif (!string.includes(\".\")) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\tconst domain = string.split(\"/\")[0];\n\t\t\tif (domain.includes(\"iplogger\") || domain.includes(\"2no.co\") || domain.includes(\"yip.su\") || domain.includes(\"ipgrabber\")) {\n\t\t\t\treturn true;\n\t\t\t}\n\n\t\t\treturn false;\n\t\t},\n\n\t\t/**\n\t\t * Parses common link formats and returns them as standard objects.\n\t\t * If a link is not recognized, returns null.\n\t\t * @param {string} stringLink\n\t\t * @returns {null|{\n\t\t *  ID: string,\n\t\t *  link: string,\n\t\t *  type: string,\n\t\t *  list: string|null,\n\t\t *  fullID: string,\n\t\t *  timestamp: number|null,\n\t\t *  channelID: string|null\n\t\t * }}\n\t\t */\n\t\tparseLink (stringLink) {\n\t\t\t// regexp explanation\n\t\t\t// (this is so hard to read, even for me, I'm sorry)\n\t\t\t// 1. check for protocol\n\t\t\t//  a. any protocol ever string:// - literally just for starting the regexp, this is dropped later\n\t\t\t//  b. OR the common www.* starting a URL\n\t\t\t// 2. parse the proper domain\n\t\t\t//  a. whatever.domain.name\n\t\t\t//  b. if not exists, localhost is permitted\n\t\t\t// 3. parse extra parameters\n\t\t\t//  a. optional port :1234, :443, ...\n\t\t\t//  b. any amount of characters (path, query, etc.) - this is later parsed\n\t\t\tif (!linkParserRegex) {\n\t\t\t\tlinkParserRegex = new RegExp(/^((([A-Za-z]+:\\/\\/)?([A-Za-z0-9.\\-_]+\\.[A-Za-z0-9\\-_]+))|([A-Za-z0-9.\\-_]+\\.([A-Za-z0-9\\-_]+))|(localhost))+(:[0-9]+)?(\\/[\\S]*)?$/);\n\t\t\t}\n\n\t\t\tlet type = null;\n\t\t\tlet ID = null;\n\t\t\tlet channelID = null;\n\t\t\tlet list = null;\n\t\t\tlet link = null;\n\t\t\tlet fullID = null;\n\t\t\tlet timestamp = null;\n\n\t\t\t// Make sure to check for null, as this might be invoked on an empty string\n\t\t\tif (stringLink && typeof stringLink === \"string\") {\n\t\t\t\t// Only check for \"non-traditional\" links (timestamps, etc.) if the link does not fit the normal format\n\t\t\t\t// The function may return null in some cases which are then skipped here.\n\t\t\t\tif (linkParserRegex.test(stringLink)) {\n\t\t\t\t\t// Youtube\n\t\t\t\t\tif (stringLink.includes(\"youtu\")) {\n\t\t\t\t\t\tlink = stringLink;\n\t\t\t\t\t\ttype = \"youtube\";\n\n\t\t\t\t\t\t// youtu.be\n\t\t\t\t\t\tif (stringLink.includes(\"youtu.be\")) {\n\t\t\t\t\t\t\tconst match = /(youtu\\.be\\/|v\\/|u\\/\\w\\/|embed\\/|watch\\?v=)([^#&?]*).*/.exec(stringLink);\n\t\t\t\t\t\t\tID = (match && match[2].length === 11) ? match[2] : null;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// youtube.com/(something)\n\t\t\t\t\t\telse if (stringLink.includes(\"youtube\")) {\n\t\t\t\t\t\t\tlet match = /(youtube\\.com\\/|v\\/|u\\/\\w\\/|embed\\/|watch\\?v=|shorts\\/)([^#&?]*).*/.exec(stringLink);\n\t\t\t\t\t\t\tif (match) {\n\t\t\t\t\t\t\t\t// Video ID found - https://www.youtube.com/watch?v=...\n\t\t\t\t\t\t\t\tID = (match && match[2].length === 11) ? match[2] : null;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse if (/^(youtube\\.com\\/)(c\\/|channel\\/|user\\/)([^#&?]*).*/.test(stringLink)) {\n\t\t\t\t\t\t\t\t// Channel name found - https://www.youtube.com/c/...\n\t\t\t\t\t\t\t\tmatch = /(youtube\\.com\\/)(c\\/|channel\\/|user\\/)([^#&?]*).*/.exec(stringLink);\n\t\t\t\t\t\t\t\tID = match?.[3] ?? null;\n\t\t\t\t\t\t\t\ttype = \"youtube-channel\";\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse if (stringLink.includes(\"playlist\")) {\n\t\t\t\t\t\t\t\t// Playlist ID found - https://www.youtube.com/playlist?list=...\n\t\t\t\t\t\t\t\tmatch = /(youtube\\.com\\/)(playlist\\?list=)([^#&?]*).*/.exec(stringLink);\n\t\t\t\t\t\t\t\tID = match?.[3] ?? null;\n\t\t\t\t\t\t\t\ttype = \"youtube-playlist\";\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t// Get timestamp if present - at the end of link, or as a parameter\n\t\t\t\t\t\t\tconst timestampParamIndex = stringLink.indexOf(\"&t=\");\n\t\t\t\t\t\t\tconst timestampHashIndex = stringLink.indexOf(\"#t=\");\n\t\t\t\t\t\t\tlet timestampString = null;\n\n\t\t\t\t\t\t\tif (timestampParamIndex !== -1) {\n\t\t\t\t\t\t\t\ttimestampString = stringLink.slice(timestampParamIndex + 3);\n\t\t\t\t\t\t\t\tconst endOfTimestampIndex = timestampString.search(/&|$/);\n\t\t\t\t\t\t\t\tif (endOfTimestampIndex !== -1) {\n\t\t\t\t\t\t\t\t\ttimestampString = timestampString.slice(0, endOfTimestampIndex);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse if (timestampHashIndex !== -1) {\n\t\t\t\t\t\t\t\ttimestampString = stringLink.slice(timestampHashIndex + 3);\n\t\t\t\t\t\t\t\tconst endOfTimestampIndex = timestampString.search(/&|$/);\n\t\t\t\t\t\t\t\tif (endOfTimestampIndex !== -1) {\n\t\t\t\t\t\t\t\t\ttimestampString = timestampString.slice(0, endOfTimestampIndex);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif (timestampString) {\n\t\t\t\t\t\t\t\tif (/^\\d+$/.test(timestampString)) {\n\t\t\t\t\t\t\t\t\t// Only digits = timestamp in seconds\n\t\t\t\t\t\t\t\t\ttimestamp = Number(timestampString);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t\t// Parse time format like 1h30m15s\n\t\t\t\t\t\t\t\t\tlet totalSeconds = 0;\n\t\t\t\t\t\t\t\t\tconst matches = timestampString.match(/(\\d+h)?(\\d+m)?(\\d+s)?/);\n\t\t\t\t\t\t\t\t\tif (matches) {\n\t\t\t\t\t\t\t\t\t\tif (matches[1]) {\n\t\t\t\t\t\t\t\t\t\t\ttotalSeconds += parseInt(matches[1], 10) * 3600;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\tif (matches[2]) {\n\t\t\t\t\t\t\t\t\t\t\ttotalSeconds += parseInt(matches[2], 10) * 60;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\tif (matches[3]) {\n\t\t\t\t\t\t\t\t\t\t\ttotalSeconds += parseInt(matches[3], 10);\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\ttimestamp = totalSeconds;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Check for playlist ID\n\t\t\t\t\t\t// Capture group 1 is the base URL, 2 is \"list=\" and 3 is the actual playlist ID\n\t\t\t\t\t\tconst playlistMatch = /(youtube\\.com\\/|youtu\\.be\\/)(watch\\?v=[^#&?]*&list=|watch\\?list=)([^#&?]*).*/.exec(stringLink);\n\t\t\t\t\t\tif (playlistMatch) {\n\t\t\t\t\t\t\tlist = playlistMatch[3];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t// Spotify\n\t\t\t\t\telse if (stringLink.includes(\"spotify\")) {\n\t\t\t\t\t\tlink = stringLink;\n\t\t\t\t\t\ttype = \"spotify\";\n\n\t\t\t\t\t\t// Track\n\t\t\t\t\t\tif (stringLink.includes(\"track\")) {\n\t\t\t\t\t\t\tconst match = /(spotify\\.com\\/|embed\\/|)track\\/([^?]*).*/.exec(stringLink);\n\t\t\t\t\t\t\tID = match?.[2] ?? null;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// Album\n\t\t\t\t\t\telse if (stringLink.includes(\"album\")) {\n\t\t\t\t\t\t\tconst match = /(spotify\\.com\\/|embed\\/|)album\\/([^?]*).*/.exec(stringLink);\n\t\t\t\t\t\t\tID = match?.[2] ?? null;\n\t\t\t\t\t\t\ttype = \"spotify-album\";\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// Artist\n\t\t\t\t\t\telse if (stringLink.includes(\"artist\")) {\n\t\t\t\t\t\t\tconst match = /(spotify\\.com\\/|embed\\/|)artist\\/([^?]*).*/.exec(stringLink);\n\t\t\t\t\t\t\tID = match?.[2] ?? null;\n\t\t\t\t\t\t\ttype = \"spotify-artist\";\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// Playlist\n\t\t\t\t\t\telse if (stringLink.includes(\"playlist\")) {\n\t\t\t\t\t\t\tconst match = /(spotify\\.com\\/|embed\\/|)playlist\\/([^?]*).*/.exec(stringLink);\n\t\t\t\t\t\t\tID = match?.[2] ?? null;\n\t\t\t\t\t\t\ttype = \"spotify-playlist\";\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t// Vimeo\n\t\t\t\t\telse if (stringLink.includes(\"vimeo\")) {\n\t\t\t\t\t\tlink = stringLink;\n\t\t\t\t\t\ttype = \"vimeo\";\n\t\t\t\t\t\tconst match = /(vimeo\\.com\\/|player.vimeo\\.com\\/video\\/)([0-9]+).*/.exec(stringLink);\n\t\t\t\t\t\tID = match?.[2] ?? null;\n\t\t\t\t\t}\n\t\t\t\t\t// SoundCloud\n\t\t\t\t\telse if (stringLink.includes(\"soundcloud\")) {\n\t\t\t\t\t\tlink = stringLink;\n\t\t\t\t\t\ttype = \"soundcloud\";\n\t\t\t\t\t\tconst match = /(soundcloud\\.com\\/)(.+)/.exec(stringLink);\n\t\t\t\t\t\tID = match?.[2] ?? null;\n\t\t\t\t\t}\n\t\t\t\t\t// Twitch clip\n\t\t\t\t\telse if (stringLink.includes(\"clips.twitch.tv\") || (stringLink.includes(\"twitch.tv\") && stringLink.includes(\"/clip/\"))) {\n\t\t\t\t\t\tlink = stringLink;\n\t\t\t\t\t\ttype = \"twitch-clip\";\n\t\t\t\t\t\tconst match = /(clips\\.twitch\\.tv\\/|twitch\\.tv\\/\\w+\\/clip\\/)([^?&/]*).*/.exec(stringLink);\n\t\t\t\t\t\tID = match?.[2] ?? null;\n\t\t\t\t\t}\n\t\t\t\t\t// Twitch VOD\n\t\t\t\t\telse if (stringLink.includes(\"twitch.tv\") && (stringLink.includes(\"/videos/\") || stringLink.includes(\"/v/\"))) {\n\t\t\t\t\t\tlink = stringLink;\n\t\t\t\t\t\ttype = \"twitch-vod\";\n\t\t\t\t\t\tconst match = /(twitch\\.tv\\/\\w+\\/v\\/|twitch\\.tv\\/videos\\/)([0-9]+).*/.exec(stringLink);\n\t\t\t\t\t\tID = match?.[2] ?? null;\n\t\t\t\t\t\t// timestamp exists - appended at the end of url with ?t=1h30m15s format\n\t\t\t\t\t\tconst timeIndex = stringLink.indexOf(\"?t=\");\n\t\t\t\t\t\tif (timeIndex !== -1) {\n\t\t\t\t\t\t\tconst timeString = stringLink.slice(timeIndex + 3);\n\t\t\t\t\t\t\tconst endOfTimeIndex = timeString.search(/&|$/);\n\t\t\t\t\t\t\tif (endOfTimeIndex !== -1) {\n\t\t\t\t\t\t\t\tconst parsedTime = timeString.slice(0, endOfTimeIndex);\n\t\t\t\t\t\t\t\tif (/^\\d+$/.test(parsedTime)) {\n\t\t\t\t\t\t\t\t\t// Only digits = timestamp in seconds\n\t\t\t\t\t\t\t\t\ttimestamp = Number(parsedTime);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t\t// Parse time format like 1h30m15s\n\t\t\t\t\t\t\t\t\tlet totalSeconds = 0;\n\t\t\t\t\t\t\t\t\tconst parts = parsedTime.match(/(\\d+h)?(\\d+m)?(\\d+s)?/);\n\t\t\t\t\t\t\t\t\tif (parts) {\n\t\t\t\t\t\t\t\t\t\tif (parts[1]) {\n\t\t\t\t\t\t\t\t\t\t\ttotalSeconds += parseInt(parts[1], 10) * 3600;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\tif (parts[2]) {\n\t\t\t\t\t\t\t\t\t\t\ttotalSeconds += parseInt(parts[2], 10) * 60;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\tif (parts[3]) {\n\t\t\t\t\t\t\t\t\t\t\ttotalSeconds += parseInt(parts[3], 10);\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\ttimestamp = totalSeconds;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t// Twitch channel\n\t\t\t\t\telse if (stringLink.includes(\"twitch.tv\") && !stringLink.includes(\"/videos/\") && !stringLink.includes(\"/v/\") && !stringLink.includes(\"/clip/\")) {\n\t\t\t\t\t\tlink = stringLink;\n\t\t\t\t\t\ttype = \"twitch-channel\";\n\t\t\t\t\t\tconst match = /(twitch\\.tv\\/)([^?&/]*).*/.exec(stringLink);\n\t\t\t\t\t\tID = match?.[2] ?? null;\n\t\t\t\t\t}\n\t\t\t\t\t// Mixer\n\t\t\t\t\telse if (stringLink.includes(\"mixer.com\")) {\n\t\t\t\t\t\tlink = stringLink;\n\t\t\t\t\t\ttype = \"mixer\";\n\t\t\t\t\t\tconst match = /(mixer\\.com\\/)([^?&/]*).*/.exec(stringLink);\n\t\t\t\t\t\tID = match?.[2] ?? null;\n\t\t\t\t\t}\n\t\t\t\t\t// DLive\n\t\t\t\t\telse if (stringLink.includes(\"dlive.tv\")) {\n\t\t\t\t\t\tlink = stringLink;\n\t\t\t\t\t\ttype = \"dlive\";\n\t\t\t\t\t\tconst match = /(dlive\\.tv\\/)([^?&/]*).*/.exec(stringLink);\n\t\t\t\t\t\tID = match?.[2] ?? null;\n\t\t\t\t\t}\n\t\t\t\t\t// TikTok\n\t\t\t\t\telse if (stringLink.includes(\"tiktok.com\")) {\n\t\t\t\t\t\tlink = stringLink;\n\t\t\t\t\t\ttype = \"tiktok\";\n\t\t\t\t\t\t// Try to match all TikTok URL formats (long form, shortened, embed, etc.)\n\t\t\t\t\t\tconst formats = [\n\t\t\t\t\t\t\t/tiktok\\.com\\/@[\\w.]+\\/video\\/(\\d+)/,\n\t\t\t\t\t\t\t/tiktok\\.com\\/t\\/([^?/&]+)/,\n\t\t\t\t\t\t\t/tiktok\\.com\\/embed\\/(\\d+)/,\n\t\t\t\t\t\t\t/vm\\.tiktok\\.com\\/([^/]+)/\n\t\t\t\t\t\t];\n\n\t\t\t\t\t\tfor (const format of formats) {\n\t\t\t\t\t\t\tconst match = format.exec(stringLink);\n\t\t\t\t\t\t\tif (match && match[1]) {\n\t\t\t\t\t\t\t\tID = match[1];\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t// Instagram\n\t\t\t\t\telse if (stringLink.includes(\"instagram.com\")) {\n\t\t\t\t\t\tlink = stringLink;\n\t\t\t\t\t\ttype = \"instagram\";\n\n\t\t\t\t\t\t// Post/video/reel\n\t\t\t\t\t\tif (stringLink.includes(\"/p/\") || stringLink.includes(\"/reel/\")) {\n\t\t\t\t\t\t\tconst match = /instagram\\.com\\/(p|reel)\\/([^/?]+)/.exec(stringLink);\n\t\t\t\t\t\t\tID = match?.[2] ?? null;\n\t\t\t\t\t\t\ttype = match?.[1] === \"reel\" ? \"instagram-reel\" : \"instagram-post\";\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// User profile\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tconst match = /instagram\\.com\\/([^/?]+)/.exec(stringLink);\n\t\t\t\t\t\t\tID = match?.[1] ?? null;\n\t\t\t\t\t\t\ttype = \"instagram-profile\";\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t// Facebook\n\t\t\t\t\telse if (stringLink.includes(\"facebook.com\") || stringLink.includes(\"fb.watch\")) {\n\t\t\t\t\t\tlink = stringLink;\n\t\t\t\t\t\ttype = \"facebook\";\n\n\t\t\t\t\t\t// Video\n\t\t\t\t\t\tif (stringLink.includes(\"/videos/\") || stringLink.includes(\"fb.watch\")) {\n\t\t\t\t\t\t\tconst videoMatch = /facebook\\.com\\/.*\\/videos\\/(\\d+)/.exec(stringLink);\n\t\t\t\t\t\t\tconst watchMatch = /fb\\.watch\\/([^/?]+)/.exec(stringLink);\n\t\t\t\t\t\t\tID = videoMatch?.[1] ?? watchMatch?.[1] ?? null;\n\t\t\t\t\t\t\ttype = \"facebook-video\";\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// Profile/Page\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tconst match = /facebook\\.com\\/([^/?]+)/.exec(stringLink);\n\t\t\t\t\t\t\tID = match?.[1] ?? null;\n\t\t\t\t\t\t\ttype = \"facebook-page\";\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t// Twitter/X\n\t\t\t\t\telse if (stringLink.includes(\"twitter.com\") || stringLink.includes(\"x.com\")) {\n\t\t\t\t\t\tlink = stringLink;\n\t\t\t\t\t\ttype = \"twitter\";\n\n\t\t\t\t\t\t// Tweet\n\t\t\t\t\t\tif (stringLink.includes(\"/status/\")) {\n\t\t\t\t\t\t\tconst match = /(twitter\\.com|x\\.com)\\/\\w+\\/status\\/(\\d+)/.exec(stringLink);\n\t\t\t\t\t\t\tID = match?.[2] ?? null;\n\t\t\t\t\t\t\ttype = \"twitter-status\";\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// Profile\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tconst match = /(twitter\\.com|x\\.com)\\/([^/?]+)/.exec(stringLink);\n\t\t\t\t\t\t\tID = match?.[2] ?? null;\n\t\t\t\t\t\t\ttype = \"twitter-profile\";\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t// Reddit\n\t\t\t\t\telse if (stringLink.includes(\"reddit.com\")) {\n\t\t\t\t\t\tlink = stringLink;\n\t\t\t\t\t\ttype = \"reddit\";\n\n\t\t\t\t\t\t// Post\n\t\t\t\t\t\tif (stringLink.includes(\"/comments/\")) {\n\t\t\t\t\t\t\tconst match = /reddit\\.com\\/r\\/([^/]+)\\/comments\\/([^/]+)/.exec(stringLink);\n\t\t\t\t\t\t\tif (match) {\n\t\t\t\t\t\t\t\tchannelID = match[1]; // Subreddit\n\t\t\t\t\t\t\t\tID = match[2]; // Post ID\n\t\t\t\t\t\t\t\ttype = \"reddit-post\";\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// Subreddit\n\t\t\t\t\t\telse if (stringLink.includes(\"/r/\")) {\n\t\t\t\t\t\t\tconst match = /reddit\\.com\\/r\\/([^/?]+)/.exec(stringLink);\n\t\t\t\t\t\t\tID = match?.[1] ?? null;\n\t\t\t\t\t\t\ttype = \"reddit-subreddit\";\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// User\n\t\t\t\t\t\telse if (stringLink.includes(\"/user/\") || stringLink.includes(\"/u/\")) {\n\t\t\t\t\t\t\tconst match = /reddit\\.com\\/(user|u)\\/([^/?]+)/.exec(stringLink);\n\t\t\t\t\t\t\tID = match?.[2] ?? null;\n\t\t\t\t\t\t\ttype = \"reddit-user\";\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t// IMDb\n\t\t\t\t\telse if (stringLink.includes(\"imdb.com\")) {\n\t\t\t\t\t\tlink = stringLink;\n\t\t\t\t\t\ttype = \"imdb\";\n\t\t\t\t\t\tconst match = /imdb\\.com\\/title\\/(tt\\d+)/.exec(stringLink);\n\t\t\t\t\t\tID = match?.[1] ?? null;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t// Discord timestamp\n\t\t\t\telse if (/^<t:\\d+(?::[tTdDfFR])?>$/.test(stringLink)) {\n\t\t\t\t\ttype = \"discord-timestamp\";\n\t\t\t\t\tconst match = /<t:(\\d+)(?::([tTdDfFR]))?>/;\n\t\t\t\t\tconst matches = match.exec(stringLink);\n\t\t\t\t\tif (matches) {\n\t\t\t\t\t\tID = matches[1];\n\t\t\t\t\t\tlist = matches[2] || null; // Format specifier\n\t\t\t\t\t\ttimestamp = Number(ID);\n\t\t\t\t\t\tlink = stringLink;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t// Rich text format - Discord-like\n\t\t\t\telse if (/^<(?:@|@!|@&|#)\\d+>$/.test(stringLink)) {\n\t\t\t\t\ttype = \"discord-mention\";\n\t\t\t\t\tconst match = /<([@#])(!|&)?(\\d+)>/;\n\t\t\t\t\tconst matches = match.exec(stringLink);\n\t\t\t\t\tif (matches) {\n\t\t\t\t\t\tconst mentionType = matches[1]; // @ or #\n\t\t\t\t\t\tconst mentionFlag = matches[2] || null; // !, &, or null\n\t\t\t\t\t\tID = matches[3];\n\t\t\t\t\t\tlink = stringLink;\n\n\t\t\t\t\t\tif (mentionType === \"@\") {\n\t\t\t\t\t\t\tif (mentionFlag === \"!\") {\n\t\t\t\t\t\t\t\ttype = \"discord-user-mention\";\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse if (mentionFlag === \"&\") {\n\t\t\t\t\t\t\t\ttype = \"discord-role-mention\";\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\ttype = \"discord-user-mention\";\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if (mentionType === \"#\") {\n\t\t\t\t\t\t\ttype = \"discord-channel-mention\";\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (!ID && !type) {\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\tif (type && ID) {\n\t\t\t\tif (channelID && ID) {\n\t\t\t\t\tfullID = `${channelID}/${ID}`;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tfullID = ID;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tconst result = {\n\t\t\t\tID: ID ?? null,\n\t\t\t\ttype: type ?? null,\n\t\t\t\tlink: link ?? null,\n\t\t\t\tfullID: fullID ?? null,\n\t\t\t\ttimestamp: timestamp ?? null,\n\t\t\t\tchannelID: channelID ?? null,\n\t\t\t\tlist: list ?? null\n\t\t\t};\n\n\t\t\treturn result;\n\t\t},\n\n\t\t/**\n\t\t * Returns a random hash of given length.\n\t\t * @param {number} length\n\t\t * @returns {string}\n\t\t */\n\t\trandomString (length = 32) {\n\t\t\tconst chars = \"0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\".split(\"\");\n\t\t\tconst arr = [];\n\t\t\tfor (let i = 0; i < length; i++) {\n\t\t\t\tarr.push(chars[Math.floor(Math.random() * chars.length)]);\n\t\t\t}\n\n\t\t\treturn arr.join(\"\");\n\t\t},\n\n\t\t/**\n\t\t * Creates a random hex string.\n\t\t * @param {number} length\n\t\t * @returns {string}\n\t\t */\n\t\trandomHex (length = 1) {\n\t\t\tlet result = \"\";\n\t\t\tfor (let i = 0; i < length; i++) {\n\t\t\t\tresult += (Math.random() * 0xF).toString(16).split(\".\")[0];\n\t\t\t}\n\n\t\t\treturn result;\n\t\t},\n\n\t\t/**\n\t\t * Creates a unique Twitch message ID.\n\t\t * @returns {string}\n\t\t */\n\t\tcreateTwitchMessageID () {\n\t\t\tconst randomized = Math.random().toString(16).slice(2);\n\t\t\tlet hex = Number(Date.now()).toString(16);\n\t\t\tif (hex.length % 2 !== 0) {\n\t\t\t\thex = \"0\" + hex;\n\t\t\t}\n\n\t\t\treturn `${randomized}-${hex}`;\n\t\t},\n\n\t\t/**\n\t\t * Converts a string to a Uint8Array\n\t\t * @param {string} string\n\t\t * @returns {Uint8Array}\n\t\t */\n\t\tstringToBytes (string) {\n\t\t\treturn new TextEncoder().encode(string);\n\t\t},\n\n\t\t/**\n\t\t * Converts a Uint8Array to a string\n\t\t * @param {Uint8Array} bytes\n\t\t * @returns {string}\n\t\t */\n\t\tbytesToString (bytes) {\n\t\t\treturn new TextDecoder().decode(bytes);\n\t\t},\n\n\t\t/**\n\t\t * Escapes a string for use in regex.\n\t\t * @param {string} string\n\t\t * @returns {string}\n\t\t */\n\t\tescapeRegExp (string) {\n\t\t\treturn string.replace(/[.*+?^${}()|[\\]\\\\]/g, \"\\\\$&\");\n\t\t},\n\n\t\t/**\n\t\t * Breaks down time from milliseconds to other units\n\t\t * @param {number} ms\n\t\t * @returns {{\n\t\t *  milliseconds: number,\n\t\t *  seconds: number,\n\t\t *  minutes: number,\n\t\t *  hours: number,\n\t\t *  days: number,\n\t\t *  humanized: string\n\t\t * }}\n\t\t */\n\t\tformatTime (ms) {\n\t\t\tif (!Number.isFinite(ms) || ms < 0) {\n\t\t\t\tthrow new Error(\"Time must be a positive finite number\");\n\t\t\t}\n\n\t\t\tlet remainder = ms;\n\t\t\tconst milliseconds = Math.floor(remainder % 1000);\n\t\t\tremainder = Math.floor(remainder / 1000);\n\t\t\tconst seconds = remainder % 60;\n\t\t\tremainder = Math.floor(remainder / 60);\n\t\t\tconst minutes = remainder % 60;\n\t\t\tremainder = Math.floor(remainder / 60);\n\t\t\tconst hours = remainder % 24;\n\t\t\tconst days = Math.floor(remainder / 24);\n\n\t\t\tlet humanized = \"\";\n\t\t\tif (days > 0) {\n\t\t\t\thumanized += `${days}d `;\n\t\t\t}\n\t\t\tif (hours > 0 || humanized) {\n\t\t\t\thumanized += `${hours}h `;\n\t\t\t}\n\t\t\tif (minutes > 0 || humanized) {\n\t\t\t\thumanized += `${minutes}m `;\n\t\t\t}\n\t\t\tif (seconds > 0 || humanized) {\n\t\t\t\thumanized += `${seconds}s `;\n\t\t\t}\n\t\t\tif (milliseconds > 0 || !humanized) {\n\t\t\t\thumanized += `${milliseconds}ms`;\n\t\t\t}\n\n\t\t\treturn {\n\t\t\t\tmilliseconds,\n\t\t\t\tseconds,\n\t\t\t\tminutes,\n\t\t\t\thours,\n\t\t\t\tdays,\n\t\t\t\thumanized: humanized.trim()\n\t\t\t};\n\t\t},\n\n\t\t/**\n\t\t * Formats seconds as a time string.\n\t\t * @param {number} seconds\n\t\t * @param {boolean} [includeMilliseconds]\n\t\t * @returns {string}\n\t\t */\n\t\tformatDuration (seconds, includeMilliseconds = false) {\n\t\t\tif (!Number.isFinite(seconds) || seconds < 0) {\n\t\t\t\tthrow new Error(\"Time must be a positive finite number\");\n\t\t\t}\n\n\t\t\tconst ms = seconds * 1000;\n\t\t\tconst { hours, minutes, seconds: secs, milliseconds } = this.formatTime(ms);\n\n\t\t\tconst parts = [];\n\t\t\tif (hours > 0) {\n\t\t\t\tparts.push(hours.toString().padStart(2, \"0\"));\n\t\t\t}\n\t\t\tparts.push(minutes.toString().padStart(2, \"0\"));\n\t\t\tparts.push(secs.toString().padStart(2, \"0\"));\n\n\t\t\tlet result = parts.join(\":\");\n\t\t\tif (includeMilliseconds) {\n\t\t\t\tresult += `.${milliseconds.toString().padStart(3, \"0\")}`;\n\t\t\t}\n\n\t\t\treturn result;\n\t\t},\n\n\t\t/**\n\t\t * Translates duration in ISO format to milliseconds.\n\t\t * @param {string} input\n\t\t * @returns {number}\n\t\t */\n\t\tparseISODuration (input) {\n\t\t\tconst regex = /P(?:(\\d+)Y)?(?:(\\d+)M)?(?:(\\d+)D)?(?:T(?:(\\d+)H)?(?:(\\d+)M)?(?:(\\d+)S)?)?/;\n\t\t\tconst matches = regex.exec(input);\n\t\t\tif (!matches) {\n\t\t\t\treturn 0;\n\t\t\t}\n\n\t\t\tconst [, years, months, days, hours, minutes, seconds] = matches;\n\t\t\tlet duration = 0;\n\n\t\t\tif (years) {\n\t\t\t\tduration += parseInt(years, 10) * 365 * 24 * 60 * 60 * 1000;\n\t\t\t}\n\t\t\tif (months) {\n\t\t\t\tduration += parseInt(months, 10) * 30 * 24 * 60 * 60 * 1000;\n\t\t\t}\n\t\t\tif (days) {\n\t\t\t\tduration += parseInt(days, 10) * 24 * 60 * 60 * 1000;\n\t\t\t}\n\t\t\tif (hours) {\n\t\t\t\tduration += parseInt(hours, 10) * 60 * 60 * 1000;\n\t\t\t}\n\t\t\tif (minutes) {\n\t\t\t\tduration += parseInt(minutes, 10) * 60 * 1000;\n\t\t\t}\n\t\t\tif (seconds) {\n\t\t\t\tduration += parseInt(seconds, 10) * 1000;\n\t\t\t}\n\n\t\t\treturn duration;\n\t\t},\n\n\t\t/**\n\t\t * Splits an array into chunks of size n.\n\t\t * @param {Array} array\n\t\t * @param {number} n\n\t\t * @returns {Array[]}\n\t\t */\n\t\tsplitArrayIntoChunks (array, n) {\n\t\t\tif (!Array.isArray(array)) {\n\t\t\t\tthrow new Error(\"Input must be an array\");\n\t\t\t}\n\n\t\t\tconst result = [];\n\t\t\tfor (let i = 0; i < array.length; i += n) {\n\t\t\t\tresult.push(array.slice(i, i + n));\n\t\t\t}\n\n\t\t\treturn result;\n\t\t},\n\n\t\t/**\n\t\t * Returns values from object as an array.\n\t\t * @param {Object} object\n\t\t * @returns {Array}\n\t\t */\n\t\tobjectValues (object) {\n\t\t\tif (!object || typeof object !== \"object\" || Array.isArray(object)) {\n\t\t\t\tthrow new Error(\"Input must be an object\");\n\t\t\t}\n\n\t\t\treturn Object.values(object);\n\t\t},\n\n\t\t/**\n\t\t * Returns keys from object as an array.\n\t\t * @param {Object} object\n\t\t * @returns {Array}\n\t\t */\n\t\tobjectKeys (object) {\n\t\t\tif (!object || typeof object !== \"object\" || Array.isArray(object)) {\n\t\t\t\tthrow new Error(\"Input must be an object\");\n\t\t\t}\n\n\t\t\treturn Object.keys(object);\n\t\t},\n\n\t\t/**\n\t\t * Returns entries from object as an array of [key, value] pairs.\n\t\t * @param {Object} object\n\t\t * @returns {Array}\n\t\t */\n\t\tobjectEntries (object) {\n\t\t\tif (!object || typeof object !== \"object\" || Array.isArray(object)) {\n\t\t\t\tthrow new Error(\"Input must be an object\");\n\t\t\t}\n\n\t\t\treturn Object.entries(object);\n\t\t},\n\n\t\t/**\n\t\t * Extracts keys from an array of objects.\n\t\t * @param {Object[]} array\n\t\t * @param {string} key\n\t\t * @returns {Array}\n\t\t */\n\t\textractProperty (array, key) {\n\t\t\tif (!Array.isArray(array)) {\n\t\t\t\tthrow new Error(\"First argument must be an array\");\n\t\t\t}\n\t\t\tif (typeof key !== \"string\" && typeof key !== \"number\") {\n\t\t\t\tthrow new Error(\"Second argument must be a string or number\");\n\t\t\t}\n\n\t\t\treturn array.map(item => (item && typeof item === \"object\") ? item[key] : undefined);\n\t\t},\n\n\t\t/**\n\t\t * Parses a command string into command name and parameters.\n\t\t * @param {string} command\n\t\t * @returns {{command: string, args: string[]}}\n\t\t */\n\t\tparseCommand (command) {\n\t\t\tif (typeof command !== \"string\") {\n\t\t\t\tthrow new Error(\"Command must be a string\");\n\t\t\t}\n\n\t\t\tconst trimmed = command.trim();\n\t\t\tif (trimmed === \"\") {\n\t\t\t\treturn { command: \"\", args: [] };\n\t\t\t}\n\n\t\t\tconst args = this.parseCLIArguments(trimmed);\n\t\t\treturn {\n\t\t\t\tcommand: args[0],\n\t\t\t\targs: args.slice(1)\n\t\t\t};\n\t\t},\n\n\t\t/**\n\t\t * Parses a string into CLI-like arguments, respecting quotes.\n\t\t * @param {string} input\n\t\t * @returns {string[]}\n\t\t */\n\t\tparseCLIArguments (input) {\n\t\t\tif (typeof input !== \"string\") {\n\t\t\t\tthrow new Error(\"Input must be a string\");\n\t\t\t}\n\n\t\t\tconst result = [];\n\t\t\tconst regex = /([^\\s\"']+)|\"([^\"]*)\"|'([^']*)'/g;\n\t\t\tlet match;\n\n\t\t\twhile ((match = regex.exec(input)) !== null) {\n\t\t\t\tif (match[1]) {\n\t\t\t\t\tresult.push(match[1]);\n\t\t\t\t}\n\t\t\t\telse if (match[2]) {\n\t\t\t\t\tresult.push(match[2]);\n\t\t\t\t}\n\t\t\t\telse if (match[3]) {\n\t\t\t\t\tresult.push(match[3]);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn result;\n\t\t},\n\n\t\t/**\n\t\t * Accesses a property path in an object.\n\t\t * @param {Object} obj\n\t\t * @param {string} path\n\t\t * @returns {*}\n\t\t */\n\t\tgetProperty (obj, path) {\n\t\t\tif (!obj || typeof obj !== \"object\") {\n\t\t\t\treturn undefined;\n\t\t\t}\n\t\t\tif (typeof path !== \"string\") {\n\t\t\t\tthrow new Error(\"Path must be a string\");\n\t\t\t}\n\n\t\t\tconst parts = path.split(\".\");\n\t\t\tlet current = obj;\n\n\t\t\tfor (const part of parts) {\n\t\t\t\tif (current === null || current === undefined) {\n\t\t\t\t\treturn undefined;\n\t\t\t\t}\n\t\t\t\tcurrent = current[part];\n\t\t\t}\n\n\t\t\treturn current;\n\t\t},\n\n\t\t/**\n\t\t * Sets a property path in an object.\n\t\t * @param {Object} obj\n\t\t * @param {string} path\n\t\t * @param {*} value\n\t\t * @returns {Object}\n\t\t */\n\t\tsetProperty (obj, path, value) {\n\t\t\tif (!obj || typeof obj !== \"object\") {\n\t\t\t\tthrow new Error(\"Object must be an object\");\n\t\t\t}\n\t\t\tif (typeof path !== \"string\") {\n\t\t\t\tthrow new Error(\"Path must be a string\");\n\t\t\t}\n\n\t\t\tconst parts = path.split(\".\");\n\t\t\tlet current = obj;\n\n\t\t\tfor (let i = 0; i < parts.length - 1; i++) {\n\t\t\t\tconst part = parts[i];\n\t\t\t\tif (current[part] === undefined || current[part] === null) {\n\t\t\t\t\tcurrent[part] = {};\n\t\t\t\t}\n\t\t\t\tcurrent = current[part];\n\t\t\t}\n\n\t\t\tcurrent[parts[parts.length - 1]] = value;\n\t\t\treturn obj;\n\t\t},\n\n\t\t/**\n\t\t * Waits for a promise to resolve with a timeout.\n\t\t * @param {Promise} promise\n\t\t * @param {number} timeout\n\t\t * @returns {Promise}\n\t\t */\n\t\ttimeoutPromise (promise, timeout) {\n\t\t\treturn Promise.race([\n\t\t\t\tpromise,\n\t\t\t\tnew Promise((_, reject) => {\n\t\t\t\t\tsetTimeout(() => reject(new UtilsCustomError(\"Promise timed out\", {\n\t\t\t\t\t\tcode: \"PROMISE_TIMEOUT\"\n\t\t\t\t\t})), timeout);\n\t\t\t\t})\n\t\t\t]);\n\t\t},\n\n\t\t/**\n\t\t * Gets a value from a persisted data source.\n\t\t * This could be in memory, or from a file.\n\t\t * @param {string} key\n\t\t * @param {Object} [options]\n\t\t * @param {string} [options.scope] Scope to use when retrieving data\n\t\t * @returns {Promise<*>}\n\t\t */\n\t\tasync getPersistedData (key, options = {}) {\n\t\t\tif (typeof key !== \"string\") {\n\t\t\t\tthrow new Error(\"Key must be a string\");\n\t\t\t}\n\n\t\t\tconst cacheKey = `${options.scope ?? \"global\"}:${key}`;\n\t\t\tconst cached = persistedDataCache.get(cacheKey);\n\t\t\tif (cached !== undefined) {\n\t\t\t\treturn cached;\n\t\t\t}\n\n\t\t\t// First check for environment variables\n\t\t\tconst envKey = key.replace(/-/g, \"_\").toUpperCase();\n\t\t\tif (process.env[envKey]) {\n\t\t\t\treturn process.env[envKey];\n\t\t\t}\n\n\t\t\t// If config singleton is available, check that too\n\t\t\tif (typeof sb !== \"undefined\" && sb.Config) {\n\t\t\t\tconst configValue = sb.Config.get(key);\n\t\t\t\tif (configValue !== undefined) {\n\t\t\t\t\tpersistedDataCache.set(cacheKey, configValue);\n\t\t\t\t\treturn configValue;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Otherwise, try to read from file\n\t\t\ttry {\n\t\t\t\tconst { promises: fs } = require(\"fs\");\n\t\t\t\tconst path = require(\"path\");\n\t\t\t\tlet data;\n\n\t\t\t\t// Build the file path\n\t\t\t\tlet filePath;\n\t\t\t\tif (options.scope) {\n\t\t\t\t\tfilePath = path.join(process.cwd(), `.${key.toLowerCase()}-${options.scope}`);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tfilePath = path.join(process.cwd(), `.${key.toLowerCase()}`);\n\t\t\t\t}\n\n\t\t\t\ttry {\n\t\t\t\t\tdata = await fs.readFile(filePath, \"utf8\");\n\t\t\t\t\tdata = data.trim();\n\n\t\t\t\t\t// Try to parse as JSON if it looks like JSON\n\t\t\t\t\tif (data.startsWith(\"{\") || data.startsWith(\"[\")) {\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tdata = JSON.parse(data);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcatch (e) {\n\t\t\t\t\t\t\t// If not valid JSON, keep as string\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tpersistedDataCache.set(cacheKey, data);\n\t\t\t\t\treturn data;\n\t\t\t\t}\n\t\t\t\tcatch (e) {\n\t\t\t\t\tif (e.code === \"ENOENT\") {\n\t\t\t\t\t\treturn undefined;\n\t\t\t\t\t}\n\t\t\t\t\tthrow e;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (e) {\n\t\t\t\tconsole.error(`Error getting persisted data for key \"${key}\":`, e);\n\t\t\t\treturn undefined;\n\t\t\t}\n\t\t},\n\n\t\t/**\n\t\t * Convenience method for checking if an item exists in an array.\n\t\t * @param {Array} array\n\t\t * @param {*} item\n\t\t * @returns {boolean}\n\t\t */\n\t\thasItem (array, item) {\n\t\t\tif (!Array.isArray(array)) {\n\t\t\t\tthrow new Error(\"First argument must be an array\");\n\t\t\t}\n\t\t\treturn array.includes(item);\n\t\t},\n\n\t\t/**\n\t\t * Convenience method for filtering duplicates from an array.\n\t\t * @param {Array} array\n\t\t * @returns {Array}\n\t\t */\n\t\tremoveDuplicates (array) {\n\t\t\tif (!Array.isArray(array)) {\n\t\t\t\tthrow new Error(\"Argument must be an array\");\n\t\t\t}\n\t\t\treturn [...new Set(array)];\n\t\t},\n\n\t\t/**\n\t\t * Converts a query string to an object.\n\t\t * @param {string} queryString\n\t\t * @returns {Object}\n\t\t */\n\t\tparseQueryString (queryString) {\n\t\t\tif (typeof queryString !== \"string\") {\n\t\t\t\tthrow new Error(\"Query string must be a string\");\n\t\t\t}\n\n\t\t\tif (queryString.startsWith(\"?\")) {\n\t\t\t\tqueryString = queryString.slice(1);\n\t\t\t}\n\n\t\t\tconst params = new URLSearchParams(queryString);\n\t\t\tconst result = {};\n\n\t\t\tfor (const [key, value] of params) {\n\t\t\t\t// Try to parse numbers and booleans\n\t\t\t\tif (value === \"true\") {\n\t\t\t\t\tresult[key] = true;\n\t\t\t\t}\n\t\t\t\telse if (value === \"false\") {\n\t\t\t\t\tresult[key] = false;\n\t\t\t\t}\n\t\t\t\telse if (value === \"null\") {\n\t\t\t\t\tresult[key] = null;\n\t\t\t\t}\n\t\t\t\telse if (value === \"undefined\") {\n\t\t\t\t\tresult[key] = undefined;\n\t\t\t\t}\n\t\t\t\telse if (/^\\d+$/.test(value)) {\n\t\t\t\t\tresult[key] = parseInt(value, 10);\n\t\t\t\t}\n\t\t\t\telse if (/^\\d+\\.\\d+$/.test(value)) {\n\t\t\t\t\tresult[key] = parseFloat(value);\n\t\t\t\t}\n\t\t\t\telse if (value === \"\") {\n\t\t\t\t\tresult[key] = true; // Flag parameters\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tresult[key] = value;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn result;\n\t\t},\n\n\t\t/**\n\t\t * Checks if a value is a valid JSON string.\n\t\t * @param {string} str\n\t\t * @returns {boolean}\n\t\t */\n\t\tisValidJSON (str) {\n\t\t\tif (typeof str !== \"string\") {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\tJSON.parse(str);\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\tcatch (e) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t},\n\n\t\t/**\n\t\t * Escapes HTML entities in a string.\n\t\t * @param {string} str\n\t\t * @returns {string}\n\t\t */\n\t\tescapeHTML (str) {\n\t\t\tif (typeof str !== \"string\") {\n\t\t\t\tthrow new Error(\"Input must be a string\");\n\t\t\t}\n\n\t\t\treturn str\n\t\t\t\t.replace(/&/g, \"&amp;\")\n\t\t\t\t.replace(/</g, \"&lt;\")\n\t\t\t\t.replace(/>/g, \"&gt;\")\n\t\t\t\t.replace(/\"/g, \"&quot;\")\n\t\t\t\t.replace(/'/g, \"&#039;\");\n\t\t},\n\n\t\t/**\n\t\t * Wraps a string with prefix and suffix.\n\t\t * @param {string} str\n\t\t * @param {string} prefix\n\t\t * @param {string} suffix\n\t\t * @returns {string}\n\t\t */\n\t\twrapString (str, prefix, suffix) {\n\t\t\tif (typeof str !== \"string\") {\n\t\t\t\tthrow new Error(\"String must be a string\");\n\t\t\t}\n\t\t\tif (typeof prefix !== \"string\") {\n\t\t\t\tthrow new Error(\"Prefix must be a string\");\n\t\t\t}\n\t\t\tif (typeof suffix !== \"string\") {\n\t\t\t\tthrow new Error(\"Suffix must be a string\");\n\t\t\t}\n\n\t\t\treturn `${prefix}${str}${suffix}`;\n\t\t},\n\n\t\t/**\n\t\t * Checks if a string contains another string.\n\t\t * @param {string} str\n\t\t * @param {string} substring\n\t\t * @param {boolean} caseSensitive\n\t\t * @returns {boolean}\n\t\t */\n\t\tcontains (str, substring, caseSensitive = true) {\n\t\t\tif (typeof str !== \"string\") {\n\t\t\t\tthrow new Error(\"String must be a string\");\n\t\t\t}\n\t\t\tif (typeof substring !== \"string\") {\n\t\t\t\tthrow new Error(\"Substring must be a string\");\n\t\t\t}\n\n\t\t\tif (caseSensitive) {\n\t\t\t\treturn str.includes(substring);\n\t\t\t}\n\t\t\telse {\n\t\t\t\treturn str.toLowerCase().includes(substring.toLowerCase());\n\t\t\t}\n\t\t},\n\n\t\t/**\n\t\t * Creates a custom error instance.\n\t\t * @param {string} message\n\t\t * @param {Object} [options]\n\t\t * @returns {UtilsCustomError}\n\t\t */\n\t\tcreateError (message, options) {\n\t\t\treturn new UtilsCustomError(message, options);\n\t\t},\n\n\t\t/**\n\t\t * Checks if a value is an object and not null or an array.\n\t\t * @param {*} value\n\t\t * @returns {boolean}\n\t\t */\n\t\tisObject (value) {\n\t\t\treturn value !== null && typeof value === \"object\" && !Array.isArray(value);\n\t\t},\n\n\t\t/**\n\t\t * Validates a URL string.\n\t\t * @param {string} url\n\t\t * @returns {boolean}\n\t\t */\n\t\tisValidURL (url) {\n\t\t\ttry {\n\t\t\t\tconst parsed = new URL(url);\n\t\t\t\treturn [\"http:\", \"https:\"].includes(parsed.protocol);\n\t\t\t}\n\t\t\tcatch (e) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t},\n\n\t\t/**\n\t\t * @param {string} platform \n\t\t * @returns {Function}\n\t\t */\n\t\tcreateTagFunction (platform) {\n\t\t\tif (platform === \"discord\") {\n\t\t\t\treturn (tagType, id, text) => {\n\t\t\t\t\tif (tagType === \"channel\") {\n\t\t\t\t\t\treturn `<#${id}>`;\n\t\t\t\t\t}\n\t\t\t\t\telse if (tagType === \"user\") {\n\t\t\t\t\t\treturn text ? `<@${id}> (${text})` : `<@${id}>`;\n\t\t\t\t\t}\n\t\t\t\t\telse if (tagType === \"role\") {\n\t\t\t\t\t\treturn text ? `<@&${id}> (${text})` : `<@&${id}>`;\n\t\t\t\t\t}\n\t\t\t\t\telse if (tagType === \"emoji\") {\n\t\t\t\t\t\treturn text ? `<:${id}:${text}>` : id;\n\t\t\t\t\t}\n\t\t\t\t\telse if (tagType === \"timestamp\") {\n\t\t\t\t\t\tconst format = text ?? \"f\";\n\t\t\t\t\t\treturn `<t:${Math.floor(id / 1000)}:${format}>`;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\treturn id;\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t}\n\t\t\telse {\n\t\t\t\treturn () => null;\n\t\t\t}\n\t\t}\n\t};\n\n\treturn class UtilsManager extends Singleton {\n\t\t/**\n\t\t * @returns {Utils}\n\t\t */\n\t\tstatic get get () {\n\t\t\treturn this.module || Utils;\n\t\t}\n\n\t\t/**\n\t\t * Creates the Utils singleton and returns it.\n\t\t * @returns {Utils}\n\t\t */\n\t\tstatic initialize () {\n\t\t\tconst utilsModule = { ...Utils };\n\t\t\tutilsModule.error = UtilsCustomError;\n\t\t\tutilsModule.Error = UtilsCustomError;\n\n\t\t\tthis.module = utilsModule;\n\t\t\treturn utilsModule;\n\t\t}\n\n\t\t/**\n\t\t * Destroys the singleton instance.\n\t\t */\n\t\tstatic destroy () {\n\t\t\tthis.module = null;\n\t\t}\n\t};\n})();\n\u0005End File\u0006# Supinic/supibot\n# singletons/config/index.js\nmodule.exports = (function () {\n\t\"use strict\";\n\n\tconst crypto = require(\"crypto\");\n\tconst Singleton = require(\"../singleton.js\");\n\tconst SecretCache = require(\"../../secret-cache.js\");\n\n\t/**\n\t * Handles all kinds of configurations.\n\t * @name sb.Config\n\t * @type Config()\n\t */\n\tclass Config extends Singleton {\n\t\tconstructor () {\n\t\t\tsuper();\n\t\t\tthis.data = {};\n\t\t\tthis.configData = {};\n\t\t\tthis.configurationDescriptions = {};\n\t\t\tthis.loaded = false;\n\t\t}\n\n\t\t/**\n\t\t * Loads data from database.\n\t\t */\n\t\tasync load () {\n\t\t\t// Default values - first check if available from sb.Query\n\t\t\tif (typeof sb === \"undefined\" || !sb.Query) {\n\t\t\t\tconsole.log(\"sb.Query not available for Config data yet, using fallback\");\n\t\t\t\tif (!this.loaded) {\n\t\t\t\t\tawait this.loadConfigFromSecrets();\n\t\t\t\t}\n\n\t\t\t\tthis.loaded = true;\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Otherwise query the database for configurations\n\t\t\tconst data = await sb.Query.getRecordset(rs => rs\n\t\t\t\t.select(\"*\")\n\t\t\t\t.from(\"chat_data\", \"Config\")\n\t\t\t);\n\n\t\t\tthis.configData = {};\n\t\t\tfor (const row of data) {\n\t\t\t\tthis.configData[row.Name] = {\n\t\t\t\t\tvalue: row.Value,\n\t\t\t\t\tlastUpdate: row.Last_Update,\n\t\t\t\t\ttype: row.Type\n\t\t\t\t};\n\t\t\t}\n\n\t\t\t// Also load the description tables\n\t\t\tconst descriptions = await sb.Query.getRecordset(rs => rs\n\t\t\t\t.select(\"*\")\n\t\t\t\t.from(\"chat_data\", \"Config_Description\")\n\t\t\t);\n\n\t\t\tthis.configurationDescriptions = {};\n\t\t\tfor (const row of descriptions) {\n\t\t\t\tthis.configurationDescriptions[row.Name] = {\n\t\t\t\t\tdescription: row.Description ?? null,\n\t\t\t\t\ttype: row.Type ?? null,\n\t\t\t\t\tunit: row.Unit ?? null\n\t\t\t\t};\n\t\t\t}\n\n\t\t\tthis.loaded = true;\n\t\t}\n\n\t\t/**\n\t\t * Loads config from secrets when database is not available yet\n\t\t */\n\t\tasync loadConfigFromSecrets () {\n\t\t\ttry {\n\t\t\t\tconst configs = await SecretCache.get(\"Config\", { array: true });\n\t\t\t\tif (!configs) {\n\t\t\t\t\tconsole.warn(\"No Config secrets found, using empty config\");\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\t// Pre-process the configs\n\t\t\t\tthis.configData = {};\n\t\t\t\tfor (const config of configs) {\n\t\t\t\t\tthis.configData[config.Name] = {\n\t\t\t\t\t\tvalue: config.Value,\n\t\t\t\t\t\tlastUpdate: config.Last_Update ?? new Date(),\n\t\t\t\t\t\ttype: config.Type ?? \"string\"\n\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (e) {\n\t\t\t\tconsole.error(\"Error loading config from secrets\", e);\n\t\t\t}\n\t\t}\n\n\t\t/**\n\t\t * Returns a specific configuration value.\n\t\t * @param {string} key Configuration name\n\t\t * @returns {*}\n\t\t */\n\t\tget (key) {\n\t\t\tif (!this.loaded) {\n\t\t\t\tconsole.warn(\"Using sb.Config before it is loaded - this may result in unexpected behaviour\");\n\t\t\t}\n\n\t\t\t// First, check if the environment provides the key\n\t\t\tif (typeof process.env[key] !== \"undefined\") {\n\t\t\t\treturn process.env[key];\n\t\t\t}\n\n\t\t\tif (key in this.configData) {\n\t\t\t\tconst value = this.configData[key].value;\n\t\t\t\tconst type = this.configData[key].type;\n\n\t\t\t\tif (type === \"boolean\") {\n\t\t\t\t\tif (typeof value === \"boolean\") {\n\t\t\t\t\t\treturn value;\n\t\t\t\t\t}\n\t\t\t\t\telse if (typeof value === \"string\") {\n\t\t\t\t\t\tif (value === \"true\") {\n\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if (value === \"false\") {\n\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\treturn Boolean(value);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse if (typeof value === \"number\") {\n\t\t\t\t\t\treturn Boolean(value);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if (type === \"number\") {\n\t\t\t\t\tif (typeof value === \"number\") {\n\t\t\t\t\t\treturn value;\n\t\t\t\t\t}\n\t\t\t\t\telse if (typeof value === \"string\") {\n\t\t\t\t\t\treturn Number(value);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if (type === \"string\") {\n\t\t\t\t\tif (typeof value === \"string\") {\n\t\t\t\t\t\treturn value;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\treturn String(value);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if (type === \"object\" || type === \"array\") {\n\t\t\t\t\tif (typeof value === \"object\") {\n\t\t\t\t\t\treturn value;\n\t\t\t\t\t}\n\t\t\t\t\telse if (typeof value === \"string\") {\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\treturn JSON.parse(value);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcatch {\n\t\t\t\t\t\t\treturn value;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn value;\n\t\t\t}\n\n\t\t\treturn null;\n\t\t}\n\n\t\t/**\n\t\t * Sets a configuration variable.\n\t\t * @param {string} key Config key\n\t\t * @param {*} value Config value\n\t\t * @returns {Promise<boolean>} True if successful, false otherwise\n\t\t */\n\t\tasync set (key, value) {\n\t\t\tif (!this.loaded) {\n\t\t\t\tconsole.warn(\"Using sb.Config before it is loaded - this may result in unexpected behaviour\");\n\t\t\t}\n\n\t\t\tif (typeof key !== \"string\") {\n\t\t\t\tthrow new Error(\"Config key must be a string\");\n\t\t\t}\n\n\t\t\tif (value === undefined) {\n\t\t\t\tthrow new Error(\"Config value cannot be undefined\");\n\t\t\t}\n\n\t\t\t// If database is not available, set only in memory\n\t\t\tif (typeof sb === \"undefined\" || !sb.Query) {\n\t\t\t\tthis.configData[key] = {\n\t\t\t\t\tvalue,\n\t\t\t\t\tlastUpdate: new Date(),\n\t\t\t\t\ttype: typeof value\n\t\t\t\t};\n\t\t\t\treturn true;\n\t\t\t}\n\n\t\t\t// Check if config exists\n\t\t\tconst exists = Boolean(await sb.Query.getRecordset(rs => rs\n\t\t\t\t.select(\"Name\")\n\t\t\t\t.from(\"chat_data\", \"Config\")\n\t\t\t\t.where(\"Name =",
    "10-important-documentations-product-mana|category|1": "Produkthantering",
    "10-important-documentations-product-mana|category|2": "Dokumentationsportaler",
    "10-important-documentations-product-mana|category|3": "Bästa praxis",
    "10-important-documentations-product-mana|category|4": "Produktchefer"
}